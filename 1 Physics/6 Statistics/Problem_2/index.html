<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Problem 2 - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Problem 2";
        var mkdocs_page_input_path = "1 Physics/6 Statistics/Problem_2.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Circuits</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../5%20Circuits/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">6 Statistics</a>
<ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2 current"><a class="reference internal current" href="#">Problem 2</a>
<ul class="current">
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">6 Statistics</li>
<li class="breadcrumb-item active">Problem 2</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="problem-2">Problem 2</h1>
<h1 id="section-1-approximating-using-a-circle">📘 Section 1: Approximating π Using a Circle</h1>
<h2 id="1-theoretical-background">1. Theoretical Background</h2>
<h3 id="conceptual-insight">🧠 Conceptual Insight</h3>
<p>Monte Carlo techniques apply randomness to tackle problems that are fundamentally deterministic. To approximate π, we leverage the geometric connection between a circle and the square that encloses it:</p>
<ul>
<li>Imagine a <strong>unit circle</strong> (radius = 1) centered at the origin (0, 0).</li>
<li>This circle fits perfectly within a <strong>square</strong> with a side length of 2, spanning coordinates from (-1, -1) to (1, 1).</li>
<li>The <strong>area</strong> of the unit circle is:</li>
</ul>
<p>$$
  A_{circle} = \pi r^2 = \pi \cdot 1^2 = \pi
  $$</p>
<ul>
<li>The <strong>area</strong> of the surrounding square is:</li>
</ul>
<p>$$
  A_{square} = (2r)^2 = (2 \cdot 1)^2 = 4
  $$</p>
<ul>
<li>The ratio between these areas becomes:</li>
</ul>
<p>$$
  \frac{A_{circle}}{A_{square}} = \frac{\pi}{4}
  $$</p>
<p>So, when we uniformly sample points at random within the square, the <strong>likelihood</strong> that a point lands inside the circle is:</p>
<p>$$
  P(\text{point inside circle}) = \frac{\pi}{4}
  $$</p>
<h3 id="estimating-via-monte-carlo">🔢 Estimating π via Monte Carlo</h3>
<p>To derive π using this probabilistic approach:</p>
<ol>
<li><strong>Generate</strong> many random coordinate pairs <span class="arithmatex">\((x, y)\)</span> in the square <span class="arithmatex">\([-1, 1] \times [-1, 1]\)</span>.</li>
<li><strong>Determine</strong> whether each point lies within the unit circle using:</li>
</ol>
<p>$$
   x^2 + y^2 \leq 1
   $$</p>
<ol>
<li><strong>Record</strong> the number of points that fall inside the circle: <span class="arithmatex">\(N_{circle}\)</span></li>
<li><strong>Note</strong> the total number of sampled points: <span class="arithmatex">\(N_{total}\)</span></li>
<li>Estimate π using the expression:</li>
</ol>
<p>$$
   \hat{\pi} = 4 \cdot \frac{N_{circle}}{N_{total}}
   $$</p>
<h3 id="key-takeaways">✅ Key Takeaways</h3>
<ul>
<li>Monte Carlo estimation of π depends on simulating random events and comparing relative counts.</li>
<li>The more points you sample (<span class="arithmatex">\(N_{total}\)</span>), the closer the estimate gets to the true value of π.</li>
<li>This strategy intuitively combines <strong>geometry, probability, and numerical simulation</strong>.</li>
</ul>
<p><img alt="alt text" src="../image-4.png"/></p>
<pre><code class="language-python">import matplotlib.pyplot as plt
import numpy as np

# Set a fixed seed for reproducibility
np.random.seed(42)

# Total number of random points
N_total = 10000

# Generate random (x, y) pairs between -1 and 1
x = np.random.uniform(-1, 1, N_total)
y = np.random.uniform(-1, 1, N_total)

# Compute whether each point falls inside the unit circle
inside_circle = x**2 + y**2 &lt;= 1

# Estimate pi
N_circle = np.sum(inside_circle)
pi_estimate = 4 * N_circle / N_total

# Create the plot
fig, ax = plt.subplots(figsize=(6, 6))
ax.set_aspect("equal")

# Plot inside-circle points in maroon (bordo), outside in blue (mavi)
ax.scatter(x[inside_circle], y[inside_circle], color="#800000", s=1, label='Inside Circle')
ax.scatter(x[~inside_circle], y[~inside_circle], color="#0077B6", s=1, label='Outside Circle')

# Draw the unit circle for reference
circle = plt.Circle((0, 0), 1, edgecolor="#800000", facecolor='none', linewidth=1.5, linestyle='--')
ax.add_patch(circle)

# Aesthetic settings
ax.set_title(f"Monte Carlo π Estimation\nEstimated π ≈ {pi_estimate:.5f}", fontsize=12, color="#800000")
ax.set_xlabel("x-axis", fontsize=10)
ax.set_ylabel("y-axis", fontsize=10)
ax.legend(loc="upper right", fontsize=9)
ax.set_xlim([-1, 1])
ax.set_ylim([-1, 1])
ax.grid(True, linestyle=':', alpha=0.6)

plt.tight_layout()
plt.show()
</code></pre>
<hr/>
<h3 id="2-running-the-simulation">🖥 2. Running the Simulation</h3>
<p>In this part, we carry out a Monte Carlo simulation to approximate the value of π by randomly placing points within a square and evaluating how many land inside a circle inscribed within it.</p>
<h3 id="simulation-procedure">🧪 Simulation Procedure</h3>
<ul>
<li>We define a <strong>unit circle</strong> with radius 1, centered at the origin <span class="arithmatex">\((0,0)\)</span>.</li>
<li>This circle is perfectly enclosed in a <strong>square</strong> with side length 2, spanning the coordinate range:</li>
</ul>
<p>$$
  [-1, 1] \times [-1, 1]
  $$</p>
<ul>
<li>The core idea is to generate <span class="arithmatex">\(N\)</span> random coordinate pairs <span class="arithmatex">\((x, y)\)</span> uniformly across the square and determine how many fall within the bounds of the circle.</li>
</ul>
<h3 id="condition-for-being-inside-the-circle">➕ Condition for Being Inside the Circle</h3>
<ul>
<li>A point <span class="arithmatex">\((x, y)\)</span> is considered <strong>within the circle</strong> if it satisfies the inequality:</li>
</ul>
<p>$$
  x^2 + y^2 \leq 1
  $$</p>
<ul>
<li>Let <span class="arithmatex">\(N_{\text{circle}}\)</span> represent the number of such valid points.</li>
<li>Let <span class="arithmatex">\(N_{\text{total}}\)</span> be the full count of generated points.</li>
</ul>
<h3 id="formula-for-estimating">🔢 Formula for Estimating π</h3>
<ul>
<li>The theoretical chance that a point falls inside the circle is approximately:</li>
</ul>
<p>$$
  P = \frac{\pi}{4}
  $$</p>
<ul>
<li>Hence, the Monte Carlo estimate for π becomes:</li>
</ul>
<p>$$
  \hat{\pi} = 4 \cdot \frac{N_{\text{circle}}}{N_{\text{total}}}
  $$</p>
<h3 id="observations">📝 Observations</h3>
<ul>
<li>Increasing <span class="arithmatex">\(N_{\text{total}}\)</span> typically leads to a more precise approximation of π.</li>
<li>Since the simulation is based on random sampling, results may vary slightly with each run.</li>
<li>This method is conceptually straightforward and provides a visual, hands-on way to explore mathematical estimation.</li>
</ul>
<h2 id="this-simulation-highlights-how-random-sampling-and-geometry-can-work-together-to-approximate-a-fundamental-constant-like">&gt; ✅ This simulation highlights how random sampling and geometry can work together to approximate a fundamental constant like π.</h2>
<h3 id="3-visualization">3. Visualization</h3>
<p>The Python script below produces a scatter plot, differentiating between points that land inside versus outside the circle.</p>
<p><img alt="alt text" src="../monte_carlo_pi.gif"/></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# Set random seed for reproducibility
np.random.seed(42)

def estimate_pi_circle(N):
    # Generate N random points in [-1, 1] x [-1, 1]
    x = np.random.uniform(-1, 1, N)
    y = np.random.uniform(-1, 1, N)

    # Check which points lie inside the unit circle
    inside_circle = x**2 + y**2 &lt;= 1
    M = np.sum(inside_circle)

    # Estimate pi
    pi_estimate = 4 * M / N

    return x, y, inside_circle, pi_estimate

# Run simulation with N = 10000
N = 10000
x, y, inside_circle, pi_estimate = estimate_pi_circle(N)

# Plot
plt.figure(figsize=(8, 8))
plt.scatter(x[inside_circle], y[inside_circle], c='blue', s=1, label='Inside Circle')
plt.scatter(x[~inside_circle], y[~inside_circle], c='red', s=1, label='Outside Circle')
circle = plt.Circle((0, 0), 1, edgecolor='black', facecolor='none')
plt.gca().add_patch(circle)
plt.gca().set_aspect('equal')
plt.xlim(-1, 1)
plt.ylim(-1, 1)
plt.title(f'Circle Method: π ≈ {pi_estimate:.5f}, N = {N}')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.grid(True)
plt.show()

print(f"Estimated π: {pi_estimate}")
</code></pre>
<h3 id="4-analysis">4 Analysis</h3>
<p><img alt="alt text" src="../image-5.png"/></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# Dark theme setup
plt.style.use('dark_background')

# Monte Carlo π estimation function
def estimate_pi_circle(N):
    np.random.seed(0)
    x = np.random.rand(N)
    y = np.random.rand(N)
    inside_circle = (x**2 + y**2) &lt;= 1
    count_inside = np.sum(inside_circle)
    pi_estimate = 4 * count_inside / N
    return x, y, inside_circle, pi_estimate

# Sample sizes (logarithmic scale)
Ns = np.logspace(2, 6, num=50, dtype=int)
errors = []
pi_true = np.pi

for N in Ns:
    _, _, _, pi_estimate = estimate_pi_circle(N)
    errors.append(abs(pi_estimate - pi_true))

# Plotting
plt.figure(figsize=(10, 6))
plt.loglog(
    Ns, errors,
    marker='o',
    linestyle='-',
    color='#800000',               # Bordo line
    markerfacecolor='#00BFFF',     # Mavi markers
    markeredgecolor='#800000',
    label='Absolute Error'
)

plt.title('Convergence of Monte Carlo π Estimation', fontsize=14, color='white')
plt.xlabel('Number of Points (N)', fontsize=12, color='white')
plt.ylabel('Absolute Error |π_estimate − π|', fontsize=12, color='white')
plt.grid(True, which='both', linestyle='--', linewidth=0.5, color='gray')
plt.legend(facecolor='#1e1e1e', edgecolor='white')
plt.tight_layout()
plt.show()
</code></pre>
<h1 id="section-2-approximating-using-buffons-experiment">✅ SECTION 2: Approximating π Using Buffon’s Experiment</h1>
<h2 id="1-conceptual-framework">📘 1. Conceptual Framework</h2>
<h3 id="introduction-to-buffons-needle-puzzle">🧠 Introduction to Buffon’s Needle Puzzle</h3>
<p>Buffon’s Needle is a classic probability puzzle that offers a technique to approximate π through random trials involving dropping a needle onto a surface marked with parallel lines. The puzzle investigates the likelihood that a needle of length <span class="arithmatex">\(L\)</span> dropped randomly onto a floor with parallel lines spaced <span class="arithmatex">\(d\)</span> units apart will intersect one of these lines.</p>
<hr/>
<h3 id="puzzle-configuration-and-presumptions">🔍 Puzzle Configuration and Presumptions</h3>
<ul>
<li>The surface features <strong>parallel lines</strong> separated by a distance <span class="arithmatex">\(d\)</span>.</li>
<li>A needle of length <span class="arithmatex">\(L\)</span> is randomly cast onto the surface.</li>
<li>The needle’s placement is defined by:</li>
<li>The separation <span class="arithmatex">\(x\)</span> from the needle’s midpoint to the closest line (where <span class="arithmatex">\(0 \leq x \leq \frac{d}{2}\)</span>).</li>
<li>The angle <span class="arithmatex">\(\theta\)</span> between the needle and the parallel lines, with <span class="arithmatex">\(\theta\)</span> being uniformly distributed within <span class="arithmatex">\([0, \frac{\pi}{2}]\)</span> due to symmetry.</li>
</ul>
<hr/>
<h3 id="requirement-for-needle-intersecting-a-line">📐 Requirement for Needle Intersecting a Line</h3>
<p>The needle intersects a line if the separation from its midpoint to the nearest line is less than or equal to half of the needle’s projected length on the axis perpendicular to the lines:</p>
<div class="arithmatex">\[
x \leq \frac{L}{2} \sin \theta
\]</div>
<hr/>
<h3 id="likelihood-of-intersection">📊 Likelihood of Intersection</h3>
<p>The probability <span class="arithmatex">\(P\)</span> that a needle intersects a line is derived by integrating across all possible positions and orientations, resulting in:</p>
<div class="arithmatex">\[
P = \frac{2L}{\pi d}
\]</div>
<p><em>This formula assumes <span class="arithmatex">\(L \leq d\)</span>.</em></p>
<hr/>
<h3 id="derivation-of-the-approximation-formula">🔢 Derivation of the π Approximation Formula</h3>
<p>Let:</p>
<ul>
<li><span class="arithmatex">\(L\)</span> = length of the needle</li>
<li><span class="arithmatex">\(d\)</span> = spacing between the parallel lines</li>
<li><span class="arithmatex">\(N\)</span> = total count of needle drops</li>
<li><span class="arithmatex">\(C\)</span> = count of instances the needle intersects a line</li>
</ul>
<p>From the observed empirical probability,</p>
<div class="arithmatex">\[
P \approx \frac{C}{N}
\]</div>
<p>and equating to the theoretical probability,</p>
<div class="arithmatex">\[
\frac{C}{N} \approx \frac{2L}{\pi d}
\]</div>
<p>Solving for π, we obtain the estimate:</p>
<div class="arithmatex">\[
\boxed{
\pi \approx \frac{2 L N}{d C}
}
\]</div>
<hr/>
<h3 id="conclusion">✅ Conclusion</h3>
<ul>
<li>Buffon’s Needle puzzle links geometry and probability to estimate π.</li>
<li>It presents an elegant, physical experiment-based approach to numerical approximation.</li>
<li>Precision enhances as <span class="arithmatex">\(N\)</span> (number of needle drops) rises.</li>
<li>The puzzle serves as a fundamental instance in geometric probability and Monte Carlo techniques.</li>
</ul>
<h2 id="2-emulation">2. Emulation</h2>
<p>We now proceed to implement the emulation of Buffon’s Needle experiment to approximate π.</p>
<h3 id="emulation-procedure">Emulation Procedure</h3>
<ul>
<li><strong>Step 1:</strong> Emulate <span class="arithmatex">\(N\)</span> random needle drops on a surface with parallel lines spaced by distance <span class="arithmatex">\(d\)</span>.</li>
<li><strong>Step 2:</strong> For each needle drop:</li>
<li>Sample the needle's midpoint position <span class="arithmatex">\(x\)</span> uniformly from <span class="arithmatex">\([0, d/2]\)</span>.</li>
<li>Sample the needle's orientation angle <span class="arithmatex">\(\theta\)</span> uniformly from <span class="arithmatex">\([0, \pi/2]\)</span>.</li>
<li><strong>Step 3:</strong> Ascertain whether the needle intersects a line by verifying the condition:</li>
</ul>
<div class="arithmatex">\[
x \leq \frac{L}{2} \sin \theta
\]</div>
<ul>
<li><strong>Step 4:</strong> Tally the number of intersections <span class="arithmatex">\(C\)</span>.</li>
<li><strong>Step 5:</strong> Approximate π using the formula:</li>
</ul>
<div class="arithmatex">\[
\hat{\pi} = \frac{2 L N}{d C}
\]</div>
<h3 id="3-visual-representation">3 Visual Representation</h3>
<p><img alt="alt text" src="../image-6.png"/></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# Set random seed
np.random.seed(42)

def estimate_pi_buffon(N, l=1, d=1):
    # Random midpoint x (y is irrelevant for horizontal lines), and angle theta
    x_mid = np.random.uniform(0, d, N)  # Midpoint x between 0 and d
    theta = np.random.uniform(0, np.pi/2, N)  # Angle between 0 and π/2

    # Distance from midpoint to nearest line
    crossings = np.abs(l/2 * np.sin(theta)) &gt;= (x_mid % d)
    M = np.sum(crossings)

    # Estimate pi
    pi_estimate = 2 * N / M if M &gt; 0 else np.inf

    return x_mid, theta, crossings, pi_estimate

# Run simulation with N = 1000
N = 1000
x_mid, theta, crossings, pi_estimate = estimate_pi_buffon(N)

# Plot
plt.figure(figsize=(10, 4), facecolor='#222222')  # Dark background
ax = plt.gca()
ax.set_facecolor('#222222')
ax.tick_params(axis='x', colors='white')
ax.tick_params(axis='y', colors='white')
ax.spines['bottom'].set_color('white')
ax.spines['top'].set_color('white')
ax.spines['left'].set_color('white')
ax.spines['right'].set_color('white')

for i in range(min(N, 50)):  # Plot up to 50 needles
    x_c = x_mid[i]
    t = theta[i]
    x1 = x_c - 0.5 * np.cos(t)
    x2 = x_c + 0.5 * np.cos(t)
    y1 = -0.5 * np.sin(t)
    y2 = 0.5 * np.sin(t)
    color = '#B22222' if crossings[i] else '#00BFFF'  # bordo and mavi
    plt.plot([x1, x2], [y1, y2], color, alpha=0.5)

# Plot lines
for x in [0, 1]:
    plt.axvline(x, color='white', linestyle='--')

plt.title(f'Buffon’s Needle: π ≈ {pi_estimate:.5f}, N = {N}', color='white')
plt.xlabel('x', color='white')
plt.ylabel('y', color='white')
plt.gca().set_aspect('equal')
plt.grid(True, color='gray', alpha=0.2)
plt.show()

print(f"Estimated π: {pi_estimate}")
</code></pre>
<h2 id="4-evaluation">4. Evaluation</h2>
<p>We examine the convergence behavior of the Buffon’s Needle simulation and contrast it with the circle-based Monte Carlo technique for approximating π.</p>
<hr/>
<h3 id="aims">🔍 Aims</h3>
<ul>
<li>Execute the Buffon’s Needle simulation for increasing counts of throws <span class="arithmatex">\(N\)</span>.</li>
<li>Observe how the approximation of π enhances (converges) as <span class="arithmatex">\(N\)</span> increases.</li>
<li>Chart the convergence of π approximations against the number of throws.</li>
<li>Assess the convergence speed and precision against the circle-based Monte Carlo method.</li>
</ul>
<hr/>
<h3 id="approach">📈 Approach</h3>
<ul>
<li>Define a sequence of sample sizes: <span class="arithmatex">\(N_1 &lt; N_2 &lt; \dots &lt; N_k\)</span>.</li>
<li>For each <span class="arithmatex">\(N_i\)</span>:</li>
<li>Execute the Buffon’s Needle simulation and document the approximated π value, <span class="arithmatex">\(\hat{\pi}_{needle}(N_i)\)</span>.</li>
<li>Execute the circle-based Monte Carlo simulation and document the approximated π value, <span class="arithmatex">\(\hat{\pi}_{circle}(N_i)\)</span>.</li>
<li>Plot <span class="arithmatex">\(\hat{\pi}\)</span> vs. <span class="arithmatex">\(N\)</span> for both methods on a shared graph.</li>
<li>Evaluate the error:</li>
</ul>
<div class="arithmatex">\[
\text{Error}(N) = \left|\pi - \hat{\pi}(N)\right|
\]</div>
<hr/>
<h3 id="python-implementation-for-evaluation">🔧 Python Implementation for Evaluation</h3>
<p><img alt="alt text" src="../image-7.png"/></p>
<p><img alt="alt text" src="../image-8.png"/></p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt

# Buffon's Needle simulation function
def buffon_needle_pi_estimate(L, d, N):
    x_centers = np.random.uniform(0, d/2, N)
    angles = np.random.uniform(0, np.pi/2, N)
    crossings = x_centers &lt;= (L/2)*np.sin(angles)
    C = np.sum(crossings)
    if C == 0:
        return np.nan
    return (2 * L * N) / (d * C)

# Circle-based Monte Carlo π estimation
def monte_carlo_circle_pi(N):
    points = np.random.uniform(-1, 1, (N, 2))
    inside_circle = np.sum(points[:,0]**2 + points[:,1]**2 &lt;= 1)
    return 4 * inside_circle / N

# Parameters
L = 1.0
d = 1.5
sample_sizes = np.logspace(2, 5, num=20, dtype=int)  # From 100 to 100,000 throws

needle_estimates = []
circle_estimates = []

for N in sample_sizes:
    pi_needle = buffon_needle_pi_estimate(L, d, N)
    pi_circle = monte_carlo_circle_pi(N)
    needle_estimates.append(pi_needle)
    circle_estimates.append(pi_circle)

# Define custom colors
bordo = '#800000'  # A shade of red for 'bordo'
mavi = '#1E90FF'   # A shade of blue for 'mavi'
dark_background = '#282C34' # A dark gray background

# Plotting convergence
plt.figure(figsize=(10, 6), facecolor=dark_background)
ax1 = plt.gca()
ax1.set_facecolor(dark_background)

plt.plot(sample_sizes, needle_estimates, 'o-', label="Buffon's Needle", color=bordo, markersize=6, linewidth=1.5)
plt.plot(sample_sizes, circle_estimates, 's-', label="Circle Monte Carlo", color=mavi, markersize=6, linewidth=1.5)
plt.axhline(np.pi, color='lightgray', linestyle='--', label="True π", linewidth=1.5) # True pi line
plt.xscale('log')

# Set text and tick colors to white for better contrast on dark background
ax1.set_xlabel("Number of Throws (log scale)", color='white')
ax1.set_ylabel("Estimated π", color='white')
ax1.set_title("Convergence of π Estimation Methods", color='white')
ax1.tick_params(axis='x', colors='white')
ax1.tick_params(axis='y', colors='white')
ax1.spines['bottom'].set_color('white')
ax1.spines['top'].set_color('white')
ax1.spines['left'].set_color('white')
ax1.spines['right'].set_color('white')
plt.legend(labelcolor='white')
plt.grid(True, linestyle=':', alpha=0.6, color='gray')
plt.show()

# Plot absolute errors
plt.figure(figsize=(10, 6), facecolor=dark_background)
ax2 = plt.gca()
ax2.set_facecolor(dark_background)

plt.plot(sample_sizes, np.abs(np.pi - np.array(needle_estimates)), 'o-', label="Buffon's Needle Error", color=bordo, markersize=6, linewidth=1.5)
plt.plot(sample_sizes, np.abs(np.pi - np.array(circle_estimates)), 's-', label="Circle Monte Carlo Error", color=mavi, markersize=6, linewidth=1.5)
plt.xscale('log')
plt.yscale('log')

# Set text and tick colors to white for better contrast on dark background
ax2.set_xlabel("Number of Throws (log scale)", color='white')
ax2.set_ylabel("Absolute Error (log scale)", color='white')
ax2.set_title("Error Convergence of π Estimation Methods", color='white')
ax2.tick_params(axis='x', colors='white')
ax2.tick_params(axis='y', colors='white')
ax2.spines['bottom'].set_color('white')
ax2.spines['top'].set_color('white')
ax2.spines['left'].set_color('white')
ax2.spines['right'].set_color('white')
plt.legend(labelcolor='white')
plt.grid(True, which="both", linestyle=':', alpha=0.6, color='gray')
plt.show()
</code></pre>
<hr/>
<h2 id="observations_1">Observations</h2>
<p>Both techniques demonstrate a tendency to converge towards the actual value of π as the count of trials rises. The <strong>circle-based Monte Carlo approach</strong> generally exhibits quicker convergence and reduced variability for an equivalent number of samples. Conversely, the <strong>Buffon's Needle technique</strong>, despite its historical charm and elegance, might necessitate a greater number of samples to attain a comparable level of precision. The plots presented on a <strong>logarithmic scale</strong> effectively underscore the rate at which the error diminishes with an increasing number of samples.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../Problem_1/" title="Problem 1"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../7%20Measurements/Problem_1/" title="Problem 1">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../7%20Measurements/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
