{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection Physics | Gravity | KW1 Assignment Author: capitala61 Date: March 30, 2025 Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation 1.1 Governing Equations of Motion To analyze projectile motion, we start by applying the fundamental laws of motion under constant acceleration, particularly the law of gravity. The two-dimensional motion of a projectile is governed by the following equations: Horizontal Motion The acceleration in the horizontal direction is zero (assuming no air resistance), so the horizontal velocity remains constant. \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] where: \\(x(t)\\) is the horizontal position of the projectile at time \\(t\\) , \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle. Vertical Motion The vertical motion is influenced by gravity. The velocity in the vertical direction is affected by gravitational acceleration ( \\(g\\) ). \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] where: \\(y(t)\\) is the vertical position of the projectile at time \\(t\\) , \\(g\\) is the acceleration due to gravity (approximately 9.81 m/s\u00b2). 1.2 Solving the Basic Differential Equation To find the time of flight, we focus on the vertical motion. The projectile hits the ground when \\(y(t) = 0\\) . Therefore, we set the vertical displacement equation equal to zero: \\[ v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 = 0 \\] Factorizing the equation: \\[ t \\left( v_0 \\cdot \\sin(\\theta) - \\frac{1}{2} g t \\right) = 0 \\] The solutions to this equation are: \\(t = 0\\) (at the moment of launch), \\(t = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g}\\) (the time at which the projectile hits the ground). Thus, the total time of flight \\(T\\) is: \\[ T = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] 1.3 Horizontal Range of the Projectile Now that we have the time of flight, we can use the horizontal motion equation to find the range of the projectile. The horizontal distance traveled is given by: \\[ R = x(T) = v_0 \\cdot \\cos(\\theta) \\cdot T \\] Substitute \\(T\\) from the earlier equation: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] Simplify the expression: \\[ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Thus, the range of the projectile as a function of the launch angle is: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] 1.4 Family of Solutions The general form of the range equation shows that the range depends on several parameters: Initial velocity \\(v_0\\) : The range increases with the square of the initial velocity. Launch angle \\(\\theta\\) : The range is maximized when \\(\\theta = 45^\\circ\\) , as \\(\\sin(2\\theta)\\) reaches its maximum value of 1 at this angle. Gravitational acceleration \\(g\\) : The range decreases with an increase in gravitational acceleration. Thus, the relationship between the angle and the range can be explored by varying these parameters. Key Points The projectile follows a parabolic trajectory. The launch angle \\(\\theta\\) has a significant impact on the horizontal range. For a given initial velocity, the optimal launch angle for maximum range is \\(\\theta = 45^\\circ\\) . Analysis of the Range 1. Investigating the Horizontal Range as a Function of the Angle of Projection 1.1 Range Equation Recap The horizontal range \\(R\\) of a projectile is given by the equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Where: \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle, \\(g\\) is the gravitational acceleration. 1.2 Range as a Function of Angle To investigate how the range depends on the angle of projection, we need to analyze the behavior of the function \\(R(\\theta)\\) for various values of \\(\\theta\\) . The range increases with the sine of \\(2\\theta\\) . This means that the range is maximized when \\(2\\theta = 90^\\circ\\) , which occurs at \\(\\theta = 45^\\circ\\) . At \\(\\theta = 0^\\circ\\) and \\(\\theta = 90^\\circ\\) , the range is zero because \\(\\sin(0^\\circ) = \\sin(180^\\circ) = 0\\) . The general behavior of the range as a function of angle is symmetric, meaning that the range for an angle \\(\\theta\\) is the same as for the angle \\(90^\\circ - \\theta\\) . 1.3 Graphical Representation We can plot \\(R(\\theta)\\) for a given initial velocity \\(v_0\\) and gravitational acceleration \\(g\\) to visualize how the range changes with the launch angle. 2. Analyzing the Influence of Initial Velocity and Gravitational Acceleration 2.1 Effect of Initial Velocity \\(v_0\\) From the range equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] The range increases with the square of the initial velocity \\(v_0\\) . This means that for a higher initial velocity, the projectile will travel further for the same angle. The influence of \\(v_0\\) is more significant than the angle, meaning that for the same angle, doubling the initial velocity will quadruple the range. 2.2 Effect of Gravitational Acceleration \\(g\\) Again, from the range equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] The range decreases as the gravitational acceleration \\(g\\) increases. This means that in stronger gravitational fields (e.g., on planets with higher gravity), the range will be shorter for the same initial velocity and launch angle. The effect of \\(g\\) is inversely proportional, meaning that for a given initial velocity, increasing the gravitational acceleration reduces the range. 3. Summary of Effects on Range 3.1 Dependence on Launch Angle Range increases as the launch angle increases from \\(0^\\circ\\) to \\(45^\\circ\\) . The maximum range occurs at \\(\\theta = 45^\\circ\\) . The relationship is symmetric around \\(45^\\circ\\) . 3.2 Dependence on Initial Velocity The range increases quadratically with the initial velocity \\(v_0\\) . Doubling the initial velocity results in a fourfold increase in range. 3.3 Dependence on Gravitational Acceleration The range decreases as the gravitational acceleration \\(g\\) increases. The effect is inversely proportional to \\(g\\) . 4. Python Code for Visualizing the Range import numpy as np import matplotlib.pyplot as plt # Constants v0 = 50 g = 9.81 angles_deg = [15, 45, 75] angles_rad = np.radians(angles_deg) # Plot setup plt.figure(figsize=(10, 6)) colors = ['b', 'g', 'r'] # Plot trajectory for each angle for angle_rad, angle_deg, color in zip(angles_rad, angles_deg, colors): t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 1000) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 plt.plot(x, y, color=color, label=f'Angle = {angle_deg}\u00b0') # Plot customization plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion Trajectories') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.axvline(0, color='black', linewidth=0.5) # Save the plot plt.savefig('projectile_motion.png') Practical Applications of Projectile Motion 1. Reflection on Real-World Situations While the basic projectile motion model provides valuable insights into how an object moves through the air, real-world situations often introduce additional complexities that the idealized model does not account for. Below, we explore some real-world scenarios and the adjustments needed for a more accurate description. 1.1 Uneven Terrain Effect of Uneven Terrain : In the ideal model, the projectile is launched from and lands on flat ground. However, in real-world scenarios, the launch or landing height might vary due to uneven terrain. If the launch and landing points are at different heights, the range equation must be modified to account for the difference in elevation. The new range equation with an initial height \\(h_0\\) becomes: \\[R(\\theta) = \\frac{v_0 \\cos(\\theta)}{g} \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2gh_0} \\right)\\] Where: \\(h_0\\) is the initial height from which the projectile is launched. Effect of Sloped Terrain : When the terrain is sloped, the trajectory and landing location change based on the angle of the slope. The equation for the range becomes more complex and involves solving for the intersection of the projectile's path with the slope of the ground. 1.2 Air Resistance Impact of Air Resistance : Air resistance (drag) significantly alters the trajectory of a projectile. The ideal model assumes no air resistance, but in real life, air resistance slows down the projectile as it travels. The general form of the motion with drag can be described by the following second-order differential equations: \\( \\(\\frac{d^2x}{dt^2}=-\\frac{C_d\\rho A}{2m}v\\frac{dx}{dt}\\) \\) \\( \\(\\frac{d^2y}{dt^2}=-g-\\frac{C_d\\rho A}{2m}v\\frac{dy}{dt}\\) \\) Where: - \\(C_d\\) is the drag coefficient, - \\(\\rho\\) is the air density, - \\(A\\) is the cross-sectional area of the projectile, - \\(m\\) is the mass of the projectile, - \\(v\\) is the velocity of the projectile. Numerical Methods : Solving these differential equations requires numerical methods such as Euler's method, Runge-Kutta, or other integration techniques. These methods can provide an accurate simulation of the trajectory that accounts for the effects of drag. 1.3 Wind and Environmental Factors Wind Effects : Wind can alter the trajectory of a projectile, either increasing or decreasing its range depending on the wind direction. The wind\u2019s influence on the trajectory can be modeled by adding a velocity term to the equations that represent the wind speed and direction. If the wind velocity is represented by \\(v_w\\) , the horizontal velocity of the projectile becomes: \\( \\(v_x' = v_x + v_w\\) \\) Where: - \\(v_x\\) is the horizontal velocity of the projectile, - \\(v_w\\) is the wind velocity. Temperature and Air Density : The air density \\(\\rho\\) depends on environmental factors such as temperature and pressure. In warmer conditions, the air density decreases, which reduces air resistance and can increase the range of the projectile. 1.4 Real-World Examples Sports : In sports like basketball or soccer, air resistance and launch height are crucial. A basketball shot will differ depending on the angle and initial velocity, but also on the height of the player and the presence of wind. Military and Engineering Applications : In military applications, such as missile trajectories, engineers must account for air resistance, wind, and terrain elevation. High-precision models that include drag and varying gravitational fields are used for accurate targeting. Space Exploration : For objects launched into space, air resistance is negligible at high altitudes, but gravitational variation (due to Earth's curvature) and velocity are still factors that affect trajectory calculations. Implementation of Projectile Motion Simulation 1. Developing a Computational Tool To simulate projectile motion and visualize the range as a function of the angle of projection, we need to use a computational approach that considers the basic equations of motion. The key to building this simulation involves solving the projectile's motion under the influence of gravity and accounting for various parameters such as initial velocity , launch angle , and gravitational acceleration . 1.1 Governing Equations The equations of motion for projectile motion without air resistance are: Horizontal motion: \\( \\(x(t) = v_0 \\cos(\\theta) t\\) \\) Vertical motion: \\( \\(y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\) \\) Where: \\(v_0\\) is the initial velocity of the projectile, \\(\\theta\\) is the launch angle, \\(g\\) is the gravitational acceleration, \\(x(t)\\) and \\(y(t)\\) are the horizontal and vertical displacements, respectively. The range \\(R\\) of the projectile (the distance it travels before hitting the ground) can be obtained when the projectile reaches \\(y=0\\) . This condition gives the time of flight as: \\[t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\] Substituting this into the equation for horizontal motion, we get the range \\(R\\) : \\[R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\] 1.2 Algorithm Design Input Parameters : Initial velocity \\(v_0\\) Launch angle \\(\\theta\\) Gravitational acceleration \\(g\\) Steps : Define the initial conditions (velocity, angle). Use the equations of motion to calculate the horizontal and vertical displacements at each time step. Compute the time of flight and the range \\(R\\) . Visualize the range \\(R\\) for different launch angles by plotting it as a function of the angle of projection. 2. Visualizing the Range as a Function of the Launch Angle To explore how the range changes with different angles of projection, we will create a plot of the range \\(R\\) for a range of angles, keeping the initial velocity and gravitational acceleration constant. Range Equation : \\( \\(R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) \\) This equation will be used to calculate the range for various values of \\(\\theta\\) (from 0\u00b0 to 90\u00b0). 2.1 Python Code Implementation Below is the Python code that simulates the projectile motion and visualizes the range as a function of the launch angle for a given initial velocity ```python import numpy as np import matplotlib.pyplot as plt # Constants v_0 = 20 # Initial velocity in m/s g = 9.81 # Gravitational acceleration in m/s^2 # Function to calculate the range for different launch angles def calculate_range(v_0, g, theta): # Convert angle to radians theta_rad = np.radians(theta) # Range equation R = (v_0**2 * np.sin(2*theta_rad)) / g return R # Launch angles from 0 to 90 degrees angles = np.linspace(0, 90, 100) # Calculate the range for each angle ranges = [calculate_range(v_0, g, angle) for angle in angles] # Plotting the range as a function of the launch angle plt.plot(angles, ranges) plt.title('Projectile Range vs Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#date-march-30-2025","text":"","title":"Date: March 30, 2025"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-governing-equations-of-motion","text":"To analyze projectile motion, we start by applying the fundamental laws of motion under constant acceleration, particularly the law of gravity. The two-dimensional motion of a projectile is governed by the following equations:","title":"1.1 Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"The acceleration in the horizontal direction is zero (assuming no air resistance), so the horizontal velocity remains constant. \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] where: \\(x(t)\\) is the horizontal position of the projectile at time \\(t\\) , \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle.","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"The vertical motion is influenced by gravity. The velocity in the vertical direction is affected by gravitational acceleration ( \\(g\\) ). \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] where: \\(y(t)\\) is the vertical position of the projectile at time \\(t\\) , \\(g\\) is the acceleration due to gravity (approximately 9.81 m/s\u00b2).","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-solving-the-basic-differential-equation","text":"To find the time of flight, we focus on the vertical motion. The projectile hits the ground when \\(y(t) = 0\\) . Therefore, we set the vertical displacement equation equal to zero: \\[ v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 = 0 \\] Factorizing the equation: \\[ t \\left( v_0 \\cdot \\sin(\\theta) - \\frac{1}{2} g t \\right) = 0 \\] The solutions to this equation are: \\(t = 0\\) (at the moment of launch), \\(t = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g}\\) (the time at which the projectile hits the ground). Thus, the total time of flight \\(T\\) is: \\[ T = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\]","title":"1.2 Solving the Basic Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-horizontal-range-of-the-projectile","text":"Now that we have the time of flight, we can use the horizontal motion equation to find the range of the projectile. The horizontal distance traveled is given by: \\[ R = x(T) = v_0 \\cdot \\cos(\\theta) \\cdot T \\] Substitute \\(T\\) from the earlier equation: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] Simplify the expression: \\[ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Thus, the range of the projectile as a function of the launch angle is: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\]","title":"1.3 Horizontal Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-family-of-solutions","text":"The general form of the range equation shows that the range depends on several parameters: Initial velocity \\(v_0\\) : The range increases with the square of the initial velocity. Launch angle \\(\\theta\\) : The range is maximized when \\(\\theta = 45^\\circ\\) , as \\(\\sin(2\\theta)\\) reaches its maximum value of 1 at this angle. Gravitational acceleration \\(g\\) : The range decreases with an increase in gravitational acceleration. Thus, the relationship between the angle and the range can be explored by varying these parameters.","title":"1.4 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-points","text":"The projectile follows a parabolic trajectory. The launch angle \\(\\theta\\) has a significant impact on the horizontal range. For a given initial velocity, the optimal launch angle for maximum range is \\(\\theta = 45^\\circ\\) .","title":"Key Points"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"","title":"Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-investigating-the-horizontal-range-as-a-function-of-the-angle-of-projection","text":"","title":"1. Investigating the Horizontal Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-range-equation-recap","text":"The horizontal range \\(R\\) of a projectile is given by the equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Where: \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle, \\(g\\) is the gravitational acceleration.","title":"1.1 Range Equation Recap"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-range-as-a-function-of-angle","text":"To investigate how the range depends on the angle of projection, we need to analyze the behavior of the function \\(R(\\theta)\\) for various values of \\(\\theta\\) . The range increases with the sine of \\(2\\theta\\) . This means that the range is maximized when \\(2\\theta = 90^\\circ\\) , which occurs at \\(\\theta = 45^\\circ\\) . At \\(\\theta = 0^\\circ\\) and \\(\\theta = 90^\\circ\\) , the range is zero because \\(\\sin(0^\\circ) = \\sin(180^\\circ) = 0\\) . The general behavior of the range as a function of angle is symmetric, meaning that the range for an angle \\(\\theta\\) is the same as for the angle \\(90^\\circ - \\theta\\) .","title":"1.2 Range as a Function of Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-graphical-representation","text":"We can plot \\(R(\\theta)\\) for a given initial velocity \\(v_0\\) and gravitational acceleration \\(g\\) to visualize how the range changes with the launch angle.","title":"1.3 Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analyzing-the-influence-of-initial-velocity-and-gravitational-acceleration","text":"","title":"2. Analyzing the Influence of Initial Velocity and Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-effect-of-initial-velocity-v_0","text":"From the range equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] The range increases with the square of the initial velocity \\(v_0\\) . This means that for a higher initial velocity, the projectile will travel further for the same angle. The influence of \\(v_0\\) is more significant than the angle, meaning that for the same angle, doubling the initial velocity will quadruple the range.","title":"2.1 Effect of Initial Velocity \\(v_0\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-effect-of-gravitational-acceleration-g","text":"Again, from the range equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] The range decreases as the gravitational acceleration \\(g\\) increases. This means that in stronger gravitational fields (e.g., on planets with higher gravity), the range will be shorter for the same initial velocity and launch angle. The effect of \\(g\\) is inversely proportional, meaning that for a given initial velocity, increasing the gravitational acceleration reduces the range.","title":"2.2 Effect of Gravitational Acceleration \\(g\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-summary-of-effects-on-range","text":"","title":"3. Summary of Effects on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-dependence-on-launch-angle","text":"Range increases as the launch angle increases from \\(0^\\circ\\) to \\(45^\\circ\\) . The maximum range occurs at \\(\\theta = 45^\\circ\\) . The relationship is symmetric around \\(45^\\circ\\) .","title":"3.1 Dependence on Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-dependence-on-initial-velocity","text":"The range increases quadratically with the initial velocity \\(v_0\\) . Doubling the initial velocity results in a fourfold increase in range.","title":"3.2 Dependence on Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-dependence-on-gravitational-acceleration","text":"The range decreases as the gravitational acceleration \\(g\\) increases. The effect is inversely proportional to \\(g\\) .","title":"3.3 Dependence on Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-code-for-visualizing-the-range","text":"import numpy as np import matplotlib.pyplot as plt # Constants v0 = 50 g = 9.81 angles_deg = [15, 45, 75] angles_rad = np.radians(angles_deg) # Plot setup plt.figure(figsize=(10, 6)) colors = ['b', 'g', 'r'] # Plot trajectory for each angle for angle_rad, angle_deg, color in zip(angles_rad, angles_deg, colors): t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 1000) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 plt.plot(x, y, color=color, label=f'Angle = {angle_deg}\u00b0') # Plot customization plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion Trajectories') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.axvline(0, color='black', linewidth=0.5) # Save the plot plt.savefig('projectile_motion.png')","title":"4. Python Code for Visualizing the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications-of-projectile-motion","text":"","title":"Practical Applications of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-reflection-on-real-world-situations","text":"While the basic projectile motion model provides valuable insights into how an object moves through the air, real-world situations often introduce additional complexities that the idealized model does not account for. Below, we explore some real-world scenarios and the adjustments needed for a more accurate description.","title":"1. Reflection on Real-World Situations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-uneven-terrain","text":"Effect of Uneven Terrain : In the ideal model, the projectile is launched from and lands on flat ground. However, in real-world scenarios, the launch or landing height might vary due to uneven terrain. If the launch and landing points are at different heights, the range equation must be modified to account for the difference in elevation. The new range equation with an initial height \\(h_0\\) becomes: \\[R(\\theta) = \\frac{v_0 \\cos(\\theta)}{g} \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2gh_0} \\right)\\] Where: \\(h_0\\) is the initial height from which the projectile is launched. Effect of Sloped Terrain : When the terrain is sloped, the trajectory and landing location change based on the angle of the slope. The equation for the range becomes more complex and involves solving for the intersection of the projectile's path with the slope of the ground.","title":"1.1 Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-air-resistance","text":"Impact of Air Resistance : Air resistance (drag) significantly alters the trajectory of a projectile. The ideal model assumes no air resistance, but in real life, air resistance slows down the projectile as it travels. The general form of the motion with drag can be described by the following second-order differential equations: \\( \\(\\frac{d^2x}{dt^2}=-\\frac{C_d\\rho A}{2m}v\\frac{dx}{dt}\\) \\) \\( \\(\\frac{d^2y}{dt^2}=-g-\\frac{C_d\\rho A}{2m}v\\frac{dy}{dt}\\) \\) Where: - \\(C_d\\) is the drag coefficient, - \\(\\rho\\) is the air density, - \\(A\\) is the cross-sectional area of the projectile, - \\(m\\) is the mass of the projectile, - \\(v\\) is the velocity of the projectile. Numerical Methods : Solving these differential equations requires numerical methods such as Euler's method, Runge-Kutta, or other integration techniques. These methods can provide an accurate simulation of the trajectory that accounts for the effects of drag.","title":"1.2 Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-wind-and-environmental-factors","text":"Wind Effects : Wind can alter the trajectory of a projectile, either increasing or decreasing its range depending on the wind direction. The wind\u2019s influence on the trajectory can be modeled by adding a velocity term to the equations that represent the wind speed and direction. If the wind velocity is represented by \\(v_w\\) , the horizontal velocity of the projectile becomes: \\( \\(v_x' = v_x + v_w\\) \\) Where: - \\(v_x\\) is the horizontal velocity of the projectile, - \\(v_w\\) is the wind velocity. Temperature and Air Density : The air density \\(\\rho\\) depends on environmental factors such as temperature and pressure. In warmer conditions, the air density decreases, which reduces air resistance and can increase the range of the projectile.","title":"1.3 Wind and Environmental Factors"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-real-world-examples","text":"Sports : In sports like basketball or soccer, air resistance and launch height are crucial. A basketball shot will differ depending on the angle and initial velocity, but also on the height of the player and the presence of wind. Military and Engineering Applications : In military applications, such as missile trajectories, engineers must account for air resistance, wind, and terrain elevation. High-precision models that include drag and varying gravitational fields are used for accurate targeting. Space Exploration : For objects launched into space, air resistance is negligible at high altitudes, but gravitational variation (due to Earth's curvature) and velocity are still factors that affect trajectory calculations.","title":"1.4 Real-World Examples"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation-of-projectile-motion-simulation","text":"","title":"Implementation of Projectile Motion Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-developing-a-computational-tool","text":"To simulate projectile motion and visualize the range as a function of the angle of projection, we need to use a computational approach that considers the basic equations of motion. The key to building this simulation involves solving the projectile's motion under the influence of gravity and accounting for various parameters such as initial velocity , launch angle , and gravitational acceleration .","title":"1. Developing a Computational Tool"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-governing-equations","text":"The equations of motion for projectile motion without air resistance are: Horizontal motion: \\( \\(x(t) = v_0 \\cos(\\theta) t\\) \\) Vertical motion: \\( \\(y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\) \\) Where: \\(v_0\\) is the initial velocity of the projectile, \\(\\theta\\) is the launch angle, \\(g\\) is the gravitational acceleration, \\(x(t)\\) and \\(y(t)\\) are the horizontal and vertical displacements, respectively. The range \\(R\\) of the projectile (the distance it travels before hitting the ground) can be obtained when the projectile reaches \\(y=0\\) . This condition gives the time of flight as: \\[t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\] Substituting this into the equation for horizontal motion, we get the range \\(R\\) : \\[R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\]","title":"1.1 Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-algorithm-design","text":"Input Parameters : Initial velocity \\(v_0\\) Launch angle \\(\\theta\\) Gravitational acceleration \\(g\\) Steps : Define the initial conditions (velocity, angle). Use the equations of motion to calculate the horizontal and vertical displacements at each time step. Compute the time of flight and the range \\(R\\) . Visualize the range \\(R\\) for different launch angles by plotting it as a function of the angle of projection.","title":"1.2 Algorithm Design"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-visualizing-the-range-as-a-function-of-the-launch-angle","text":"To explore how the range changes with different angles of projection, we will create a plot of the range \\(R\\) for a range of angles, keeping the initial velocity and gravitational acceleration constant. Range Equation : \\( \\(R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) \\) This equation will be used to calculate the range for various values of \\(\\theta\\) (from 0\u00b0 to 90\u00b0).","title":"2. Visualizing the Range as a Function of the Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-python-code-implementation","text":"","title":"2.1 Python Code Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#below-is-the-python-code-that-simulates-the-projectile-motion-and-visualizes-the-range-as-a-function-of-the-launch-angle-for-a-given-initial-velocity","text":"```python import numpy as np import matplotlib.pyplot as plt # Constants v_0 = 20 # Initial velocity in m/s g = 9.81 # Gravitational acceleration in m/s^2 # Function to calculate the range for different launch angles def calculate_range(v_0, g, theta): # Convert angle to radians theta_rad = np.radians(theta) # Range equation R = (v_0**2 * np.sin(2*theta_rad)) / g return R # Launch angles from 0 to 90 degrees angles = np.linspace(0, 90, 100) # Calculate the range for each angle ranges = [calculate_range(v_0, g, angle) for angle in angles] # Plotting the range as a function of the launch angle plt.plot(angles, ranges) plt.title('Projectile Range vs Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.show()","title":"Below is the Python code that simulates the projectile motion and visualizes the range as a function of the launch angle for a given initial velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum: Dynamics and Analysis 1. Theoretical Framework The forced damped pendulum is modeled by a second-order nonlinear ordinary differential equation (ODE) describing angular displacement under damping and periodic external forcing. 1.1 Governing Equation The equation of motion is: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=A\\cos(\\omega t)\\] Variables : \\(\\theta(t)\\) : Angular displacement (radians) \\(b\\) : Damping coefficient (s \\(^{-1}\\) ) \\(g\\) : Gravitational acceleration (m/s \\(^2\\) ) \\(L\\) : Pendulum length (m) \\(A\\) : Driving amplitude (s \\(^{-2}\\) ) \\(\\omega\\) : Driving frequency (rad/s) 1.2 Small-Angle Approximation For small angles ( \\(\\theta\\ll 1\\) ), the nonlinear term simplifies: \\[\\sin\\theta\\approx\\theta\\] This yields a linear ODE: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\theta=A\\cos(\\omega t)\\] 1.3 Solution to Linearized Equation The solution combines homogeneous and particular components: Homogeneous Solution : The characteristic equation is: \\( \\(r^2+br+(g/L)=0\\) \\) Roots are: \\( \\(r_{1,2}=(-b\\pm\\sqrt{b^2-4(g/L)})/2\\) \\) The homogeneous solution is: \\[\\theta_h(t)=C_1e^{r_1t}+C_2e^{r_2t}\\] For underdamped systems ( \\(b^2<4(g/L)\\) ): \\[\\theta_h(t)=e^{-(b/2)t}(C_1\\cos(\\omega_dt)+C_2\\sin(\\omega_dt))\\] Where damped frequency is: \\[\\omega_d=\\sqrt{(g/L)-(b^2/4)}\\] Particular Solution : Assume a steady-state form: \\[\\theta_p(t)=B\\cos(\\omega t-\\delta)\\] The amplitude \\(B\\) is: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\] The phase shift \\(\\delta\\) is: \\[\\tan\\delta=(b\\omega)/((g/L)-\\omega^2)\\] 1.3.1 Pendulum Motion Visualization The time evolution of \\(\\theta(t)\\) illustrates the combined effects of damping and external forcing, as described by the nonlinear ODE: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=A\\cos(\\omega t)\\] The following Python code solves this ODE numerically using parameters \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , \\(A=0.5\\) s \\(^{-2}\\) , and \\(\\omega=0.8\\sqrt{g/L}\\) , plotting \\(\\theta(t)\\) over time. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint Additional Visualization: Simple Pendulum Motion (Undamped, No Forcing) To further illustrate the basic pendulum dynamics without damping ( \\(b=0\\) ) and without external forcing ( \\(A=0\\) ), we plot \\(\\theta(t)\\) over time for small initial displacement. This captures the pure periodic motion expected from an ideal pendulum. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Simple pendulum parameters b = 0.0 # damping A = 0.0 # forcing omega_f = 0.0 g = 9.81 L = 1.0 def simple_pendulum(t, y): theta, omega = y dydt = [omega, -(g/L)*np.sin(theta)] return dydt # Time points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [0.2, 0.0] # initial conditions: [angle, angular velocity] # Solve sol = solve_ivp(simple_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'r') axs[0].set_title('Simple Pendulum - Time Series') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'r') axs[1].set_title('Simple Pendulum - Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show() 1.4 Resonance Resonance occurs when \\(\\omega\\) approaches the natural frequency: \\[\\omega_0=\\sqrt{g/L}\\] Undamped Case ( \\(b=0\\) ): \\[B\\to\\infty\\text{ as }\\omega\\to\\omega_0\\] Damped Case : Maximum amplitude occurs at: \\[\\omega_{\\text{res}}=\\sqrt{\\omega_0^2-(b^2/2)}\\] With maximum amplitude: \\[B_{\\text{max}}=A/(b\\sqrt{\\omega_0^2-(b^2/4)})\\] 1.4.1 Resonance Curve Visualization The resonance curve plots the steady-state amplitude \\(B\\) against driving frequency \\(\\omega\\) , as given by: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\] The following Python code computes \\(B\\) for \\(\\omega\\) from 0.1 to 5 rad/s, with \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , and \\(A=0.5\\) s \\(^{-2}\\) . Additional Visualization: Resonance Behavior in the Undamped Pendulum Below we show the amplitude response \\(B\\) versus driving frequency \\(\\omega\\) for an undamped pendulum ( \\(b=0\\) ). As expected, the amplitude diverges sharply near the natural frequency \\(\\omega_0=\\sqrt{g/L}\\) , showing the classical resonance peak. import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 b = 0.2 A = 0.5 # Frequency range omega = np.linspace(0.1, 5, 500) # Amplitude B B = A / np.sqrt(((g/L) - omega**2)**2 + (b*omega)**2) # Plot plt.figure(figsize=(8, 5)) plt.plot(omega, B, label=r'Amplitude $B$') plt.xlabel(r'Driving Frequency $\\omega$ (rad/s)') plt.ylabel(r'Amplitude $B$ (rad)') plt.title('Resonance Curve of Forced Damped Pendulum') plt.grid(True) plt.legend() plt.show() 1.5 Energy Dynamics Total mechanical energy is: \\[E(t)=(1/2)mL^2(d\\theta/dt)^2+mgL(1-\\cos\\theta)\\] At resonance: Undamped: Energy grows without bound. Damped: Energy balances input and dissipation, yielding: \\[E_{\\text{steady}}\\approx(1/2)mL^2B^2\\omega^2\\] Energy Evolution Over Time The plot below shows the total mechanical energy \\(E(t)\\) of the pendulum over time for both damped and undamped cases. In the undamped case, energy remains constant (or grows under forcing); in the damped case, energy stabilizes after transient behavior. # Forced pendulum parameters b = 0.0 # no damping A = 1.2 # forcing amplitude omega_f = 2.0/3.0 # forcing frequency def forced_pendulum(t, y): theta, omega = y dydt = [omega, -(g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'c') axs[0].set_title('Forced Pendulum - Time Series') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'c') axs[1].set_title('Forced Pendulum - Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show() 1.6 Summary The nonlinear ODE governs pendulum motion. Small-angle approximation linearizes the system. Solutions include damped and forced components. Resonance amplifies oscillations, moderated by damping. 2. Parametric Effects This section analyzes how parameters affect dynamics, focusing on damping, driving amplitude, and frequency. 2.1 Damping Coefficient ( \\(b\\) ) Damping influences oscillation decay: Low \\(b\\) : Sustained oscillations. Solution approximates undamped case: \\[\\theta(t)\\approx B\\cos(\\omega t-\\delta)\\] High \\(b\\) : Rapid decay to equilibrium. Overdamped solution ( \\(b^2>4(g/L)\\) ): \\[\\theta(t)=C_1e^{r_1t}+C_2e^{r_2t}\\] 2.2 Driving Amplitude ( \\(A\\) ) The amplitude \\(A\\) scales the external force: Small \\(A\\) : Oscillations decay unless near resonance. Amplitude scales linearly: \\[B\\propto A\\] Large \\(A\\) : Increases steady-state amplitude: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\] 2.3 Driving Frequency ( \\(\\omega\\) ) Frequency determines forcing efficiency: Near \\(\\omega_0\\) : Large oscillations due to resonance. Amplitude peaks at \\(\\omega_{\\text{res}}\\) . Far from \\(\\omega_0\\) : Reduced amplitude: \\[B\\approx A/|(g/L)-\\omega^2|\\] 2.4 Chaos and Nonlinearity For large \\(A\\) or specific \\(\\omega\\) , the nonlinear \\(\\sin\\theta\\) term induces chaos: Periodic Motion : Stable at low \\(A\\) , described by: \\[\\theta(t)\\approx B\\cos(\\omega t-\\delta)\\] Chaotic Motion : Sensitive to initial conditions. Characterized by positive Lyapunov exponent: \\[\\lambda>0\\] 2.5 Visualization Tools Phase Portrait : Plots \\(\\theta\\) vs. \\(d\\theta/dt\\) . Periodic motion: Closed loops. Chaotic motion: Irregular patterns. The following Python code generates a phase portrait for the pendulum with \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , \\(A=0.5\\) s \\(^{-2}\\) , and \\(\\omega=0.8\\sqrt{g/L}\\) , showing a closed loop indicative of periodic motion. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 L = 1.0 b = 0.2 A = 0.5 omega = 0.8 * np.sqrt(g/L) # ODE system def pendulum(state, t, b, g, L, A, omega): theta, omega = state dtheta_dt = omega domega_dt = -b*omega - (g/L)*np.sin(theta) + A*np.cos(omega*t) return [dtheta_dt, domega_dt] # Time array t = np.linspace(0, 20, 1000) # Initial conditions state0 = [0.1, 0.0] # Solve ODE solution = odeint(pendulum, state0, t, args=(b, g, L, A, omega)) theta = solution[:, 0] dtheta_dt = solution[:, 1] # Plot plt.figure(figsize=(8, 5)) plt.plot(theta, dtheta_dt, label=r\"$\\text{Phase Trajectory}$\") plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\frac{d\\theta}{dt}$ (rad/s)\") plt.title(r\"$\\text{Phase Portrait of Forced Damped Pendulum}$\") plt.grid(True) plt.legend() plt.show() # Poincar\u00e9 Section Description: # Samples at $t=2\\pi n/\\omega$. # Periodic: Discrete points. # Chaotic: Scattered points. 2.6 Summary Damping controls oscillation decay. Amplitude scales forcing strength. Frequency drives resonance or chaos. Nonlinear effects lead to complex dynamics. 3. Applications The model applies to systems with oscillatory dynamics. 3.1 Energy Harvesting Vibrational harvesters convert motion to energy: Model : Driving force: Ambient vibrations. Power output: \\[P=(1/2)mL^2(d\\theta/dt)^2\\] Optimization : Maximize at resonance: \\[\\omega=\\omega_0\\] 3.2 Structural Engineering Bridges oscillate under external loads: Equation : Similar to pendulum: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=F_{\\text{ext}}(t)\\] Design : Increase \\(b\\) to avoid resonance. 3.3 Electrical Circuits RLC circuits mirror pendulum dynamics: Equation : Charge dynamics: \\[Ld^2q/dt^2+R\\,dq/dt+(1/C)q=V_{\\text{ext}}(t)\\] Resonance : Maximizes current at: \\[\\omega=1/\\sqrt{LC}\\] 3.4 Summary Energy harvesting optimizes power at resonance. Structures require damping to prevent failure. Circuits control resonance for stability. Additional Visualization: Phase Portraits Under Different Conditions The following phase diagram shows the behavior of the pendulum for different scenarios: - (i) No damping and no external force (pure closed loops), - (ii) With damping (spiraling into equilibrium), - (iii) With external driving (limit cycles or chaotic behavior). # Forced damped pendulum parameters (resonance-like) b = 0.05 # light damping A = 1.2 # forcing amplitude omega_f = 2.0/3.0 # forcing frequency def forced_damped_pendulum(t, y): theta, omega = y dydt = [omega, -(b)*omega - (g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'm') axs[0].set_title('Forced Damped Pendulum - Time Series (Resonance-like)') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'm') axs[1].set_title('Forced Damped Pendulum - Phase Portrait (Resonance-like)') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show() Poincar\u00e9 Section: Visualization of Periodicity and Chaos Below we plot the Poincar\u00e9 section, sampling the pendulum's phase space at regular intervals ( \\(t=2\\pi n/\\omega\\) ): - For periodic motion: discrete isolated points appear. - For chaotic motion: scattered clouds of points emerge. # Forced damped pendulum parameters (chaotic) b = 0.2 # stronger damping A = 1.5 # larger forcing omega_f = 2.0/3.0 # forcing frequency def chaotic_forced_damped_pendulum(t, y): theta, omega = y dydt = [omega, -(b)*omega - (g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(chaotic_forced_damped_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'g') axs[0].set_title('Forced Damped Pendulum - Time Series (Chaotic)') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'g') axs[1].set_title('Forced Damped Pendulum - Phase Portrait (Chaotic)') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-dynamics-and-analysis","text":"","title":"Forced Damped Pendulum: Dynamics and Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-framework","text":"The forced damped pendulum is modeled by a second-order nonlinear ordinary differential equation (ODE) describing angular displacement under damping and periodic external forcing.","title":"1. Theoretical Framework"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-governing-equation","text":"The equation of motion is: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=A\\cos(\\omega t)\\] Variables : \\(\\theta(t)\\) : Angular displacement (radians) \\(b\\) : Damping coefficient (s \\(^{-1}\\) ) \\(g\\) : Gravitational acceleration (m/s \\(^2\\) ) \\(L\\) : Pendulum length (m) \\(A\\) : Driving amplitude (s \\(^{-2}\\) ) \\(\\omega\\) : Driving frequency (rad/s)","title":"1.1 Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-small-angle-approximation","text":"For small angles ( \\(\\theta\\ll 1\\) ), the nonlinear term simplifies: \\[\\sin\\theta\\approx\\theta\\] This yields a linear ODE: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\theta=A\\cos(\\omega t)\\]","title":"1.2 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-solution-to-linearized-equation","text":"The solution combines homogeneous and particular components: Homogeneous Solution : The characteristic equation is: \\( \\(r^2+br+(g/L)=0\\) \\) Roots are: \\( \\(r_{1,2}=(-b\\pm\\sqrt{b^2-4(g/L)})/2\\) \\) The homogeneous solution is: \\[\\theta_h(t)=C_1e^{r_1t}+C_2e^{r_2t}\\] For underdamped systems ( \\(b^2<4(g/L)\\) ): \\[\\theta_h(t)=e^{-(b/2)t}(C_1\\cos(\\omega_dt)+C_2\\sin(\\omega_dt))\\] Where damped frequency is: \\[\\omega_d=\\sqrt{(g/L)-(b^2/4)}\\] Particular Solution : Assume a steady-state form: \\[\\theta_p(t)=B\\cos(\\omega t-\\delta)\\] The amplitude \\(B\\) is: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\] The phase shift \\(\\delta\\) is: \\[\\tan\\delta=(b\\omega)/((g/L)-\\omega^2)\\]","title":"1.3 Solution to Linearized Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#131-pendulum-motion-visualization","text":"The time evolution of \\(\\theta(t)\\) illustrates the combined effects of damping and external forcing, as described by the nonlinear ODE: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=A\\cos(\\omega t)\\] The following Python code solves this ODE numerically using parameters \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , \\(A=0.5\\) s \\(^{-2}\\) , and \\(\\omega=0.8\\sqrt{g/L}\\) , plotting \\(\\theta(t)\\) over time. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint","title":"1.3.1 Pendulum Motion Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#additional-visualization-simple-pendulum-motion-undamped-no-forcing","text":"To further illustrate the basic pendulum dynamics without damping ( \\(b=0\\) ) and without external forcing ( \\(A=0\\) ), we plot \\(\\theta(t)\\) over time for small initial displacement. This captures the pure periodic motion expected from an ideal pendulum.","title":"Additional Visualization: Simple Pendulum Motion (Undamped, No Forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Simple pendulum parameters b = 0.0 # damping A = 0.0 # forcing omega_f = 0.0 g = 9.81 L = 1.0 def simple_pendulum(t, y): theta, omega = y dydt = [omega, -(g/L)*np.sin(theta)] return dydt # Time points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [0.2, 0.0] # initial conditions: [angle, angular velocity] # Solve sol = solve_ivp(simple_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'r') axs[0].set_title('Simple Pendulum - Time Series') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'r') axs[1].set_title('Simple Pendulum - Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#14-resonance","text":"Resonance occurs when \\(\\omega\\) approaches the natural frequency: \\[\\omega_0=\\sqrt{g/L}\\] Undamped Case ( \\(b=0\\) ): \\[B\\to\\infty\\text{ as }\\omega\\to\\omega_0\\] Damped Case : Maximum amplitude occurs at: \\[\\omega_{\\text{res}}=\\sqrt{\\omega_0^2-(b^2/2)}\\] With maximum amplitude: \\[B_{\\text{max}}=A/(b\\sqrt{\\omega_0^2-(b^2/4)})\\]","title":"1.4 Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#141-resonance-curve-visualization","text":"The resonance curve plots the steady-state amplitude \\(B\\) against driving frequency \\(\\omega\\) , as given by: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\] The following Python code computes \\(B\\) for \\(\\omega\\) from 0.1 to 5 rad/s, with \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , and \\(A=0.5\\) s \\(^{-2}\\) .","title":"1.4.1 Resonance Curve Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#additional-visualization-resonance-behavior-in-the-undamped-pendulum","text":"Below we show the amplitude response \\(B\\) versus driving frequency \\(\\omega\\) for an undamped pendulum ( \\(b=0\\) ). As expected, the amplitude diverges sharply near the natural frequency \\(\\omega_0=\\sqrt{g/L}\\) , showing the classical resonance peak.","title":"Additional Visualization: Resonance Behavior in the Undamped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_2","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 b = 0.2 A = 0.5 # Frequency range omega = np.linspace(0.1, 5, 500) # Amplitude B B = A / np.sqrt(((g/L) - omega**2)**2 + (b*omega)**2) # Plot plt.figure(figsize=(8, 5)) plt.plot(omega, B, label=r'Amplitude $B$') plt.xlabel(r'Driving Frequency $\\omega$ (rad/s)') plt.ylabel(r'Amplitude $B$ (rad)') plt.title('Resonance Curve of Forced Damped Pendulum') plt.grid(True) plt.legend() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#15-energy-dynamics","text":"Total mechanical energy is: \\[E(t)=(1/2)mL^2(d\\theta/dt)^2+mgL(1-\\cos\\theta)\\] At resonance: Undamped: Energy grows without bound. Damped: Energy balances input and dissipation, yielding: \\[E_{\\text{steady}}\\approx(1/2)mL^2B^2\\omega^2\\]","title":"1.5 Energy Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-evolution-over-time","text":"The plot below shows the total mechanical energy \\(E(t)\\) of the pendulum over time for both damped and undamped cases. In the undamped case, energy remains constant (or grows under forcing); in the damped case, energy stabilizes after transient behavior. # Forced pendulum parameters b = 0.0 # no damping A = 1.2 # forcing amplitude omega_f = 2.0/3.0 # forcing frequency def forced_pendulum(t, y): theta, omega = y dydt = [omega, -(g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'c') axs[0].set_title('Forced Pendulum - Time Series') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'c') axs[1].set_title('Forced Pendulum - Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":"Energy Evolution Over Time"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#16-summary","text":"The nonlinear ODE governs pendulum motion. Small-angle approximation linearizes the system. Solutions include damped and forced components. Resonance amplifies oscillations, moderated by damping.","title":"1.6 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-parametric-effects","text":"This section analyzes how parameters affect dynamics, focusing on damping, driving amplitude, and frequency.","title":"2. Parametric Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-damping-coefficient-b","text":"Damping influences oscillation decay: Low \\(b\\) : Sustained oscillations. Solution approximates undamped case: \\[\\theta(t)\\approx B\\cos(\\omega t-\\delta)\\] High \\(b\\) : Rapid decay to equilibrium. Overdamped solution ( \\(b^2>4(g/L)\\) ): \\[\\theta(t)=C_1e^{r_1t}+C_2e^{r_2t}\\]","title":"2.1 Damping Coefficient (\\(b\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-driving-amplitude-a","text":"The amplitude \\(A\\) scales the external force: Small \\(A\\) : Oscillations decay unless near resonance. Amplitude scales linearly: \\[B\\propto A\\] Large \\(A\\) : Increases steady-state amplitude: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\]","title":"2.2 Driving Amplitude (\\(A\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#23-driving-frequency-omega","text":"Frequency determines forcing efficiency: Near \\(\\omega_0\\) : Large oscillations due to resonance. Amplitude peaks at \\(\\omega_{\\text{res}}\\) . Far from \\(\\omega_0\\) : Reduced amplitude: \\[B\\approx A/|(g/L)-\\omega^2|\\]","title":"2.3 Driving Frequency (\\(\\omega\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#24-chaos-and-nonlinearity","text":"For large \\(A\\) or specific \\(\\omega\\) , the nonlinear \\(\\sin\\theta\\) term induces chaos: Periodic Motion : Stable at low \\(A\\) , described by: \\[\\theta(t)\\approx B\\cos(\\omega t-\\delta)\\] Chaotic Motion : Sensitive to initial conditions. Characterized by positive Lyapunov exponent: \\[\\lambda>0\\]","title":"2.4 Chaos and Nonlinearity"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#25-visualization-tools","text":"Phase Portrait : Plots \\(\\theta\\) vs. \\(d\\theta/dt\\) . Periodic motion: Closed loops. Chaotic motion: Irregular patterns. The following Python code generates a phase portrait for the pendulum with \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , \\(A=0.5\\) s \\(^{-2}\\) , and \\(\\omega=0.8\\sqrt{g/L}\\) , showing a closed loop indicative of periodic motion. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 L = 1.0 b = 0.2 A = 0.5 omega = 0.8 * np.sqrt(g/L) # ODE system def pendulum(state, t, b, g, L, A, omega): theta, omega = state dtheta_dt = omega domega_dt = -b*omega - (g/L)*np.sin(theta) + A*np.cos(omega*t) return [dtheta_dt, domega_dt] # Time array t = np.linspace(0, 20, 1000) # Initial conditions state0 = [0.1, 0.0] # Solve ODE solution = odeint(pendulum, state0, t, args=(b, g, L, A, omega)) theta = solution[:, 0] dtheta_dt = solution[:, 1] # Plot plt.figure(figsize=(8, 5)) plt.plot(theta, dtheta_dt, label=r\"$\\text{Phase Trajectory}$\") plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\frac{d\\theta}{dt}$ (rad/s)\") plt.title(r\"$\\text{Phase Portrait of Forced Damped Pendulum}$\") plt.grid(True) plt.legend() plt.show() # Poincar\u00e9 Section Description: # Samples at $t=2\\pi n/\\omega$. # Periodic: Discrete points. # Chaotic: Scattered points.","title":"2.5 Visualization Tools"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#26-summary","text":"Damping controls oscillation decay. Amplitude scales forcing strength. Frequency drives resonance or chaos. Nonlinear effects lead to complex dynamics.","title":"2.6 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-applications","text":"The model applies to systems with oscillatory dynamics.","title":"3. Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#31-energy-harvesting","text":"Vibrational harvesters convert motion to energy: Model : Driving force: Ambient vibrations. Power output: \\[P=(1/2)mL^2(d\\theta/dt)^2\\] Optimization : Maximize at resonance: \\[\\omega=\\omega_0\\]","title":"3.1 Energy Harvesting"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#32-structural-engineering","text":"Bridges oscillate under external loads: Equation : Similar to pendulum: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=F_{\\text{ext}}(t)\\] Design : Increase \\(b\\) to avoid resonance.","title":"3.2 Structural Engineering"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#33-electrical-circuits","text":"RLC circuits mirror pendulum dynamics: Equation : Charge dynamics: \\[Ld^2q/dt^2+R\\,dq/dt+(1/C)q=V_{\\text{ext}}(t)\\] Resonance : Maximizes current at: \\[\\omega=1/\\sqrt{LC}\\]","title":"3.3 Electrical Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#34-summary","text":"Energy harvesting optimizes power at resonance. Structures require damping to prevent failure. Circuits control resonance for stability.","title":"3.4 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#additional-visualization-phase-portraits-under-different-conditions","text":"The following phase diagram shows the behavior of the pendulum for different scenarios: - (i) No damping and no external force (pure closed loops), - (ii) With damping (spiraling into equilibrium), - (iii) With external driving (limit cycles or chaotic behavior). # Forced damped pendulum parameters (resonance-like) b = 0.05 # light damping A = 1.2 # forcing amplitude omega_f = 2.0/3.0 # forcing frequency def forced_damped_pendulum(t, y): theta, omega = y dydt = [omega, -(b)*omega - (g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'm') axs[0].set_title('Forced Damped Pendulum - Time Series (Resonance-like)') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'm') axs[1].set_title('Forced Damped Pendulum - Phase Portrait (Resonance-like)') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":"Additional Visualization: Phase Portraits Under Different Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section-visualization-of-periodicity-and-chaos","text":"Below we plot the Poincar\u00e9 section, sampling the pendulum's phase space at regular intervals ( \\(t=2\\pi n/\\omega\\) ): - For periodic motion: discrete isolated points appear. - For chaotic motion: scattered clouds of points emerge. # Forced damped pendulum parameters (chaotic) b = 0.2 # stronger damping A = 1.5 # larger forcing omega_f = 2.0/3.0 # forcing frequency def chaotic_forced_damped_pendulum(t, y): theta, omega = y dydt = [omega, -(b)*omega - (g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(chaotic_forced_damped_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'g') axs[0].set_title('Forced Damped Pendulum - Time Series (Chaotic)') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'g') axs[1].set_title('Forced Damped Pendulum - Phase Portrait (Chaotic)') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":"Poincar\u00e9 Section: Visualization of Periodicity and Chaos"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \ud83c\udf0c Deriving Kepler\u2019s Third Law for Circular Orbits Kepler\u2019s Third Law states that the square of the orbital period of a planet is directly proportional to the cube of the semi-major axis of its orbit. For circular orbits, the semi-major axis is equal to the orbital radius. Let's derive this from fundamental physical principles. \u2696\ufe0f Step 1: Newton\u2019s Law of Universal Gravitation Newton's Law of Gravitation gives the attractive force between two masses: \\[F_{\\text{gravity}} = G\\frac{Mm}{r^2}\\] \\(G\\) = Gravitational constant \\(M\\) = Mass of the central body (e.g., Earth or Sun) \\(m\\) = Mass of the orbiting object (e.g., satellite or planet) \\(r\\) = Radius of the circular orbit \ud83d\udd04 Step 2: Centripetal Force for Circular Motion Any object in a circular orbit must experience a centripetal force to stay on its path: \\[F_{\\text{centripetal}} = \\frac{mv^2}{r}\\] \u2696\ufe0f Step 3: Equating Gravitational and Centripetal Forces Since gravity provides the centripetal force: \\[\\frac{mv^2}{r} = G\\frac{Mm}{r^2}\\] Cancel out \\(m\\) (mass of the orbiting body): \\[\\frac{v^2}{r} = G\\frac{M}{r^2}\\] Multiply both sides by \\(r\\) : \\[v^2 = \\frac{GM}{r}\\] \u23f1\ufe0f Step 4: Express Orbital Velocity in Terms of Period Orbital velocity \\(v\\) is the distance traveled in one orbit divided by the orbital period \\(T\\) : \\[v = \\frac{2\\pi r}{T}\\] Substitute into the velocity equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\] Simplify: \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r}\\] Multiply both sides by \\(r\\) : \\[\\frac{4\\pi^2 r^3}{T^2} = GM\\] \ud83d\udcd0 Final Form: Kepler\u2019s Third Law Rearranging for \\(T^2\\) : \\[T^2 = \\frac{4\\pi^2}{GM} \\cdot r^3\\] \u2705 This is Kepler's Third Law for circular orbits! \\(T^2 \\propto r^3\\) The constant of proportionality depends on the central mass \\(M\\) \ud83c\udf20 Physical Meaning of Kepler\u2019s Third Law We previously derived Kepler's Third Law for circular orbits: \\[T^2=\\frac{4\\pi^2}{GM}\\cdot r^3\\] This relationship elegantly connects time (orbital period) with space (orbital radius) through the gravitational constant and the mass of the central body . \ud83d\udd0d Interpretation of Each Term \\(T\\) : Orbital period \u2014 how long it takes to complete one full orbit \\(r\\) : Orbital radius \u2014 the distance between the orbiting body and the central mass \\(G\\) : Universal gravitational constant \u2014 governs strength of gravitational interaction \\(M\\) : Mass of the central body (e.g., Earth, Sun) \ud83e\udde0 Physical Insights 1. Gravitational Control of Motion The period \\(T\\) depends only on the mass of the central body \\(M\\) and the radius \\(r\\) of the orbit. The orbiting body\u2019s own mass \\(m\\) does not appear in the final formula \u2014 this reflects the equivalence principle. 2. Increased Radius = Slower Orbit From the formula: \\( \\(T\\propto r^{3/2}\\) \\) Larger orbits take significantly longer to complete. This explains why outer planets (like Neptune) move much slower than inner ones (like Mercury). 3. Scaling and Proportionality A doubling of \\(r\\) increases \\(T\\) by a factor of: \\( \\(T\\propto(2r)^{3/2}=2^{3/2}\\approx2.83\\) \\) Time grows faster than radius \u2014 orbital systems are not linear. \ud83d\udd2d Astronomical Applications \u2705 1. Estimating Masses of Celestial Bodies Rearranging: \\( \\(M=\\frac{4\\pi^2r^3}{GT^2}\\) \\) If we know the radius and period of a satellite or moon, we can compute the mass of the planet/star it orbits. \u2705 2. Predicting Orbital Times Given a known central mass and radius, we can compute how long any object will take to orbit. \u2705 3. Comparing Planetary Systems By comparing \\(T^2/r^3\\) across different systems, we can verify gravitational consistency: \\( \\(\\frac{T^2}{r^3}=\\text{constant for a given }M\\) \\) \ud83c\udf0d Real-World Applications of Kepler's Third Law Kepler\u2019s Third Law allows us to predict orbital periods and distances for a variety of celestial bodies. By analyzing real-world examples such as the Moon\u2019s orbit around Earth , planetary orbits (like Earth\u2019s orbit around the Sun), and Jupiter\u2019s moons , we can see the practical utility of this fundamental law. 1. \ud83c\udf19 Moon\u2019s Orbit Around Earth 1.1. Known Values Orbital period \\(T_{\\text{moon}}\\) of the Moon: \\(T_{\\text{moon}} = 27.3\\) days (converted to seconds: \\(T_{\\text{moon}} = 27.3 \\times 86400\\) seconds) Average distance between the Earth and the Moon: \\(r = 3.84 \\times 10^8\\) meters Mass of Earth: \\(M_{\\text{Earth}} = 5.972 \\times 10^{24}\\) kg Using Kepler\u2019s Third Law for the Moon\u2019s orbit around Earth: \\[T^2 = \\frac{4\\pi^2 r^3}{GM_{\\text{Earth}}}\\] 1.2. Orbital Period Calculation We can calculate the orbital period of the Moon by rearranging the above equation to solve for \\(T\\) : \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM_{\\text{Earth}}}}\\] Let\u2019s calculate this in Python: import numpy as np # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 (gravitational constant) M_earth = 5.972e24 # kg (mass of Earth) r_moon = 3.84e8 # meters (average distance from Earth to Moon) # Orbital period calculation (in seconds) T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (G * M_earth)) T_moon_days = T_moon / (60 * 60 * 24) # Convert from seconds to days print(f\"Orbital period of the Moon: {T_moon_days:.2f} days\") 2. \ud83d\udda5\ufe0f Python Script to Simulate Circular Orbits We can use the derived formulas to simulate the motion of a satellite in a circular orbit. Below is a Python script that simulates and visualizes the orbit of a satellite around a central body. 2.1. Python Code Implementation import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 (gravitational constant) M = 5.972e24 # kg (mass of Earth) r = 7.5e6 # meters (orbital radius) T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital period v = np.sqrt(G * M / r) # Orbital velocity # Time settings for animation omega = 2 * np.pi / T # Angular velocity (rad/s) t = np.linspace(0, T, 360) # Time array for one orbit x = r * np.cos(omega * t) # X positions over time y = r * np.sin(omega * t) # Y positions over time # Set up the figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-r*1.5, r*1.5) ax.set_ylim(-r*1.5, r*1.5) ax.set_title(\"Satellite Orbit Animation\", color='darkgreen') ax.set_xlabel(\"X (m)\", color='darkgreen') ax.set_ylabel(\"Y (m)\", color='darkgreen') # Draw the central body and initialize the satellite central_body = plt.Circle((0, 0), r*0.05, color='red', label='Earth') satellite, = plt.plot([], [], 'o', color='cyan', label='Satellite') orbit, = plt.plot(x, y, linestyle='--', color='gray', alpha=0.5) # Add the central body to the plot ax.add_artist(central_body) ax.legend(loc=\"upper right\") ax.grid(True, linestyle='--', alpha=0.7) # Animation update function def update(frame): satellite.set_data([x[frame]], [y[frame]]) return satellite, # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) plt.show() # Output the orbital period and velocity print(f\"Orbital Period: {T/86400:.2f} days\") print(f\"Orbital Velocity: {v/1000:.2f} km/s\") \ud83e\ude90 Verifying Kepler\u2019s Third Law Numerically In this section, we will verify Kepler's Third Law numerically by calculating the orbital period of a planet or moon and comparing it to the values predicted by the law. Kepler's Third Law states that the square of the orbital period ( \\(T^2\\) ) is directly proportional to the cube of the orbital radius ( \\(r^3\\) ). Mathematically, this relationship can be written as: \\[T^2 \\propto r^3\\] In terms of gravitational forces, the orbital period \\(T\\) for a circular orbit is given by: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\] Where: - \\(T\\) is the orbital period . - \\(r\\) is the orbital radius . - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ). - \\(M\\) is the mass of the central body (e.g., the Sun for planetary orbits). We will now use this formula to verify Kepler\u2019s Third Law numerically for a set of planets and moons. \ud83e\uddee Calculating Masses of Earth and Sun import numpy as np # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) AU_to_m = 1.496e11 # Meters per AU year_to_s = 3.156e7 # Seconds per year day_to_s = 86400 # Seconds per day # Data for Earth's orbit around the Sun (to calculate Sun's mass) r_sun = 1.000 * AU_to_m # Earth's semi-major axis (m) T_sun = 1.000 * year_to_s # Earth's orbital period (s) # Data for Moon's orbit around Earth (to calculate Earth's mass) r_moon = 3.84e8 # Average distance from Earth to Moon (m) T_moon = 27.3 * day_to_s # Moon's orbital period (s) # Calculate Sun's mass r_sun_cubed = r_sun ** 3 T_sun_squared = T_sun ** 2 M_sun = (4 * np.pi**2 * r_sun_cubed) / (G * T_sun_squared) print(f\"Mass of the Sun: {M_sun:.3e} kg\") # Calculate Earth's mass r_moon_cubed = r_moon ** 3 T_moon_squared = T_moon ** 2 M_earth = (4 * np.pi**2 * r_moon_cubed) / (G * T_moon_squared) print(f\"Mass of the Earth: {M_earth:.3e} kg\") 1. \ud83e\uddee Kepler\u2019s Third Law Formula From Kepler's Third Law, the orbital period for a circular orbit is: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\] 1.1. Gravitational Constant and Units \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) . Mass of the central body ( \\(M\\) ) is given in kg . Orbital radius ( \\(r\\) ) is given in meters . The orbital period \\(T\\) will be calculated in seconds . 2. \ud83d\udd2d Numerical Verification Let\u2019s now calculate the orbital period for different celestial bodies, such as Earth and Jupiter , using Kepler\u2019s Third Law. 2.1. Python Code Implementation The following code will calculate the orbital period for different celestial bodies by using their orbital radii and masses . We will also visualize the relationship between the square of the orbital period ( \\(T^2\\) ) and the cube of the orbital radius ( \\(r^3\\) ). import numpy as np import matplotlib.pyplot as plt # Conversion factors AU_to_m = 1.496e11 # Meters per AU year_to_s = 3.156e7 # Seconds per year # Data for Mercury, Venus, Earth, Mars (semi-major axis in AU, period in years) planets = { \"Mercury\": {\"r\": 0.387 * AU_to_m, \"T\": 0.241 * year_to_s}, \"Venus\": {\"r\": 0.723 * AU_to_m, \"T\": 0.615 * year_to_s}, \"Earth\": {\"r\": 1.000 * AU_to_m, \"T\": 1.000 * year_to_s}, \"Mars\": {\"r\": 1.524 * AU_to_m, \"T\": 1.881 * year_to_s}, } # Compute r^3 and T^2 r_cubed = [data[\"r\"]**3 for data in planets.values()] T_squared = [data[\"T\"]**2 for data in planets.values()] planet_names = list(planets.keys()) # Plot T^2 vs r^3 (should be a straight line) plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='blue', label=\"Planets\") for i, name in enumerate(planet_names): plt.annotate(name, (r_cubed[i], T_squared[i]), fontsize=9, ha='right') plt.plot(r_cubed, np.poly1d(np.polyfit(r_cubed, T_squared, 1))(r_cubed), color='red', linestyle='--', label=\"Best Fit Line\") plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$ for Planets\") plt.xlabel(\"$r^3$ (m\u00b3)\") plt.ylabel(\"$T^2$ (s\u00b2)\") plt.legend() plt.grid(True) plt.savefig('kepler_third_law_plot.png') # Save the plot as per guidelines","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deriving-keplers-third-law-for-circular-orbits","text":"Kepler\u2019s Third Law states that the square of the orbital period of a planet is directly proportional to the cube of the semi-major axis of its orbit. For circular orbits, the semi-major axis is equal to the orbital radius. Let's derive this from fundamental physical principles.","title":"\ud83c\udf0c Deriving Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-newtons-law-of-universal-gravitation","text":"Newton's Law of Gravitation gives the attractive force between two masses: \\[F_{\\text{gravity}} = G\\frac{Mm}{r^2}\\] \\(G\\) = Gravitational constant \\(M\\) = Mass of the central body (e.g., Earth or Sun) \\(m\\) = Mass of the orbiting object (e.g., satellite or planet) \\(r\\) = Radius of the circular orbit","title":"\u2696\ufe0f Step 1: Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-centripetal-force-for-circular-motion","text":"Any object in a circular orbit must experience a centripetal force to stay on its path: \\[F_{\\text{centripetal}} = \\frac{mv^2}{r}\\]","title":"\ud83d\udd04 Step 2: Centripetal Force for Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-3-equating-gravitational-and-centripetal-forces","text":"Since gravity provides the centripetal force: \\[\\frac{mv^2}{r} = G\\frac{Mm}{r^2}\\] Cancel out \\(m\\) (mass of the orbiting body): \\[\\frac{v^2}{r} = G\\frac{M}{r^2}\\] Multiply both sides by \\(r\\) : \\[v^2 = \\frac{GM}{r}\\]","title":"\u2696\ufe0f Step 3: Equating Gravitational and Centripetal Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-4-express-orbital-velocity-in-terms-of-period","text":"Orbital velocity \\(v\\) is the distance traveled in one orbit divided by the orbital period \\(T\\) : \\[v = \\frac{2\\pi r}{T}\\] Substitute into the velocity equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\] Simplify: \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r}\\] Multiply both sides by \\(r\\) : \\[\\frac{4\\pi^2 r^3}{T^2} = GM\\]","title":"\u23f1\ufe0f Step 4: Express Orbital Velocity in Terms of Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-form-keplers-third-law","text":"Rearranging for \\(T^2\\) : \\[T^2 = \\frac{4\\pi^2}{GM} \\cdot r^3\\] \u2705 This is Kepler's Third Law for circular orbits! \\(T^2 \\propto r^3\\) The constant of proportionality depends on the central mass \\(M\\)","title":"\ud83d\udcd0 Final Form: Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#physical-meaning-of-keplers-third-law","text":"We previously derived Kepler's Third Law for circular orbits: \\[T^2=\\frac{4\\pi^2}{GM}\\cdot r^3\\] This relationship elegantly connects time (orbital period) with space (orbital radius) through the gravitational constant and the mass of the central body .","title":"\ud83c\udf20 Physical Meaning of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#interpretation-of-each-term","text":"\\(T\\) : Orbital period \u2014 how long it takes to complete one full orbit \\(r\\) : Orbital radius \u2014 the distance between the orbiting body and the central mass \\(G\\) : Universal gravitational constant \u2014 governs strength of gravitational interaction \\(M\\) : Mass of the central body (e.g., Earth, Sun)","title":"\ud83d\udd0d Interpretation of Each Term"},{"location":"1%20Physics/2%20Gravity/Problem_1/#physical-insights","text":"","title":"\ud83e\udde0 Physical Insights"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-gravitational-control-of-motion","text":"The period \\(T\\) depends only on the mass of the central body \\(M\\) and the radius \\(r\\) of the orbit. The orbiting body\u2019s own mass \\(m\\) does not appear in the final formula \u2014 this reflects the equivalence principle.","title":"1. Gravitational Control of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-increased-radius-slower-orbit","text":"From the formula: \\( \\(T\\propto r^{3/2}\\) \\) Larger orbits take significantly longer to complete. This explains why outer planets (like Neptune) move much slower than inner ones (like Mercury).","title":"2. Increased Radius = Slower Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-scaling-and-proportionality","text":"A doubling of \\(r\\) increases \\(T\\) by a factor of: \\( \\(T\\propto(2r)^{3/2}=2^{3/2}\\approx2.83\\) \\) Time grows faster than radius \u2014 orbital systems are not linear.","title":"3. Scaling and Proportionality"},{"location":"1%20Physics/2%20Gravity/Problem_1/#astronomical-applications","text":"","title":"\ud83d\udd2d Astronomical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-estimating-masses-of-celestial-bodies","text":"Rearranging: \\( \\(M=\\frac{4\\pi^2r^3}{GT^2}\\) \\) If we know the radius and period of a satellite or moon, we can compute the mass of the planet/star it orbits.","title":"\u2705 1. Estimating Masses of Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-predicting-orbital-times","text":"Given a known central mass and radius, we can compute how long any object will take to orbit.","title":"\u2705 2. Predicting Orbital Times"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-comparing-planetary-systems","text":"By comparing \\(T^2/r^3\\) across different systems, we can verify gravitational consistency: \\( \\(\\frac{T^2}{r^3}=\\text{constant for a given }M\\) \\)","title":"\u2705 3. Comparing Planetary Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-applications-of-keplers-third-law","text":"Kepler\u2019s Third Law allows us to predict orbital periods and distances for a variety of celestial bodies. By analyzing real-world examples such as the Moon\u2019s orbit around Earth , planetary orbits (like Earth\u2019s orbit around the Sun), and Jupiter\u2019s moons , we can see the practical utility of this fundamental law.","title":"\ud83c\udf0d Real-World Applications of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-moons-orbit-around-earth","text":"","title":"1. \ud83c\udf19 Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-known-values","text":"Orbital period \\(T_{\\text{moon}}\\) of the Moon: \\(T_{\\text{moon}} = 27.3\\) days (converted to seconds: \\(T_{\\text{moon}} = 27.3 \\times 86400\\) seconds) Average distance between the Earth and the Moon: \\(r = 3.84 \\times 10^8\\) meters Mass of Earth: \\(M_{\\text{Earth}} = 5.972 \\times 10^{24}\\) kg Using Kepler\u2019s Third Law for the Moon\u2019s orbit around Earth: \\[T^2 = \\frac{4\\pi^2 r^3}{GM_{\\text{Earth}}}\\]","title":"1.1. Known Values"},{"location":"1%20Physics/2%20Gravity/Problem_1/#12-orbital-period-calculation","text":"We can calculate the orbital period of the Moon by rearranging the above equation to solve for \\(T\\) : \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM_{\\text{Earth}}}}\\] Let\u2019s calculate this in Python: import numpy as np # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 (gravitational constant) M_earth = 5.972e24 # kg (mass of Earth) r_moon = 3.84e8 # meters (average distance from Earth to Moon) # Orbital period calculation (in seconds) T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (G * M_earth)) T_moon_days = T_moon / (60 * 60 * 24) # Convert from seconds to days print(f\"Orbital period of the Moon: {T_moon_days:.2f} days\")","title":"1.2. Orbital Period Calculation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-python-script-to-simulate-circular-orbits","text":"We can use the derived formulas to simulate the motion of a satellite in a circular orbit. Below is a Python script that simulates and visualizes the orbit of a satellite around a central body.","title":"2. \ud83d\udda5\ufe0f Python Script to Simulate Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#21-python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 (gravitational constant) M = 5.972e24 # kg (mass of Earth) r = 7.5e6 # meters (orbital radius) T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital period v = np.sqrt(G * M / r) # Orbital velocity # Time settings for animation omega = 2 * np.pi / T # Angular velocity (rad/s) t = np.linspace(0, T, 360) # Time array for one orbit x = r * np.cos(omega * t) # X positions over time y = r * np.sin(omega * t) # Y positions over time # Set up the figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-r*1.5, r*1.5) ax.set_ylim(-r*1.5, r*1.5) ax.set_title(\"Satellite Orbit Animation\", color='darkgreen') ax.set_xlabel(\"X (m)\", color='darkgreen') ax.set_ylabel(\"Y (m)\", color='darkgreen') # Draw the central body and initialize the satellite central_body = plt.Circle((0, 0), r*0.05, color='red', label='Earth') satellite, = plt.plot([], [], 'o', color='cyan', label='Satellite') orbit, = plt.plot(x, y, linestyle='--', color='gray', alpha=0.5) # Add the central body to the plot ax.add_artist(central_body) ax.legend(loc=\"upper right\") ax.grid(True, linestyle='--', alpha=0.7) # Animation update function def update(frame): satellite.set_data([x[frame]], [y[frame]]) return satellite, # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) plt.show() # Output the orbital period and velocity print(f\"Orbital Period: {T/86400:.2f} days\") print(f\"Orbital Velocity: {v/1000:.2f} km/s\")","title":"2.1. Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#verifying-keplers-third-law-numerically","text":"In this section, we will verify Kepler's Third Law numerically by calculating the orbital period of a planet or moon and comparing it to the values predicted by the law. Kepler's Third Law states that the square of the orbital period ( \\(T^2\\) ) is directly proportional to the cube of the orbital radius ( \\(r^3\\) ). Mathematically, this relationship can be written as: \\[T^2 \\propto r^3\\] In terms of gravitational forces, the orbital period \\(T\\) for a circular orbit is given by: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\] Where: - \\(T\\) is the orbital period . - \\(r\\) is the orbital radius . - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ). - \\(M\\) is the mass of the central body (e.g., the Sun for planetary orbits). We will now use this formula to verify Kepler\u2019s Third Law numerically for a set of planets and moons.","title":"\ud83e\ude90 Verifying Kepler\u2019s Third Law Numerically"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-masses-of-earth-and-sun","text":"import numpy as np # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) AU_to_m = 1.496e11 # Meters per AU year_to_s = 3.156e7 # Seconds per year day_to_s = 86400 # Seconds per day # Data for Earth's orbit around the Sun (to calculate Sun's mass) r_sun = 1.000 * AU_to_m # Earth's semi-major axis (m) T_sun = 1.000 * year_to_s # Earth's orbital period (s) # Data for Moon's orbit around Earth (to calculate Earth's mass) r_moon = 3.84e8 # Average distance from Earth to Moon (m) T_moon = 27.3 * day_to_s # Moon's orbital period (s) # Calculate Sun's mass r_sun_cubed = r_sun ** 3 T_sun_squared = T_sun ** 2 M_sun = (4 * np.pi**2 * r_sun_cubed) / (G * T_sun_squared) print(f\"Mass of the Sun: {M_sun:.3e} kg\") # Calculate Earth's mass r_moon_cubed = r_moon ** 3 T_moon_squared = T_moon ** 2 M_earth = (4 * np.pi**2 * r_moon_cubed) / (G * T_moon_squared) print(f\"Mass of the Earth: {M_earth:.3e} kg\")","title":"\ud83e\uddee Calculating Masses of Earth and Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-keplers-third-law-formula","text":"From Kepler's Third Law, the orbital period for a circular orbit is: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\]","title":"1. \ud83e\uddee Kepler\u2019s Third Law Formula"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-gravitational-constant-and-units","text":"\\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) . Mass of the central body ( \\(M\\) ) is given in kg . Orbital radius ( \\(r\\) ) is given in meters . The orbital period \\(T\\) will be calculated in seconds .","title":"1.1. Gravitational Constant and Units"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-numerical-verification","text":"Let\u2019s now calculate the orbital period for different celestial bodies, such as Earth and Jupiter , using Kepler\u2019s Third Law.","title":"2. \ud83d\udd2d Numerical Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#21-python-code-implementation_1","text":"The following code will calculate the orbital period for different celestial bodies by using their orbital radii and masses . We will also visualize the relationship between the square of the orbital period ( \\(T^2\\) ) and the cube of the orbital radius ( \\(r^3\\) ). import numpy as np import matplotlib.pyplot as plt # Conversion factors AU_to_m = 1.496e11 # Meters per AU year_to_s = 3.156e7 # Seconds per year # Data for Mercury, Venus, Earth, Mars (semi-major axis in AU, period in years) planets = { \"Mercury\": {\"r\": 0.387 * AU_to_m, \"T\": 0.241 * year_to_s}, \"Venus\": {\"r\": 0.723 * AU_to_m, \"T\": 0.615 * year_to_s}, \"Earth\": {\"r\": 1.000 * AU_to_m, \"T\": 1.000 * year_to_s}, \"Mars\": {\"r\": 1.524 * AU_to_m, \"T\": 1.881 * year_to_s}, } # Compute r^3 and T^2 r_cubed = [data[\"r\"]**3 for data in planets.values()] T_squared = [data[\"T\"]**2 for data in planets.values()] planet_names = list(planets.keys()) # Plot T^2 vs r^3 (should be a straight line) plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='blue', label=\"Planets\") for i, name in enumerate(planet_names): plt.annotate(name, (r_cubed[i], T_squared[i]), fontsize=9, ha='right') plt.plot(r_cubed, np.poly1d(np.polyfit(r_cubed, T_squared, 1))(r_cubed), color='red', linestyle='--', label=\"Best Fit Line\") plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$ for Planets\") plt.xlabel(\"$r^3$ (m\u00b3)\") plt.ylabel(\"$T^2$ (s\u00b2)\") plt.legend() plt.grid(True) plt.savefig('kepler_third_law_plot.png') # Save the plot as per guidelines","title":"2.1. Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Cosmic Velocities: Derivations, Calculations, and Comparisons 1. Definitions of Cosmic Velocities Cosmic velocities are critical thresholds in astrodynamics, defining minimum speeds for orbital and escape maneuvers: First Cosmic Velocity \\(v_1\\) : Definition : The speed required for an object to maintain a circular orbit near a celestial body's surface. Equation : \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second Cosmic Velocity \\(v_2\\) : Definition : The speed required to escape a celestial body's gravitational pull. Equation : \\(v_2 = \\sqrt{\\frac{2GM}{R}}\\) Third Cosmic Velocity \\(v_3\\) : Definition : The speed required to escape a star system from a planet's orbit. Equation : \\(v_3 = \\sqrt{v_2^2 + (v_{\\text{esc,Sun}} - v_{\\text{orbit}})^2}\\) 2. Derivations 2.1 First Cosmic Velocity ( \\(v_1\\) ) import numpy as np import matplotlib.pyplot as plt # Constants and calculations G = 6.67430e-11 M = 5.972e24 radii = np.linspace(1e6, 1.5e7, 500) v1 = np.sqrt(G * M / radii) v1_km_s = v1 / 1000 # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Main plot line with enhanced styling main_line, = plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='#0066cc', linewidth=3) # Enhanced text elements ax.set_xlabel('Planet Radius (km)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_ylabel('First Cosmic Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('First Cosmic Velocity vs Planet Radius', fontsize=16, fontweight='bold', pad=20, color='black') # High-visibility legend legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) legend.get_texts()[0].set_color('black') legend.get_texts()[0].set_fontweight('bold') # Grid and frame ax.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # Add direct label to curve for extra clarity ax.text(8000, 7.5, r'$v_1 = \\sqrt{\\frac{GM}{R}}$', fontsize=14, fontweight='bold', color='#0066cc') # Make ticks more visible ax.tick_params(axis='both', which='both', labelsize=12, color='black') plt.tight_layout() plt.show() Derivation : Gravitational force equals centripetal force: $$ \\frac{GMm}{R^2}=\\frac{mv_1^2}{R} \\implies v_1=\\sqrt{\\frac{GM}{R}} $$ 2.2 Second Cosmic Velocity ( \\(v_2\\) ) import numpy as np import matplotlib.pyplot as plt # Data v1 = np.linspace(0, 20, 500) v2 = np.sqrt(2) * v1 # Plot setup with high visibility text plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Plot lines with contrasting colors main_line, = plt.plot(v1, v2, color='#0066cc', linewidth=3, label=r'$v_2 = \\sqrt{2} \\times v_1$') ref_line, = plt.plot(v1, v1, linestyle='--', color='#cc3300', linewidth=2, label=r'$v_2 = v_1$ (reference line)') # Enhanced text elements ax.set_xlabel('First Cosmic Velocity $v_1$ (km/s)', fontsize=14, fontweight='bold', color='black') ax.set_ylabel('Second Cosmic Velocity $v_2$ (km/s)', fontsize=14, fontweight='bold', color='black') ax.set_title('Relationship between First and Second Cosmic Velocities', fontsize=16, fontweight='bold', pad=20, color='black') # High-visibility legend legend = ax.legend( handles=[main_line, ref_line], loc='upper left', frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1 ) legend.get_frame().set_linewidth(2) # Make all text elements black and bold for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') # Grid and ticks ax.grid(True, linestyle=':', color='gray', alpha=0.4) ax.tick_params(axis='both', which='major', labelsize=12, colors='black') # Add direct labels to lines for extra clarity ax.text(15, 28, r'$v_2 = \\sqrt{2}v_1$', fontsize=14, fontweight='bold', color='#0066cc') ax.text(15, 15, r'$v_2 = v_1$', fontsize=14, fontweight='bold', color='#cc3300') # Frame for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) plt.tight_layout() plt.show() Derivation : Energy conservation (kinetic + potential = 0 at infinity): \\[ \\frac{1}{2}mv_2^2 - \\frac{GMm}{R} = 0 \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\] 2.3 Third Cosmic Velocity ( \\(v_3\\) ) Derivation : Escape Sun's gravity at planet's orbital distance: $$ v_{\\text{esc,Sun}}=\\sqrt{\\frac{2GM_{\\text{Sun}}}{R_{\\text{orbit}}}} $$ Planet's orbital velocity around Sun: $$ v_{\\text{orbit}}=\\sqrt{\\frac{GM_{\\text{Sun}}}{R_{\\text{orbit}}}} $$ Total velocity from planet's surface: $$ v_3=\\sqrt{v_2^2+(v_{\\text{esc,Sun}}-v_{\\text{orbit}})^2} $$ 3. Cosmic Velocities for Earth Parameters : - \\(M_{\\text{Earth}} = 5.972 \\times 10^{24} \\text{ kg}\\) - \\(R_{\\text{Earth}} = 6.371 \\times 10^6 \\text{ m}\\) - \\(R_{\\text{Earth-Sun}} = 1.496 \\times 10^{11} \\text{ m}\\) Calculations : - \\(v_1 = \\sqrt{\\frac{GM_{\\text{Earth}}}{R_{\\text{Earth}}}} \\approx 7.91 \\text{ km/s}\\) - \\(v_2 = \\sqrt{2} \\cdot v_1 \\approx 11.19 \\text{ km/s}\\) - \\(v_3 = \\sqrt{v_2^2 + (\\sqrt{\\frac{2GM_{\\text{Sun}}}{R_{\\text{Earth-Sun}}}} - \\sqrt{\\frac{GM_{\\text{Sun}}}{R_{\\text{Earth-Sun}}}})^2} \\approx 16.64 \\text{ km/s}\\) 4. Comparison with Moon, Mars, and Jupiter import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced styling bar_width = 0.25 bar1 = plt.bar(x, v1, width=bar_width, label='First Cosmic Velocity (v1)', color='#0066cc', edgecolor='black', linewidth=1.5) bar2 = plt.bar([i + bar_width for i in x], v2, width=bar_width, label='Second Cosmic Velocity (v2)', color='#cc3300', edgecolor='black', linewidth=1.5) bar3 = plt.bar([i + 2*bar_width for i in x], [v if v else 0 for v in v3], width=bar_width, label='Third Cosmic Velocity (v3)', color='#009966', edgecolor='black', linewidth=1.5) # Special styling for Moon's v3 (None value) bar3[1].set_hatch('//') bar3[1].set_color('#ff9999') # Enhanced text elements ax.set_ylabel('Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('Comparison of Cosmic Velocities', fontsize=16, fontweight='bold', pad=20, color='black') ax.set_xticks([i + bar_width for i in x]) ax.set_xticklabels(bodies, fontsize=12, fontweight='bold', color='black') # High-visibility legend legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') # Add value labels on bars for bars, offset in zip([bar1, bar2, bar3], [0, bar_width, 2*bar_width]): for i, bar in enumerate(bars): height = bar.get_height() if height > 0: # Only label non-zero bars ax.text(bar.get_x() + bar.get_width()/2., height + 1, f'{height:.1f}', ha='center', va='bottom', fontsize=11, fontweight='bold') # Special annotation for Moon's v3 ax.text(1 + 2*bar_width, 1, 'N/A', ha='center', va='bottom', fontsize=11, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) plt.tight_layout() plt.show() Parameters : Body Mass (kg) Radius (m) Orbital Radius (m) Moon \\(7.342 \\times 10^{22}\\) \\(1.737 \\times 10^6\\) \\(1.496 \\times 10^{11}\\) (Earth's) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.899 \\times 10^{27}\\) \\(6.991 \\times 10^7\\) \\(7.785 \\times 10^{11}\\) Calculated Velocities (km/s) : Body \\(v_1\\) \\(v_2\\) \\(v_3\\) Earth 7.91 11.19 16.64 Moon 1.68 2.38 16.51 Mars 3.55 5.03 13.09 Jupiter 42.14 59.57 9.67 5. Visualizations 5.1 Cosmic Velocities Comparison import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_sun = 1.989e30 # Celestial body parameters: [mass (kg), radius (m), orbital radius (m)] bodies = { 'Earth': [5.972e24, 6.371e6, 1.496e11], 'Moon': [7.342e22, 1.737e6, 1.496e11], 'Mars': [6.417e23, 3.390e6, 2.279e11], 'Jupiter': [1.899e27, 6.991e7, 7.785e11] } # Calculate cosmic velocities velocities = {'v1': {}, 'v2': {}, 'v3': {}} for body, (M, R, R_orbit) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 v2 = np.sqrt(2 * G * M / R) / 1000 v_esc_sun = np.sqrt(2 * G * M_sun / R_orbit) / 1000 v_orbit = np.sqrt(G * M_sun / R_orbit) / 1000 v3 = np.sqrt(v2**2 + (v_esc_sun - v_orbit)**2) velocities['v1'][body] = v1 velocities['v2'][body] = v2 velocities['v3'][body] = v3 # Plot fig, ax = plt.subplots(figsize=(12, 7)) x = np.arange(len(bodies)) width = 0.25 bars1 = ax.bar(x - width, velocities['v1'].values(), width, label='$v_1$') bars2 = ax.bar(x, velocities['v2'].values(), width, label='$v_2$') bars3 = ax.bar(x + width, velocities['v3'].values(), width, label='$v_3$') # Annotations for bars in [bars1, bars2, bars3]: for bar in bars: height = bar.get_height() ax.annotate(f'{height:.2f}', xy=(bar.get_x() + bar.get_width() / 2, height), xytext=(0, 3), textcoords=\"offset points\", ha='center', va='bottom') ax.set_yscale('log') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (km/s, log scale)') ax.set_title('Cosmic Velocities Comparison') ax.set_xticks(x) ax.set_xticklabels(bodies.keys()) ax.legend() ax.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('cosmic_velocities_comparison.png') plt.show() import numpy as np import matplotlib.pyplot as plt # Constants and data G = 6.67430e-11 bodies = { \"Earth\": {\"R\": 6.371e6, \"M\": 5.97e24}, \"Moon\": {\"R\": 1.74e6, \"M\": 7.35e22}, \"Mars\": {\"R\": 3.39e6, \"M\": 6.42e23}, \"Jupiter\": {\"R\": 7.15e7, \"M\": 1.90e27} } # Calculate values radii = [] v2_values = [] labels = [] for body, data in bodies.items(): R = data[\"R\"] M = data[\"M\"] v2 = np.sqrt(2 * G * M / R) / 1000 radii.append(R / 1e6) v2_values.append(v2) labels.append(body) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced styling bars = plt.bar(labels, v2_values, color=['#0066cc', '#cc3300', '#009966', '#6633cc'], edgecolor='black', linewidth=1.5, width=0.6) # Enhanced text elements ax.set_title('Second Cosmic Velocity (Escape Velocity) vs Planet Radius', fontsize=16, fontweight='bold', pad=20, color='black') ax.set_xlabel('Celestial Body', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_ylabel('Escape Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) # Value labels on bars for bar in bars: height = bar.get_height() ax.text(bar.get_x() + bar.get_width()/2., height + 0.5, f'{height:.1f} km/s', ha='center', va='bottom', fontsize=12, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # X-axis ticks ax.set_xticklabels(labels, fontsize=12, fontweight='bold', color='black') plt.tight_layout() plt.show() import matplotlib.pyplot as plt # Data celestial_bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] escape_velocities = [16.7, None, 14.1, 18.5] # Third Cosmic Velocity (km/s) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced visibility bars = plt.bar(celestial_bodies, [vel if vel else 0 for vel in escape_velocities], color=['#0066cc', '#cc3300', '#009966', '#6633cc'], width=0.6, edgecolor='black', linewidth=1.5) # Special marking for Moon (None value) bars[1].set_hatch('//') bars[1].set_color('#ff9999') bars[1].set_edgecolor('black') # Enhanced text elements ax.set_ylabel('Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('Third Cosmic Velocity Comparison for Celestial Bodies', fontsize=16, fontweight='bold', pad=20, color='black') # X-axis labels ax.set_xticklabels(celestial_bodies, fontsize=12, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # High-visibility legend legend = ax.legend(['Third Cosmic Velocity (v3)'], frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) legend.get_texts()[0].set_color('black') legend.get_texts()[0].set_fontweight('bold') # Add value labels on top of bars for bar in bars: height = bar.get_height() if height > 0: # Only label non-zero bars ax.text(bar.get_x() + bar.get_width()/2., height + 0.5, f'{height:.1f}', ha='center', va='bottom', fontsize=12, fontweight='bold') # Special annotation for Moon ax.text(bars[1].get_x() + bars[1].get_width()/2., 1, 'N/A', ha='center', va='bottom', fontsize=12, fontweight='bold', color='black') plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-derivations-calculations-and-comparisons","text":"","title":"Cosmic Velocities: Derivations, Calculations, and Comparisons"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-of-cosmic-velocities","text":"Cosmic velocities are critical thresholds in astrodynamics, defining minimum speeds for orbital and escape maneuvers: First Cosmic Velocity \\(v_1\\) : Definition : The speed required for an object to maintain a circular orbit near a celestial body's surface. Equation : \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second Cosmic Velocity \\(v_2\\) : Definition : The speed required to escape a celestial body's gravitational pull. Equation : \\(v_2 = \\sqrt{\\frac{2GM}{R}}\\) Third Cosmic Velocity \\(v_3\\) : Definition : The speed required to escape a star system from a planet's orbit. Equation : \\(v_3 = \\sqrt{v_2^2 + (v_{\\text{esc,Sun}} - v_{\\text{orbit}})^2}\\)","title":"1. Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-derivations","text":"","title":"2. Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-first-cosmic-velocity-v_1","text":"import numpy as np import matplotlib.pyplot as plt # Constants and calculations G = 6.67430e-11 M = 5.972e24 radii = np.linspace(1e6, 1.5e7, 500) v1 = np.sqrt(G * M / radii) v1_km_s = v1 / 1000 # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Main plot line with enhanced styling main_line, = plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='#0066cc', linewidth=3) # Enhanced text elements ax.set_xlabel('Planet Radius (km)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_ylabel('First Cosmic Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('First Cosmic Velocity vs Planet Radius', fontsize=16, fontweight='bold', pad=20, color='black') # High-visibility legend legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) legend.get_texts()[0].set_color('black') legend.get_texts()[0].set_fontweight('bold') # Grid and frame ax.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # Add direct label to curve for extra clarity ax.text(8000, 7.5, r'$v_1 = \\sqrt{\\frac{GM}{R}}$', fontsize=14, fontweight='bold', color='#0066cc') # Make ticks more visible ax.tick_params(axis='both', which='both', labelsize=12, color='black') plt.tight_layout() plt.show() Derivation : Gravitational force equals centripetal force: $$ \\frac{GMm}{R^2}=\\frac{mv_1^2}{R} \\implies v_1=\\sqrt{\\frac{GM}{R}} $$","title":"2.1 First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-second-cosmic-velocity-v_2","text":"import numpy as np import matplotlib.pyplot as plt # Data v1 = np.linspace(0, 20, 500) v2 = np.sqrt(2) * v1 # Plot setup with high visibility text plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Plot lines with contrasting colors main_line, = plt.plot(v1, v2, color='#0066cc', linewidth=3, label=r'$v_2 = \\sqrt{2} \\times v_1$') ref_line, = plt.plot(v1, v1, linestyle='--', color='#cc3300', linewidth=2, label=r'$v_2 = v_1$ (reference line)') # Enhanced text elements ax.set_xlabel('First Cosmic Velocity $v_1$ (km/s)', fontsize=14, fontweight='bold', color='black') ax.set_ylabel('Second Cosmic Velocity $v_2$ (km/s)', fontsize=14, fontweight='bold', color='black') ax.set_title('Relationship between First and Second Cosmic Velocities', fontsize=16, fontweight='bold', pad=20, color='black') # High-visibility legend legend = ax.legend( handles=[main_line, ref_line], loc='upper left', frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1 ) legend.get_frame().set_linewidth(2) # Make all text elements black and bold for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') # Grid and ticks ax.grid(True, linestyle=':', color='gray', alpha=0.4) ax.tick_params(axis='both', which='major', labelsize=12, colors='black') # Add direct labels to lines for extra clarity ax.text(15, 28, r'$v_2 = \\sqrt{2}v_1$', fontsize=14, fontweight='bold', color='#0066cc') ax.text(15, 15, r'$v_2 = v_1$', fontsize=14, fontweight='bold', color='#cc3300') # Frame for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) plt.tight_layout() plt.show() Derivation : Energy conservation (kinetic + potential = 0 at infinity): \\[ \\frac{1}{2}mv_2^2 - \\frac{GMm}{R} = 0 \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\]","title":"2.2 Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-third-cosmic-velocity-v_3","text":"Derivation : Escape Sun's gravity at planet's orbital distance: $$ v_{\\text{esc,Sun}}=\\sqrt{\\frac{2GM_{\\text{Sun}}}{R_{\\text{orbit}}}} $$ Planet's orbital velocity around Sun: $$ v_{\\text{orbit}}=\\sqrt{\\frac{GM_{\\text{Sun}}}{R_{\\text{orbit}}}} $$ Total velocity from planet's surface: $$ v_3=\\sqrt{v_2^2+(v_{\\text{esc,Sun}}-v_{\\text{orbit}})^2} $$","title":"2.3 Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-cosmic-velocities-for-earth","text":"Parameters : - \\(M_{\\text{Earth}} = 5.972 \\times 10^{24} \\text{ kg}\\) - \\(R_{\\text{Earth}} = 6.371 \\times 10^6 \\text{ m}\\) - \\(R_{\\text{Earth-Sun}} = 1.496 \\times 10^{11} \\text{ m}\\) Calculations : - \\(v_1 = \\sqrt{\\frac{GM_{\\text{Earth}}}{R_{\\text{Earth}}}} \\approx 7.91 \\text{ km/s}\\) - \\(v_2 = \\sqrt{2} \\cdot v_1 \\approx 11.19 \\text{ km/s}\\) - \\(v_3 = \\sqrt{v_2^2 + (\\sqrt{\\frac{2GM_{\\text{Sun}}}{R_{\\text{Earth-Sun}}}} - \\sqrt{\\frac{GM_{\\text{Sun}}}{R_{\\text{Earth-Sun}}}})^2} \\approx 16.64 \\text{ km/s}\\)","title":"3. Cosmic Velocities for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-comparison-with-moon-mars-and-jupiter","text":"import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced styling bar_width = 0.25 bar1 = plt.bar(x, v1, width=bar_width, label='First Cosmic Velocity (v1)', color='#0066cc', edgecolor='black', linewidth=1.5) bar2 = plt.bar([i + bar_width for i in x], v2, width=bar_width, label='Second Cosmic Velocity (v2)', color='#cc3300', edgecolor='black', linewidth=1.5) bar3 = plt.bar([i + 2*bar_width for i in x], [v if v else 0 for v in v3], width=bar_width, label='Third Cosmic Velocity (v3)', color='#009966', edgecolor='black', linewidth=1.5) # Special styling for Moon's v3 (None value) bar3[1].set_hatch('//') bar3[1].set_color('#ff9999') # Enhanced text elements ax.set_ylabel('Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('Comparison of Cosmic Velocities', fontsize=16, fontweight='bold', pad=20, color='black') ax.set_xticks([i + bar_width for i in x]) ax.set_xticklabels(bodies, fontsize=12, fontweight='bold', color='black') # High-visibility legend legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') # Add value labels on bars for bars, offset in zip([bar1, bar2, bar3], [0, bar_width, 2*bar_width]): for i, bar in enumerate(bars): height = bar.get_height() if height > 0: # Only label non-zero bars ax.text(bar.get_x() + bar.get_width()/2., height + 1, f'{height:.1f}', ha='center', va='bottom', fontsize=11, fontweight='bold') # Special annotation for Moon's v3 ax.text(1 + 2*bar_width, 1, 'N/A', ha='center', va='bottom', fontsize=11, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) plt.tight_layout() plt.show() Parameters : Body Mass (kg) Radius (m) Orbital Radius (m) Moon \\(7.342 \\times 10^{22}\\) \\(1.737 \\times 10^6\\) \\(1.496 \\times 10^{11}\\) (Earth's) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.899 \\times 10^{27}\\) \\(6.991 \\times 10^7\\) \\(7.785 \\times 10^{11}\\) Calculated Velocities (km/s) : Body \\(v_1\\) \\(v_2\\) \\(v_3\\) Earth 7.91 11.19 16.64 Moon 1.68 2.38 16.51 Mars 3.55 5.03 13.09 Jupiter 42.14 59.57 9.67","title":"4. Comparison with Moon, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-visualizations","text":"","title":"5. Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#51-cosmic-velocities-comparison","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_sun = 1.989e30 # Celestial body parameters: [mass (kg), radius (m), orbital radius (m)] bodies = { 'Earth': [5.972e24, 6.371e6, 1.496e11], 'Moon': [7.342e22, 1.737e6, 1.496e11], 'Mars': [6.417e23, 3.390e6, 2.279e11], 'Jupiter': [1.899e27, 6.991e7, 7.785e11] } # Calculate cosmic velocities velocities = {'v1': {}, 'v2': {}, 'v3': {}} for body, (M, R, R_orbit) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 v2 = np.sqrt(2 * G * M / R) / 1000 v_esc_sun = np.sqrt(2 * G * M_sun / R_orbit) / 1000 v_orbit = np.sqrt(G * M_sun / R_orbit) / 1000 v3 = np.sqrt(v2**2 + (v_esc_sun - v_orbit)**2) velocities['v1'][body] = v1 velocities['v2'][body] = v2 velocities['v3'][body] = v3 # Plot fig, ax = plt.subplots(figsize=(12, 7)) x = np.arange(len(bodies)) width = 0.25 bars1 = ax.bar(x - width, velocities['v1'].values(), width, label='$v_1$') bars2 = ax.bar(x, velocities['v2'].values(), width, label='$v_2$') bars3 = ax.bar(x + width, velocities['v3'].values(), width, label='$v_3$') # Annotations for bars in [bars1, bars2, bars3]: for bar in bars: height = bar.get_height() ax.annotate(f'{height:.2f}', xy=(bar.get_x() + bar.get_width() / 2, height), xytext=(0, 3), textcoords=\"offset points\", ha='center', va='bottom') ax.set_yscale('log') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (km/s, log scale)') ax.set_title('Cosmic Velocities Comparison') ax.set_xticks(x) ax.set_xticklabels(bodies.keys()) ax.legend() ax.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('cosmic_velocities_comparison.png') plt.show() import numpy as np import matplotlib.pyplot as plt # Constants and data G = 6.67430e-11 bodies = { \"Earth\": {\"R\": 6.371e6, \"M\": 5.97e24}, \"Moon\": {\"R\": 1.74e6, \"M\": 7.35e22}, \"Mars\": {\"R\": 3.39e6, \"M\": 6.42e23}, \"Jupiter\": {\"R\": 7.15e7, \"M\": 1.90e27} } # Calculate values radii = [] v2_values = [] labels = [] for body, data in bodies.items(): R = data[\"R\"] M = data[\"M\"] v2 = np.sqrt(2 * G * M / R) / 1000 radii.append(R / 1e6) v2_values.append(v2) labels.append(body) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced styling bars = plt.bar(labels, v2_values, color=['#0066cc', '#cc3300', '#009966', '#6633cc'], edgecolor='black', linewidth=1.5, width=0.6) # Enhanced text elements ax.set_title('Second Cosmic Velocity (Escape Velocity) vs Planet Radius', fontsize=16, fontweight='bold', pad=20, color='black') ax.set_xlabel('Celestial Body', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_ylabel('Escape Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) # Value labels on bars for bar in bars: height = bar.get_height() ax.text(bar.get_x() + bar.get_width()/2., height + 0.5, f'{height:.1f} km/s', ha='center', va='bottom', fontsize=12, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # X-axis ticks ax.set_xticklabels(labels, fontsize=12, fontweight='bold', color='black') plt.tight_layout() plt.show() import matplotlib.pyplot as plt # Data celestial_bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] escape_velocities = [16.7, None, 14.1, 18.5] # Third Cosmic Velocity (km/s) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced visibility bars = plt.bar(celestial_bodies, [vel if vel else 0 for vel in escape_velocities], color=['#0066cc', '#cc3300', '#009966', '#6633cc'], width=0.6, edgecolor='black', linewidth=1.5) # Special marking for Moon (None value) bars[1].set_hatch('//') bars[1].set_color('#ff9999') bars[1].set_edgecolor('black') # Enhanced text elements ax.set_ylabel('Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('Third Cosmic Velocity Comparison for Celestial Bodies', fontsize=16, fontweight='bold', pad=20, color='black') # X-axis labels ax.set_xticklabels(celestial_bodies, fontsize=12, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # High-visibility legend legend = ax.legend(['Third Cosmic Velocity (v3)'], frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) legend.get_texts()[0].set_color('black') legend.get_texts()[0].set_fontweight('bold') # Add value labels on top of bars for bar in bars: height = bar.get_height() if height > 0: # Only label non-zero bars ax.text(bar.get_x() + bar.get_width()/2., height + 0.5, f'{height:.1f}', ha='center', va='bottom', fontsize=12, fontweight='bold') # Special annotation for Moon ax.text(bars[1].get_x() + bars[1].get_width()/2., 1, 'N/A', ha='center', va='bottom', fontsize=12, fontweight='bold', color='black') plt.tight_layout() plt.show()","title":"5.1 Cosmic Velocities Comparison"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Theoretical Analysis 1. Equations of Motion The payload's trajectory is governed by Newton's Law of Gravitation and Newton's Second Law : Newton's Law of Gravitation : \\(\\mathbf{F} = -\\frac{GMm}{r^2}\\hat{\\mathbf{r}}\\) where: - \\(G\\) = Gravitational constant ( \\(6.674 \\times 10^{-11}\\,\\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) ) - \\(M\\) = Mass of Earth ( \\(5.972 \\times 10^{24}\\,\\text{kg}\\) ) - \\(m\\) = Mass of payload (neglected for trajectory analysis) - \\(r\\) = Distance between payload and Earth's center Equation of Motion (2D Polar Coordinates) : \\(\\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3}\\mathbf{r}\\) Decomposed into Cartesian coordinates ( \\(x, y\\) ): \\(\\frac{d^2x}{dt^2} = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{(x^2 + y^2)^{3/2}}\\) 2. Trajectory Types The shape of the orbit depends on the specific orbital energy ( \\(E\\) ) and eccentricity ( \\(e\\) ): Elliptical Orbit ( \\(E < 0\\) , \\(0 \\leq e < 1\\) ): Bound orbit (e.g., satellites) Initial velocity below escape velocity: \\(v < v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}}\\) Parabolic Orbit ( \\(E = 0\\) , \\(e = 1\\) ): Escape trajectory (minimum escape condition) Initial velocity equals escape velocity: \\(v = v_{\\text{esc}}\\) Hyperbolic Orbit ( \\(E > 0\\) , \\(e > 1\\) ): Unbound trajectory (e.g., interplanetary probes) Initial velocity exceeds escape velocity: \\(v > v_{\\text{esc}}\\) 3. Initial Velocity Impact Key velocity thresholds for a payload at altitude \\(h = r - R_E\\) (Earth's radius \\(R_E = 6371\\,\\text{km}\\) ): Scenario Velocity Condition Outcome Suborbital \\(v < \\sqrt{\\frac{GM}{r}}\\) Reentry (ballistic trajectory) Circular Orbit \\(v = \\sqrt{\\frac{GM}{r}}\\) Stable orbit Elliptical Orbit \\(\\sqrt{\\frac{GM}{r}} < v < v_{\\text{esc}}\\) Apogee/perigee variation Escape \\(v \\geq v_{\\text{esc}}\\) Leaves Earth's influence Note : - Orbital Insertion : Requires precise \\(v\\) to match desired orbit - Reentry : Achieved by reducing \\(v\\) (e.g., retrograde thrust or atmospheric drag) - Escape : Requires \\(v \\geq \\sqrt{\\frac{2GM}{r}}\\) (parabolic/hyperbolic) Python Code Snippet (Symbolic Derivation) import sympy as sp # Define variables t, G, M = sp.symbols('t G M') x, y = sp.Function('x')(t), sp.Function('y')(t) # Equations of motion eq1 = sp.Eq(sp.diff(x, t, 2), -G * M * x / (x**2 + y**2)**(3/2)) eq2 = sp.Eq(sp.diff(y, t, 2), -G * M * y / (x**2 + y**2)**(3/2)) print(\"Equation for x:\", eq1) print(\"Equation for y:\", eq2) Numerical Simulation Setup 1. Initial Conditions We define the payload's initial state in Cartesian coordinates: Position : \\( \\(x_0=(R_E+h)\\cos\\theta\\) \\) \\( \\(y_0=(R_E+h)\\sin\\theta\\) \\) where: - \\(R_E=6371\\,\\text{km}\\) (Earth's radius) - \\(h\\) =altitude above surface - \\(\\theta\\) =angular position from reference axis Velocity : \\( \\(v_{x0}=v_0\\cos\\phi\\) \\) \\( \\(v_{y0}=v_0\\sin\\phi\\) \\) where: - \\(v_0\\) =initial speed - \\(\\phi\\) =launch angle from horizontal 2. Numerical Method Selection We solve the coupled ODEs using the 4th-order Runge-Kutta method (RK4) for higher accuracy: The general RK4 formulation for \\(\\frac{dy}{dt}=f(t,y)\\) : \\( \\(k_1=f(t_n,y_n)\\) \\) \\( \\(k_2=f(t_n+\\frac{h}{2},y_n+\\frac{h}{2}k_1)\\) \\) \\( \\(k_3=f(t_n+\\frac{h}{2},y_n+\\frac{h}{2}k_2)\\) \\) \\( \\(k_4=f(t_n+h,y_n+hk_3)\\) \\) \\( \\(y_{n+1}=y_n+\\frac{h}{6}(k_1+2k_2+2k_3+k_4)\\) \\) 3. Implementation Framework Python Implementation import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_E = 6371e3 # m def equations_of_motion(t, state): \"\"\"ODE system for payload trajectory\"\"\" x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] def simulate_trajectory(h, v0, theta, phi, t_span, dt): \"\"\"Run trajectory simulation\"\"\" # Initial conditions r0 = R_E + h x0 = r0 * np.cos(theta) y0 = r0 * np.sin(theta) vx0 = v0 * np.cos(phi) vy0 = v0 * np.sin(phi) # Time points t_eval = np.arange(t_span[0], t_span[1], dt) # Solve ODE sol = solve_ivp(equations_of_motion, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') return sol # Example usage h = 500e3 # 500 km altitude v0 = 7.5e3 # 7.5 km/s theta = 0 # Initial angle phi = np.pi/4 # 45 degree launch angle t_span = [0, 3600*2] # 2 hour simulation dt = 10 # 10 second timestep solution = simulate_trajectory(h, v0, theta, phi, t_span, dt) \ud83d\udcd8 Projectile Motion Simulation \u2014 Computational Implementation \ud83c\udfaf Objective To simulate the trajectory of a projectile under idealized physics using Python, with adjustable parameters such as: Initial speed \\(v_0\\) Launch angle \\(\\theta\\) Initial height \\(h_0\\) Gravitational acceleration \\(g\\) \ud83e\uddee Governing Equations The equations of motion for a projectile launched at an angle \\(\\theta\\) from an initial height \\(h_0\\) are: Horizontal velocity: $$ v_x = v_0\\cos(\\theta) $$ Vertical velocity: $$ v_y = v_0\\sin(\\theta) $$ Position as a function of time: $$ x(t) = v_0\\cos(\\theta)\\cdot t $$ $$ y(t) = h_0 + v_0\\sin(\\theta)\\cdot t - \\frac{1}{2}gt^2 $$ Time of flight (solving \\(y(t) = 0\\) ): $$ t = \\frac{v_0\\sin(\\theta)}{g} + \\sqrt{\\left(\\frac{v_0\\sin(\\theta)}{g}\\right)^2 + \\frac{2h_0}{g}} $$ \ud83e\uddf0 Required Libraries numpy \u2013 numerical calculations matplotlib.pyplot \u2013 visualization \ud83e\uddea Python Code Implementation import numpy as np import matplotlib.pyplot as plt # Adjustable parameters v0 = 30 # Initial speed (m/s) theta_deg = 45 # Launch angle in degrees h0 = 0 # Initial height (m) g = 9.81 # Gravity (m/s^2) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight t_flight = (v0 * np.sin(theta) / g) + np.sqrt((v0 * np.sin(theta) / g) ** 2 + (2 * h0 / g)) # Time points t = np.linspace(0, t_flight, num=500) # Position calculations x = v0 * np.cos(theta) * t y = h0 + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot trajectory plt.figure(figsize=(10, 5)) plt.plot(x, y, label=f'{v0} m/s at {theta_deg}\u00b0') plt.title('Projectile Motion Simulation') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.axhline(0, color='gray', linestyle='--', linewidth=0.7) plt.legend() plt.show() \ud83c\udf0d Trajectory Visualization \u2014 Orbital Mechanics \ud83d\ude80 Objective To visualize the trajectory of a payload launched from Earth under different initial velocity conditions: Suborbital Orbital Escape trajectory \ud83c\udfaf Key Features Plot the trajectory of the payload relative to Earth Highlight: Perigee : Closest approach to Earth Apogee : Farthest point in bound trajectory Escape condition : Payload escapes Earth's gravity Compare different initial velocities and their effects \ud83e\uddee Governing Equations We assume: Two-body problem (Earth and payload) Only gravitational force acts (no atmosphere, no thrust) Let: \\(G\\) = gravitational constant \\(M\\) = mass of Earth \\(r\\) = radial distance from Earth's center \\(v\\) = speed \\(\\mu=GM\\) = standard gravitational parameter Kinetic and Potential Energy Kinetic energy per unit mass: \\( \\(KE=\\frac{1}{2}v^2\\) \\) Gravitational potential energy per unit mass: \\( \\(PE=-\\frac{\\mu}{r}\\) \\) Total specific energy: \\( \\(\\varepsilon=KE+PE=\\frac{1}{2}v^2-\\frac{\\mu}{r}\\) \\) Trajectory Type If \\(\\varepsilon<0\\) : Bound (elliptical) \u2013 orbital or suborbital If \\(\\varepsilon=0\\) : Parabolic escape If \\(\\varepsilon>0\\) : Hyperbolic escape \ud83e\uddf0 Required Libraries numpy \u2013 numerical integration and array math matplotlib \u2013 for plotting scipy.integrate \u2013 to solve equations of motion \ud83e\uddea Python Code Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Earth mass (kg) mu = G * M R_earth = 6.371e6 # Earth radius in meters # Initial conditions altitude = 300e3 # 300 km above Earth's surface r0 = R_earth + altitude theta0 = 0 positions = [] labels = [] # Different initial velocities (m/s) v_suborbital = 6500 # Less than orbital v_orbital = np.sqrt(mu / r0) # Circular orbit speed v_escape = np.sqrt(2 * mu / r0) # Escape velocity initial_scenarios = [ (\"Suborbital\", v_suborbital), (\"Orbital\", v_orbital), (\"Escape\", v_escape) ] # Equations of motion in polar coordinates def orbital_dynamics(t, y): x, y_, vx, vy = y r = np.sqrt(x**2 + y_**2) ax = -mu * x / r**3 ay = -mu * y_ / r**3 return [vx, vy, ax, ay] # Time span for simulation t_span = (0, 6000) t_eval = np.linspace(t_span[0], t_span[1], 5000) # Solve and plot each scenario plt.figure(figsize=(8, 8)) for label, v0 in initial_scenarios: y0 = [r0, 0, 0, v0] # [x, y, vx, vy] sol = solve_ivp(orbital_dynamics, t_span, y0, t_eval=t_eval, rtol=1e-8) x = sol.y[0] y = sol.y[1] plt.plot(x / 1e3, y / 1e3, label=f\"{label} ({v0:.0f} m/s)\") # Plot Earth theta = np.linspace(0, 2*np.pi, 1000) earth_x = R_earth * np.cos(theta) / 1e3 earth_y = R_earth * np.sin(theta) / 1e3 plt.fill(earth_x, earth_y, 'lightblue', label='Earth') # Plot formatting plt.title(\"Trajectory Visualization: Suborbital, Orbital, Escape\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show() \ud83e\udde0 Analysis & Discussion \u2014 Orbital Trajectory Behavior \ud83d\udd04 Impact of Varying Initial Conditions \ud83d\udea6 Initial Speed The trajectory of a payload launched from Earth depends critically on its initial velocity ( \\(v_0\\) ) : If \\(v_0<\\sqrt{\\frac{\\mu}{r_0}}\\) : Trajectory is suborbital Payload returns to Earth after reaching maximum altitude (like ballistic missile) If \\(v_0=\\sqrt{\\frac{\\mu}{r_0}}\\) : Trajectory is circular orbit Stable orbit at constant altitude If \\(v_0\\) is such that \\(0<\\varepsilon<0\\) : Elliptical orbit , where perigee and apogee differ If \\(v_0=\\sqrt{\\frac{2\\mu}{r_0}}\\) : Parabolic trajectory (escape) If \\(v_0>\\sqrt{\\frac{2\\mu}{r_0}}\\) : Hyperbolic escape from Earth's gravity Here, \\(\\mu=GM\\) is the standard gravitational parameter, and \\(r_0\\) is the initial radial distance from Earth\u2019s center. \ud83c\udf10 Real-World Applications Trajectory Type Application Example Suborbital Space tourism, sounding rockets Circular Orbit Low Earth Orbit (LEO) satellites Elliptical Orbit Molniya orbits, Geostationary Transfer Orbit Escape Interplanetary missions (e.g., Voyager, JWST) \ud83d\udd2c Validation Against Orbital Mechanics We validate the numerical simulations using known orbital mechanics principles , including Kepler\u2019s Laws : 1. Kepler\u2019s First Law Every planet moves in an ellipse with the Sun (or Earth) at one focus. For bound orbits ( \\(\\varepsilon<0\\) ), our simulated trajectories are elliptical. For \\(v_0=\\sqrt{\\mu/r_0}\\) , the orbit becomes a special case: a circle . 2. Kepler\u2019s Second Law A line joining a planet and the Sun sweeps out equal areas in equal times. Since gravity is a central force , angular momentum is conserved: \\( \\(\\vec{r}\\times\\vec{v}=\\text{constant}\\) \\) Numerically, this is evident as orbital speed increases at perigee and decreases at apogee. 3. Kepler\u2019s Third Law The square of the orbital period is proportional to the cube of the semi-major axis: \\( \\(T^2\\propto a^3\\) \\) For circular orbits: \\( \\(T=2\\pi\\sqrt{\\frac{r_0^3}{\\mu}}\\) \\) Simulation-derived periods match this analytical value closely. \u2705 Takeaways Initial velocity is the primary control variable for trajectory shaping. The simulated motion adheres to Keplerian dynamics under ideal conditions. Such tools are vital in: Mission planning Satellite deployment strategies Trajectory correction maneuvers Reentry analysis for crewed missions \ud83d\udcd8 Further Enhancements Include atmospheric drag for low-altitude missions. Account for Earth\u2019s rotation and non-spherical mass distribution . Add thrust profiles for real rocket burns and transfers (e.g., Hohmann transfers). \ud83d\udcc4 Trajectory Simulation: Methodology and Findings \ud83e\uddf0 1. Methodology Overview We analyze the motion of a payload launched from Earth under varying initial speeds. The goal is to understand how different initial velocities affect orbital trajectories. \ud83d\udd27 Assumptions: Two-body system: Earth and payload. No atmospheric drag or thrust during flight. Earth is a perfect sphere. Gravitational force is central and inverse-square. Let: \\(G\\) : Gravitational constant \\(M\\) : Mass of Earth \\(\\mu=GM\\) : Standard gravitational parameter \\(r\\) : Radial distance from Earth's center \\(v\\) : Speed of payload \\(\\varepsilon\\) : Specific mechanical energy \ud83e\uddee 2. Governing Equations Kinetic and Potential Energy Kinetic Energy per unit mass: \\( \\(KE=\\frac{1}{2}v^2\\) \\) Gravitational Potential Energy per unit mass: \\( \\(PE=-\\frac{\\mu}{r}\\) \\) Total Specific Mechanical Energy: \\( \\(\\varepsilon=\\frac{1}{2}v^2-\\frac{\\mu}{r}\\) \\) Trajectory Classification If \\(\\varepsilon<0\\) : Bound Orbit (elliptical or circular) If \\(\\varepsilon=0\\) : Parabolic Escape If \\(\\varepsilon>0\\) : Hyperbolic Escape \ud83e\uddea 3. Python Code Snippet import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 M = 5.972e24 mu = G * M R_earth = 6.371e6 # Initial state setup altitude = 300e3 r0 = R_earth + altitude v_orbital = np.sqrt(mu / r0) v_escape = np.sqrt(2 * mu / r0) # Equations of motion def dynamics(t, y): x, y_, vx, vy = y r = np.sqrt(x**2 + y_**2) ax = -mu * x / r**3 ay = -mu * y_ / r**3 return [vx, vy, ax, ay] import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.97e24 # Mass of Earth (kg) radius_earth = 6.371e6 # Radius of Earth (m) # Time parameters dt = 100 # Time step (seconds) T = 3600 * 24 # Total time of simulation (1 day) # Initial conditions: (initial position, initial velocity) initial_conditions = { 'x0': 1.5 * radius_earth, # 1.5 Earth radii from Earth's center (m) 'y0': 0, # Along the x-axis (horizontal direction) 'vx0': 0, # Initial velocity in x-direction (m/s) 'vy0': 5000 # Initial velocity in y-direction (m/s) } # Function to compute acceleration due to gravity def gravity_acceleration(x, y): r = np.sqrt(x**2 + y**2) # Fixed: Correct distance from Earth's center a = -G * M / r**2 # Gravitational acceleration ax = a * x / r # Acceleration in x-direction ay = a * y / r # Acceleration in y-direction return ax, ay # Initialize position and velocity arrays x, y = [initial_conditions['x0']], [initial_conditions['y0']] vx, vy = [initial_conditions['vx0']], [initial_conditions['vy0']] # Numerical integration using Euler's method for t in np.arange(0, T, dt): ax, ay = gravity_acceleration(x[-1], y[-1]) # Get acceleration at current position # Update velocities vx.append(vx[-1] + ax * dt) vy.append(vy[-1] + ay * dt) # Update positions x.append(x[-1] + vx[-1] * dt) y.append(y[-1] + vy[-1] * dt) # Convert the results into numpy arrays for easier plotting x = np.array(x) y = np.array(y) # Plot setup with high-visibility and cool styling plt.figure(figsize=(8, 6), facecolor='white') ax = plt.gca() # Plot the trajectory with vibrant styling plt.plot(x / 1e3, y / 1e3, color='#0066cc', linewidth=3, label='Payload Trajectory', linestyle='-', alpha=0.9) plt.scatter([0], [0], color='#cc3300', s=150, edgecolor='black', linewidth=2, label='Earth', marker='o', zorder=5) # Add a cool gradient-like effect to the trajectory plt.plot(x / 1e3, y / 1e3, color='#009966', linewidth=1.5, linestyle='--', alpha=0.5) # Enhanced text elements with bold, modern fonts ax.set_xlabel('X Position (km)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_ylabel('Y Position (km)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_title('Payload Trajectory Near Earth', fontsize=18, fontweight='bold', pad=20, color='black', family='Arial') # High-visibility legend with a sleek look legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1, loc='upper right') for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') text.set_fontfamily('Arial') # Add a subtle annotation for the starting point ax.annotate('Start', xy=(x[0] / 1e3, y[0] / 1e3), xytext=(x[0] / 1e3 + 500, y[0] / 1e3 + 500), arrowprops=dict(facecolor='black', arrowstyle='->'), fontsize=10, fontweight='bold', color='black', family='Arial') # Cool grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) ax.xaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2.5) # Set a sleek background and axis styling ax.set_facecolor('#f5f5f5') plt.axis('equal') plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R = 6.371e6 # radius of Earth in meters altitude = 800e3 # 800 km above the surface initial_distance = R + altitude time_step = 1 # seconds total_time = 7000 # simulate up to 7000 seconds n_steps = int(total_time / time_step) # Initial velocities in m/s velocities = np.arange(5000, 13500, 500) # from 5 km/s to 13 km/s # Plot setup with high-visibility and cool styling plt.figure(figsize=(10, 10), facecolor='white') ax = plt.gca() # Create Earth plot with enhanced styling theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) earth_y = R * np.sin(theta) plt.fill(earth_x, earth_y, color='#0066cc', alpha=0.6, edgecolor='black', linewidth=2, label='Earth') # Function to compute gravity acceleration def gravity(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # Simulate each trajectory with distinct colors colors = ['#cc3300', '#009966', '#ff6600', '#660099', '#ff3399', '#006666', '#cc9900', '#990000', '#00cc99', '#ff9933', '#3333cc', '#ff0066', '#669900', '#9900cc', '#00ff66', '#cc0066'] for i, v in enumerate(velocities): pos = np.array([initial_distance, 0.0]) vel = np.array([0.0, v]) traj = [] for _ in range(n_steps): acc = gravity(pos) vel += acc * time_step pos += vel * time_step traj.append(pos.copy()) if np.linalg.norm(pos) <= R: break traj = np.array(traj) plt.plot(traj[:, 0], traj[:, 1], color=colors[i % len(colors)], linewidth=2.5, label=f'{v/1000:.1f} km/s', alpha=0.9) # Plot center of Earth plt.scatter([0], [0], color='black', s=100, edgecolor='black', linewidth=2, marker='o', label='Center of Earth', zorder=5) # Add annotation for starting point plt.annotate('Start', xy=(initial_distance, 0), xytext=(initial_distance + 1e6, 0.5e6), arrowprops=dict(facecolor='black', arrowstyle='->'), fontsize=10, fontweight='bold', color='black', family='Arial') # Enhanced text elements with bold, modern fonts ax.set_xlabel('X Position (m)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_ylabel('Y Position (m)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_title('Trajectories of Objects from 800 km Altitude with Varying Speeds', fontsize=18, fontweight='bold', pad=20, color='black', family='Arial') # High-visibility legend with a sleek look legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=10, borderpad=1, loc='upper right') for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') text.set_fontfamily('Arial') # Cool grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) ax.xaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2.5) # Set a sleek background and axis styling ax.set_facecolor('#f5f5f5') plt.axis('equal') plt.tight_layout() plt.savefig('multi_trajectory_plot.png')","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-analysis","text":"","title":"Theoretical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-equations-of-motion","text":"The payload's trajectory is governed by Newton's Law of Gravitation and Newton's Second Law : Newton's Law of Gravitation : \\(\\mathbf{F} = -\\frac{GMm}{r^2}\\hat{\\mathbf{r}}\\) where: - \\(G\\) = Gravitational constant ( \\(6.674 \\times 10^{-11}\\,\\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) ) - \\(M\\) = Mass of Earth ( \\(5.972 \\times 10^{24}\\,\\text{kg}\\) ) - \\(m\\) = Mass of payload (neglected for trajectory analysis) - \\(r\\) = Distance between payload and Earth's center Equation of Motion (2D Polar Coordinates) : \\(\\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3}\\mathbf{r}\\) Decomposed into Cartesian coordinates ( \\(x, y\\) ): \\(\\frac{d^2x}{dt^2} = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{(x^2 + y^2)^{3/2}}\\)","title":"1. Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-trajectory-types","text":"The shape of the orbit depends on the specific orbital energy ( \\(E\\) ) and eccentricity ( \\(e\\) ): Elliptical Orbit ( \\(E < 0\\) , \\(0 \\leq e < 1\\) ): Bound orbit (e.g., satellites) Initial velocity below escape velocity: \\(v < v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}}\\) Parabolic Orbit ( \\(E = 0\\) , \\(e = 1\\) ): Escape trajectory (minimum escape condition) Initial velocity equals escape velocity: \\(v = v_{\\text{esc}}\\) Hyperbolic Orbit ( \\(E > 0\\) , \\(e > 1\\) ): Unbound trajectory (e.g., interplanetary probes) Initial velocity exceeds escape velocity: \\(v > v_{\\text{esc}}\\)","title":"2. Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-initial-velocity-impact","text":"Key velocity thresholds for a payload at altitude \\(h = r - R_E\\) (Earth's radius \\(R_E = 6371\\,\\text{km}\\) ): Scenario Velocity Condition Outcome Suborbital \\(v < \\sqrt{\\frac{GM}{r}}\\) Reentry (ballistic trajectory) Circular Orbit \\(v = \\sqrt{\\frac{GM}{r}}\\) Stable orbit Elliptical Orbit \\(\\sqrt{\\frac{GM}{r}} < v < v_{\\text{esc}}\\) Apogee/perigee variation Escape \\(v \\geq v_{\\text{esc}}\\) Leaves Earth's influence Note : - Orbital Insertion : Requires precise \\(v\\) to match desired orbit - Reentry : Achieved by reducing \\(v\\) (e.g., retrograde thrust or atmospheric drag) - Escape : Requires \\(v \\geq \\sqrt{\\frac{2GM}{r}}\\) (parabolic/hyperbolic)","title":"3. Initial Velocity Impact"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-snippet-symbolic-derivation","text":"import sympy as sp # Define variables t, G, M = sp.symbols('t G M') x, y = sp.Function('x')(t), sp.Function('y')(t) # Equations of motion eq1 = sp.Eq(sp.diff(x, t, 2), -G * M * x / (x**2 + y**2)**(3/2)) eq2 = sp.Eq(sp.diff(y, t, 2), -G * M * y / (x**2 + y**2)**(3/2)) print(\"Equation for x:\", eq1) print(\"Equation for y:\", eq2)","title":"Python Code Snippet (Symbolic Derivation)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-setup","text":"","title":"Numerical Simulation Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-initial-conditions","text":"We define the payload's initial state in Cartesian coordinates: Position : \\( \\(x_0=(R_E+h)\\cos\\theta\\) \\) \\( \\(y_0=(R_E+h)\\sin\\theta\\) \\) where: - \\(R_E=6371\\,\\text{km}\\) (Earth's radius) - \\(h\\) =altitude above surface - \\(\\theta\\) =angular position from reference axis Velocity : \\( \\(v_{x0}=v_0\\cos\\phi\\) \\) \\( \\(v_{y0}=v_0\\sin\\phi\\) \\) where: - \\(v_0\\) =initial speed - \\(\\phi\\) =launch angle from horizontal","title":"1. Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-method-selection","text":"We solve the coupled ODEs using the 4th-order Runge-Kutta method (RK4) for higher accuracy: The general RK4 formulation for \\(\\frac{dy}{dt}=f(t,y)\\) : \\( \\(k_1=f(t_n,y_n)\\) \\) \\( \\(k_2=f(t_n+\\frac{h}{2},y_n+\\frac{h}{2}k_1)\\) \\) \\( \\(k_3=f(t_n+\\frac{h}{2},y_n+\\frac{h}{2}k_2)\\) \\) \\( \\(k_4=f(t_n+h,y_n+hk_3)\\) \\) \\( \\(y_{n+1}=y_n+\\frac{h}{6}(k_1+2k_2+2k_3+k_4)\\) \\)","title":"2. Numerical Method Selection"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-implementation-framework","text":"","title":"3. Implementation Framework"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_E = 6371e3 # m def equations_of_motion(t, state): \"\"\"ODE system for payload trajectory\"\"\" x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] def simulate_trajectory(h, v0, theta, phi, t_span, dt): \"\"\"Run trajectory simulation\"\"\" # Initial conditions r0 = R_E + h x0 = r0 * np.cos(theta) y0 = r0 * np.sin(theta) vx0 = v0 * np.cos(phi) vy0 = v0 * np.sin(phi) # Time points t_eval = np.arange(t_span[0], t_span[1], dt) # Solve ODE sol = solve_ivp(equations_of_motion, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') return sol # Example usage h = 500e3 # 500 km altitude v0 = 7.5e3 # 7.5 km/s theta = 0 # Initial angle phi = np.pi/4 # 45 degree launch angle t_span = [0, 3600*2] # 2 hour simulation dt = 10 # 10 second timestep solution = simulate_trajectory(h, v0, theta, phi, t_span, dt)","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#projectile-motion-simulation-computational-implementation","text":"","title":"\ud83d\udcd8 Projectile Motion Simulation \u2014 Computational Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective","text":"To simulate the trajectory of a projectile under idealized physics using Python, with adjustable parameters such as: Initial speed \\(v_0\\) Launch angle \\(\\theta\\) Initial height \\(h_0\\) Gravitational acceleration \\(g\\)","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"The equations of motion for a projectile launched at an angle \\(\\theta\\) from an initial height \\(h_0\\) are: Horizontal velocity: $$ v_x = v_0\\cos(\\theta) $$ Vertical velocity: $$ v_y = v_0\\sin(\\theta) $$ Position as a function of time: $$ x(t) = v_0\\cos(\\theta)\\cdot t $$ $$ y(t) = h_0 + v_0\\sin(\\theta)\\cdot t - \\frac{1}{2}gt^2 $$ Time of flight (solving \\(y(t) = 0\\) ): $$ t = \\frac{v_0\\sin(\\theta)}{g} + \\sqrt{\\left(\\frac{v_0\\sin(\\theta)}{g}\\right)^2 + \\frac{2h_0}{g}} $$","title":"\ud83e\uddee Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#required-libraries","text":"numpy \u2013 numerical calculations matplotlib.pyplot \u2013 visualization","title":"\ud83e\uddf0 Required Libraries"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Adjustable parameters v0 = 30 # Initial speed (m/s) theta_deg = 45 # Launch angle in degrees h0 = 0 # Initial height (m) g = 9.81 # Gravity (m/s^2) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight t_flight = (v0 * np.sin(theta) / g) + np.sqrt((v0 * np.sin(theta) / g) ** 2 + (2 * h0 / g)) # Time points t = np.linspace(0, t_flight, num=500) # Position calculations x = v0 * np.cos(theta) * t y = h0 + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot trajectory plt.figure(figsize=(10, 5)) plt.plot(x, y, label=f'{v0} m/s at {theta_deg}\u00b0') plt.title('Projectile Motion Simulation') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.axhline(0, color='gray', linestyle='--', linewidth=0.7) plt.legend() plt.show()","title":"\ud83e\uddea Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-visualization-orbital-mechanics","text":"","title":"\ud83c\udf0d Trajectory Visualization \u2014 Orbital Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective_1","text":"To visualize the trajectory of a payload launched from Earth under different initial velocity conditions: Suborbital Orbital Escape trajectory","title":"\ud83d\ude80 Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-features","text":"Plot the trajectory of the payload relative to Earth Highlight: Perigee : Closest approach to Earth Apogee : Farthest point in bound trajectory Escape condition : Payload escapes Earth's gravity Compare different initial velocities and their effects","title":"\ud83c\udfaf Key Features"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations_1","text":"We assume: Two-body problem (Earth and payload) Only gravitational force acts (no atmosphere, no thrust) Let: \\(G\\) = gravitational constant \\(M\\) = mass of Earth \\(r\\) = radial distance from Earth's center \\(v\\) = speed \\(\\mu=GM\\) = standard gravitational parameter","title":"\ud83e\uddee Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#kinetic-and-potential-energy","text":"Kinetic energy per unit mass: \\( \\(KE=\\frac{1}{2}v^2\\) \\) Gravitational potential energy per unit mass: \\( \\(PE=-\\frac{\\mu}{r}\\) \\) Total specific energy: \\( \\(\\varepsilon=KE+PE=\\frac{1}{2}v^2-\\frac{\\mu}{r}\\) \\)","title":"Kinetic and Potential Energy"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-type","text":"If \\(\\varepsilon<0\\) : Bound (elliptical) \u2013 orbital or suborbital If \\(\\varepsilon=0\\) : Parabolic escape If \\(\\varepsilon>0\\) : Hyperbolic escape","title":"Trajectory Type"},{"location":"1%20Physics/2%20Gravity/Problem_3/#required-libraries_1","text":"numpy \u2013 numerical integration and array math matplotlib \u2013 for plotting scipy.integrate \u2013 to solve equations of motion","title":"\ud83e\uddf0 Required Libraries"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-implementation_1","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Earth mass (kg) mu = G * M R_earth = 6.371e6 # Earth radius in meters # Initial conditions altitude = 300e3 # 300 km above Earth's surface r0 = R_earth + altitude theta0 = 0 positions = [] labels = [] # Different initial velocities (m/s) v_suborbital = 6500 # Less than orbital v_orbital = np.sqrt(mu / r0) # Circular orbit speed v_escape = np.sqrt(2 * mu / r0) # Escape velocity initial_scenarios = [ (\"Suborbital\", v_suborbital), (\"Orbital\", v_orbital), (\"Escape\", v_escape) ] # Equations of motion in polar coordinates def orbital_dynamics(t, y): x, y_, vx, vy = y r = np.sqrt(x**2 + y_**2) ax = -mu * x / r**3 ay = -mu * y_ / r**3 return [vx, vy, ax, ay] # Time span for simulation t_span = (0, 6000) t_eval = np.linspace(t_span[0], t_span[1], 5000) # Solve and plot each scenario plt.figure(figsize=(8, 8)) for label, v0 in initial_scenarios: y0 = [r0, 0, 0, v0] # [x, y, vx, vy] sol = solve_ivp(orbital_dynamics, t_span, y0, t_eval=t_eval, rtol=1e-8) x = sol.y[0] y = sol.y[1] plt.plot(x / 1e3, y / 1e3, label=f\"{label} ({v0:.0f} m/s)\") # Plot Earth theta = np.linspace(0, 2*np.pi, 1000) earth_x = R_earth * np.cos(theta) / 1e3 earth_y = R_earth * np.sin(theta) / 1e3 plt.fill(earth_x, earth_y, 'lightblue', label='Earth') # Plot formatting plt.title(\"Trajectory Visualization: Suborbital, Orbital, Escape\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"\ud83e\uddea Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#analysis-discussion-orbital-trajectory-behavior","text":"","title":"\ud83e\udde0 Analysis &amp; Discussion \u2014 Orbital Trajectory Behavior"},{"location":"1%20Physics/2%20Gravity/Problem_3/#impact-of-varying-initial-conditions","text":"","title":"\ud83d\udd04 Impact of Varying Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-speed","text":"The trajectory of a payload launched from Earth depends critically on its initial velocity ( \\(v_0\\) ) : If \\(v_0<\\sqrt{\\frac{\\mu}{r_0}}\\) : Trajectory is suborbital Payload returns to Earth after reaching maximum altitude (like ballistic missile) If \\(v_0=\\sqrt{\\frac{\\mu}{r_0}}\\) : Trajectory is circular orbit Stable orbit at constant altitude If \\(v_0\\) is such that \\(0<\\varepsilon<0\\) : Elliptical orbit , where perigee and apogee differ If \\(v_0=\\sqrt{\\frac{2\\mu}{r_0}}\\) : Parabolic trajectory (escape) If \\(v_0>\\sqrt{\\frac{2\\mu}{r_0}}\\) : Hyperbolic escape from Earth's gravity Here, \\(\\mu=GM\\) is the standard gravitational parameter, and \\(r_0\\) is the initial radial distance from Earth\u2019s center.","title":"\ud83d\udea6 Initial Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Trajectory Type Application Example Suborbital Space tourism, sounding rockets Circular Orbit Low Earth Orbit (LEO) satellites Elliptical Orbit Molniya orbits, Geostationary Transfer Orbit Escape Interplanetary missions (e.g., Voyager, JWST)","title":"\ud83c\udf10 Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#validation-against-orbital-mechanics","text":"We validate the numerical simulations using known orbital mechanics principles , including Kepler\u2019s Laws :","title":"\ud83d\udd2c Validation Against Orbital Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-keplers-first-law","text":"Every planet moves in an ellipse with the Sun (or Earth) at one focus. For bound orbits ( \\(\\varepsilon<0\\) ), our simulated trajectories are elliptical. For \\(v_0=\\sqrt{\\mu/r_0}\\) , the orbit becomes a special case: a circle .","title":"1. Kepler\u2019s First Law"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-keplers-second-law","text":"A line joining a planet and the Sun sweeps out equal areas in equal times. Since gravity is a central force , angular momentum is conserved: \\( \\(\\vec{r}\\times\\vec{v}=\\text{constant}\\) \\) Numerically, this is evident as orbital speed increases at perigee and decreases at apogee.","title":"2. Kepler\u2019s Second Law"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-keplers-third-law","text":"The square of the orbital period is proportional to the cube of the semi-major axis: \\( \\(T^2\\propto a^3\\) \\) For circular orbits: \\( \\(T=2\\pi\\sqrt{\\frac{r_0^3}{\\mu}}\\) \\) Simulation-derived periods match this analytical value closely.","title":"3. Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_3/#takeaways","text":"Initial velocity is the primary control variable for trajectory shaping. The simulated motion adheres to Keplerian dynamics under ideal conditions. Such tools are vital in: Mission planning Satellite deployment strategies Trajectory correction maneuvers Reentry analysis for crewed missions","title":"\u2705 Takeaways"},{"location":"1%20Physics/2%20Gravity/Problem_3/#further-enhancements","text":"Include atmospheric drag for low-altitude missions. Account for Earth\u2019s rotation and non-spherical mass distribution . Add thrust profiles for real rocket burns and transfers (e.g., Hohmann transfers).","title":"\ud83d\udcd8 Further Enhancements"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-simulation-methodology-and-findings","text":"","title":"\ud83d\udcc4 Trajectory Simulation: Methodology and Findings"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-methodology-overview","text":"We analyze the motion of a payload launched from Earth under varying initial speeds. The goal is to understand how different initial velocities affect orbital trajectories.","title":"\ud83e\uddf0 1. Methodology Overview"},{"location":"1%20Physics/2%20Gravity/Problem_3/#assumptions","text":"Two-body system: Earth and payload. No atmospheric drag or thrust during flight. Earth is a perfect sphere. Gravitational force is central and inverse-square. Let: \\(G\\) : Gravitational constant \\(M\\) : Mass of Earth \\(\\mu=GM\\) : Standard gravitational parameter \\(r\\) : Radial distance from Earth's center \\(v\\) : Speed of payload \\(\\varepsilon\\) : Specific mechanical energy","title":"\ud83d\udd27 Assumptions:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-governing-equations","text":"","title":"\ud83e\uddee 2. Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#kinetic-and-potential-energy_1","text":"Kinetic Energy per unit mass: \\( \\(KE=\\frac{1}{2}v^2\\) \\) Gravitational Potential Energy per unit mass: \\( \\(PE=-\\frac{\\mu}{r}\\) \\) Total Specific Mechanical Energy: \\( \\(\\varepsilon=\\frac{1}{2}v^2-\\frac{\\mu}{r}\\) \\)","title":"Kinetic and Potential Energy"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-classification","text":"If \\(\\varepsilon<0\\) : Bound Orbit (elliptical or circular) If \\(\\varepsilon=0\\) : Parabolic Escape If \\(\\varepsilon>0\\) : Hyperbolic Escape","title":"Trajectory Classification"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-python-code-snippet","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 M = 5.972e24 mu = G * M R_earth = 6.371e6 # Initial state setup altitude = 300e3 r0 = R_earth + altitude v_orbital = np.sqrt(mu / r0) v_escape = np.sqrt(2 * mu / r0) # Equations of motion def dynamics(t, y): x, y_, vx, vy = y r = np.sqrt(x**2 + y_**2) ax = -mu * x / r**3 ay = -mu * y_ / r**3 return [vx, vy, ax, ay] import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.97e24 # Mass of Earth (kg) radius_earth = 6.371e6 # Radius of Earth (m) # Time parameters dt = 100 # Time step (seconds) T = 3600 * 24 # Total time of simulation (1 day) # Initial conditions: (initial position, initial velocity) initial_conditions = { 'x0': 1.5 * radius_earth, # 1.5 Earth radii from Earth's center (m) 'y0': 0, # Along the x-axis (horizontal direction) 'vx0': 0, # Initial velocity in x-direction (m/s) 'vy0': 5000 # Initial velocity in y-direction (m/s) } # Function to compute acceleration due to gravity def gravity_acceleration(x, y): r = np.sqrt(x**2 + y**2) # Fixed: Correct distance from Earth's center a = -G * M / r**2 # Gravitational acceleration ax = a * x / r # Acceleration in x-direction ay = a * y / r # Acceleration in y-direction return ax, ay # Initialize position and velocity arrays x, y = [initial_conditions['x0']], [initial_conditions['y0']] vx, vy = [initial_conditions['vx0']], [initial_conditions['vy0']] # Numerical integration using Euler's method for t in np.arange(0, T, dt): ax, ay = gravity_acceleration(x[-1], y[-1]) # Get acceleration at current position # Update velocities vx.append(vx[-1] + ax * dt) vy.append(vy[-1] + ay * dt) # Update positions x.append(x[-1] + vx[-1] * dt) y.append(y[-1] + vy[-1] * dt) # Convert the results into numpy arrays for easier plotting x = np.array(x) y = np.array(y) # Plot setup with high-visibility and cool styling plt.figure(figsize=(8, 6), facecolor='white') ax = plt.gca() # Plot the trajectory with vibrant styling plt.plot(x / 1e3, y / 1e3, color='#0066cc', linewidth=3, label='Payload Trajectory', linestyle='-', alpha=0.9) plt.scatter([0], [0], color='#cc3300', s=150, edgecolor='black', linewidth=2, label='Earth', marker='o', zorder=5) # Add a cool gradient-like effect to the trajectory plt.plot(x / 1e3, y / 1e3, color='#009966', linewidth=1.5, linestyle='--', alpha=0.5) # Enhanced text elements with bold, modern fonts ax.set_xlabel('X Position (km)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_ylabel('Y Position (km)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_title('Payload Trajectory Near Earth', fontsize=18, fontweight='bold', pad=20, color='black', family='Arial') # High-visibility legend with a sleek look legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1, loc='upper right') for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') text.set_fontfamily('Arial') # Add a subtle annotation for the starting point ax.annotate('Start', xy=(x[0] / 1e3, y[0] / 1e3), xytext=(x[0] / 1e3 + 500, y[0] / 1e3 + 500), arrowprops=dict(facecolor='black', arrowstyle='->'), fontsize=10, fontweight='bold', color='black', family='Arial') # Cool grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) ax.xaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2.5) # Set a sleek background and axis styling ax.set_facecolor('#f5f5f5') plt.axis('equal') plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R = 6.371e6 # radius of Earth in meters altitude = 800e3 # 800 km above the surface initial_distance = R + altitude time_step = 1 # seconds total_time = 7000 # simulate up to 7000 seconds n_steps = int(total_time / time_step) # Initial velocities in m/s velocities = np.arange(5000, 13500, 500) # from 5 km/s to 13 km/s # Plot setup with high-visibility and cool styling plt.figure(figsize=(10, 10), facecolor='white') ax = plt.gca() # Create Earth plot with enhanced styling theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) earth_y = R * np.sin(theta) plt.fill(earth_x, earth_y, color='#0066cc', alpha=0.6, edgecolor='black', linewidth=2, label='Earth') # Function to compute gravity acceleration def gravity(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # Simulate each trajectory with distinct colors colors = ['#cc3300', '#009966', '#ff6600', '#660099', '#ff3399', '#006666', '#cc9900', '#990000', '#00cc99', '#ff9933', '#3333cc', '#ff0066', '#669900', '#9900cc', '#00ff66', '#cc0066'] for i, v in enumerate(velocities): pos = np.array([initial_distance, 0.0]) vel = np.array([0.0, v]) traj = [] for _ in range(n_steps): acc = gravity(pos) vel += acc * time_step pos += vel * time_step traj.append(pos.copy()) if np.linalg.norm(pos) <= R: break traj = np.array(traj) plt.plot(traj[:, 0], traj[:, 1], color=colors[i % len(colors)], linewidth=2.5, label=f'{v/1000:.1f} km/s', alpha=0.9) # Plot center of Earth plt.scatter([0], [0], color='black', s=100, edgecolor='black', linewidth=2, marker='o', label='Center of Earth', zorder=5) # Add annotation for starting point plt.annotate('Start', xy=(initial_distance, 0), xytext=(initial_distance + 1e6, 0.5e6), arrowprops=dict(facecolor='black', arrowstyle='->'), fontsize=10, fontweight='bold', color='black', family='Arial') # Enhanced text elements with bold, modern fonts ax.set_xlabel('X Position (m)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_ylabel('Y Position (m)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_title('Trajectories of Objects from 800 km Altitude with Varying Speeds', fontsize=18, fontweight='bold', pad=20, color='black', family='Arial') # High-visibility legend with a sleek look legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=10, borderpad=1, loc='upper right') for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') text.set_fontfamily('Arial') # Cool grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) ax.xaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2.5) # Set a sleek background and axis styling ax.set_facecolor('#f5f5f5') plt.axis('equal') plt.tight_layout() plt.savefig('multi_trajectory_plot.png')","title":"\ud83e\uddea 3. Python Code Snippet"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}