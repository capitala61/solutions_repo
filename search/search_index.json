{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection Physics | Gravity | KW1 Assignment Author: capitala61 Date: March 30, 2025 Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation 1.1 Governing Equations of Motion To analyze projectile motion, we start by applying the fundamental laws of motion under constant acceleration, particularly the law of gravity. The two-dimensional motion of a projectile is governed by the following equations: Horizontal Motion The acceleration in the horizontal direction is zero (assuming no air resistance), so the horizontal velocity remains constant. \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] where: \\(x(t)\\) is the horizontal position of the projectile at time \\(t\\) , \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle. Vertical Motion The vertical motion is influenced by gravity. The velocity in the vertical direction is affected by gravitational acceleration ( \\(g\\) ). \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] where: \\(y(t)\\) is the vertical position of the projectile at time \\(t\\) , \\(g\\) is the acceleration due to gravity (approximately 9.81 m/s\u00b2). 1.2 Solving the Basic Differential Equation To find the time of flight, we focus on the vertical motion. The projectile hits the ground when \\(y(t) = 0\\) . Therefore, we set the vertical displacement equation equal to zero: \\[ v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 = 0 \\] Factorizing the equation: \\[ t \\left( v_0 \\cdot \\sin(\\theta) - \\frac{1}{2} g t \\right) = 0 \\] The solutions to this equation are: \\(t = 0\\) (at the moment of launch), \\(t = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g}\\) (the time at which the projectile hits the ground). Thus, the total time of flight \\(T\\) is: \\[ T = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] 1.3 Horizontal Range of the Projectile Now that we have the time of flight, we can use the horizontal motion equation to find the range of the projectile. The horizontal distance traveled is given by: \\[ R = x(T) = v_0 \\cdot \\cos(\\theta) \\cdot T \\] Substitute \\(T\\) from the earlier equation: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] Simplify the expression: \\[ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Thus, the range of the projectile as a function of the launch angle is: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] 1.4 Family of Solutions The general form of the range equation shows that the range depends on several parameters: Initial velocity \\(v_0\\) : The range increases with the square of the initial velocity. Launch angle \\(\\theta\\) : The range is maximized when \\(\\theta = 45^\\circ\\) , as \\(\\sin(2\\theta)\\) reaches its maximum value of 1 at this angle. Gravitational acceleration \\(g\\) : The range decreases with an increase in gravitational acceleration. Thus, the relationship between the angle and the range can be explored by varying these parameters. Key Points The projectile follows a parabolic trajectory. The launch angle \\(\\theta\\) has a significant impact on the horizontal range. For a given initial velocity, the optimal launch angle for maximum range is \\(\\theta = 45^\\circ\\) . Analysis of the Range 1. Investigating the Horizontal Range as a Function of the Angle of Projection 1.1 Range Equation Recap The horizontal range \\(R\\) of a projectile is given by the equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Where: \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle, \\(g\\) is the gravitational acceleration. 1.2 Range as a Function of Angle To investigate how the range depends on the angle of projection, we need to analyze the behavior of the function \\(R(\\theta)\\) for various values of \\(\\theta\\) . The range increases with the sine of \\(2\\theta\\) . This means that the range is maximized when \\(2\\theta = 90^\\circ\\) , which occurs at \\(\\theta = 45^\\circ\\) . At \\(\\theta = 0^\\circ\\) and \\(\\theta = 90^\\circ\\) , the range is zero because \\(\\sin(0^\\circ) = \\sin(180^\\circ) = 0\\) . The general behavior of the range as a function of angle is symmetric, meaning that the range for an angle \\(\\theta\\) is the same as for the angle \\(90^\\circ - \\theta\\) . 1.3 Graphical Representation We can plot \\(R(\\theta)\\) for a given initial velocity \\(v_0\\) and gravitational acceleration \\(g\\) to visualize how the range changes with the launch angle. 2. Analyzing the Influence of Initial Velocity and Gravitational Acceleration 2.1 Effect of Initial Velocity \\(v_0\\) From the range equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] The range increases with the square of the initial velocity \\(v_0\\) . This means that for a higher initial velocity, the projectile will travel further for the same angle. The influence of \\(v_0\\) is more significant than the angle, meaning that for the same angle, doubling the initial velocity will quadruple the range. 2.2 Effect of Gravitational Acceleration \\(g\\) Again, from the range equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] The range decreases as the gravitational acceleration \\(g\\) increases. This means that in stronger gravitational fields (e.g., on planets with higher gravity), the range will be shorter for the same initial velocity and launch angle. The effect of \\(g\\) is inversely proportional, meaning that for a given initial velocity, increasing the gravitational acceleration reduces the range. 3. Summary of Effects on Range 3.1 Dependence on Launch Angle Range increases as the launch angle increases from \\(0^\\circ\\) to \\(45^\\circ\\) . The maximum range occurs at \\(\\theta = 45^\\circ\\) . The relationship is symmetric around \\(45^\\circ\\) . 3.2 Dependence on Initial Velocity The range increases quadratically with the initial velocity \\(v_0\\) . Doubling the initial velocity results in a fourfold increase in range. 3.3 Dependence on Gravitational Acceleration The range decreases as the gravitational acceleration \\(g\\) increases. The effect is inversely proportional to \\(g\\) . 4. Python Code for Visualizing the Range import numpy as np import matplotlib.pyplot as plt # Constants v0 = 50 g = 9.81 angles_deg = [15, 45, 75] angles_rad = np.radians(angles_deg) # Plot setup plt.figure(figsize=(10, 6)) colors = ['b', 'g', 'r'] # Plot trajectory for each angle for angle_rad, angle_deg, color in zip(angles_rad, angles_deg, colors): t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 1000) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 plt.plot(x, y, color=color, label=f'Angle = {angle_deg}\u00b0') # Plot customization plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion Trajectories') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.axvline(0, color='black', linewidth=0.5) # Save the plot plt.savefig('projectile_motion.png') Practical Applications of Projectile Motion 1. Reflection on Real-World Situations While the basic projectile motion model provides valuable insights into how an object moves through the air, real-world situations often introduce additional complexities that the idealized model does not account for. Below, we explore some real-world scenarios and the adjustments needed for a more accurate description. 1.1 Uneven Terrain Effect of Uneven Terrain : In the ideal model, the projectile is launched from and lands on flat ground. However, in real-world scenarios, the launch or landing height might vary due to uneven terrain. If the launch and landing points are at different heights, the range equation must be modified to account for the difference in elevation. The new range equation with an initial height \\(h_0\\) becomes: \\[R(\\theta) = \\frac{v_0 \\cos(\\theta)}{g} \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2gh_0} \\right)\\] Where: \\(h_0\\) is the initial height from which the projectile is launched. Effect of Sloped Terrain : When the terrain is sloped, the trajectory and landing location change based on the angle of the slope. The equation for the range becomes more complex and involves solving for the intersection of the projectile's path with the slope of the ground. 1.2 Air Resistance Impact of Air Resistance : Air resistance (drag) significantly alters the trajectory of a projectile. The ideal model assumes no air resistance, but in real life, air resistance slows down the projectile as it travels. The general form of the motion with drag can be described by the following second-order differential equations: \\( \\(\\frac{d^2x}{dt^2}=-\\frac{C_d\\rho A}{2m}v\\frac{dx}{dt}\\) \\) \\( \\(\\frac{d^2y}{dt^2}=-g-\\frac{C_d\\rho A}{2m}v\\frac{dy}{dt}\\) \\) Where: - \\(C_d\\) is the drag coefficient, - \\(\\rho\\) is the air density, - \\(A\\) is the cross-sectional area of the projectile, - \\(m\\) is the mass of the projectile, - \\(v\\) is the velocity of the projectile. Numerical Methods : Solving these differential equations requires numerical methods such as Euler's method, Runge-Kutta, or other integration techniques. These methods can provide an accurate simulation of the trajectory that accounts for the effects of drag. 1.3 Wind and Environmental Factors Wind Effects : Wind can alter the trajectory of a projectile, either increasing or decreasing its range depending on the wind direction. The wind\u2019s influence on the trajectory can be modeled by adding a velocity term to the equations that represent the wind speed and direction. If the wind velocity is represented by \\(v_w\\) , the horizontal velocity of the projectile becomes: \\( \\(v_x' = v_x + v_w\\) \\) Where: - \\(v_x\\) is the horizontal velocity of the projectile, - \\(v_w\\) is the wind velocity. Temperature and Air Density : The air density \\(\\rho\\) depends on environmental factors such as temperature and pressure. In warmer conditions, the air density decreases, which reduces air resistance and can increase the range of the projectile. 1.4 Real-World Examples Sports : In sports like basketball or soccer, air resistance and launch height are crucial. A basketball shot will differ depending on the angle and initial velocity, but also on the height of the player and the presence of wind. Military and Engineering Applications : In military applications, such as missile trajectories, engineers must account for air resistance, wind, and terrain elevation. High-precision models that include drag and varying gravitational fields are used for accurate targeting. Space Exploration : For objects launched into space, air resistance is negligible at high altitudes, but gravitational variation (due to Earth's curvature) and velocity are still factors that affect trajectory calculations. Implementation of Projectile Motion Simulation 1. Developing a Computational Tool To simulate projectile motion and visualize the range as a function of the angle of projection, we need to use a computational approach that considers the basic equations of motion. The key to building this simulation involves solving the projectile's motion under the influence of gravity and accounting for various parameters such as initial velocity , launch angle , and gravitational acceleration . 1.1 Governing Equations The equations of motion for projectile motion without air resistance are: Horizontal motion: \\( \\(x(t) = v_0 \\cos(\\theta) t\\) \\) Vertical motion: \\( \\(y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\) \\) Where: \\(v_0\\) is the initial velocity of the projectile, \\(\\theta\\) is the launch angle, \\(g\\) is the gravitational acceleration, \\(x(t)\\) and \\(y(t)\\) are the horizontal and vertical displacements, respectively. The range \\(R\\) of the projectile (the distance it travels before hitting the ground) can be obtained when the projectile reaches \\(y=0\\) . This condition gives the time of flight as: \\[t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\] Substituting this into the equation for horizontal motion, we get the range \\(R\\) : \\[R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\] 1.2 Algorithm Design Input Parameters : Initial velocity \\(v_0\\) Launch angle \\(\\theta\\) Gravitational acceleration \\(g\\) Steps : Define the initial conditions (velocity, angle). Use the equations of motion to calculate the horizontal and vertical displacements at each time step. Compute the time of flight and the range \\(R\\) . Visualize the range \\(R\\) for different launch angles by plotting it as a function of the angle of projection. 2. Visualizing the Range as a Function of the Launch Angle To explore how the range changes with different angles of projection, we will create a plot of the range \\(R\\) for a range of angles, keeping the initial velocity and gravitational acceleration constant. Range Equation : \\( \\(R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) \\) This equation will be used to calculate the range for various values of \\(\\theta\\) (from 0\u00b0 to 90\u00b0). 2.1 Python Code Implementation Below is the Python code that simulates the projectile motion and visualizes the range as a function of the launch angle for a given initial velocity ```python import numpy as np import matplotlib.pyplot as plt # Constants v_0 = 20 # Initial velocity in m/s g = 9.81 # Gravitational acceleration in m/s^2 # Function to calculate the range for different launch angles def calculate_range(v_0, g, theta): # Convert angle to radians theta_rad = np.radians(theta) # Range equation R = (v_0**2 * np.sin(2*theta_rad)) / g return R # Launch angles from 0 to 90 degrees angles = np.linspace(0, 90, 100) # Calculate the range for each angle ranges = [calculate_range(v_0, g, angle) for angle in angles] # Plotting the range as a function of the launch angle plt.plot(angles, ranges) plt.title('Projectile Range vs Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#date-march-30-2025","text":"","title":"Date: March 30, 2025"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-governing-equations-of-motion","text":"To analyze projectile motion, we start by applying the fundamental laws of motion under constant acceleration, particularly the law of gravity. The two-dimensional motion of a projectile is governed by the following equations:","title":"1.1 Governing Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"The acceleration in the horizontal direction is zero (assuming no air resistance), so the horizontal velocity remains constant. \\[ x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t \\] where: \\(x(t)\\) is the horizontal position of the projectile at time \\(t\\) , \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle.","title":"Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"The vertical motion is influenced by gravity. The velocity in the vertical direction is affected by gravitational acceleration ( \\(g\\) ). \\[ y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] where: \\(y(t)\\) is the vertical position of the projectile at time \\(t\\) , \\(g\\) is the acceleration due to gravity (approximately 9.81 m/s\u00b2).","title":"Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-solving-the-basic-differential-equation","text":"To find the time of flight, we focus on the vertical motion. The projectile hits the ground when \\(y(t) = 0\\) . Therefore, we set the vertical displacement equation equal to zero: \\[ v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 = 0 \\] Factorizing the equation: \\[ t \\left( v_0 \\cdot \\sin(\\theta) - \\frac{1}{2} g t \\right) = 0 \\] The solutions to this equation are: \\(t = 0\\) (at the moment of launch), \\(t = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g}\\) (the time at which the projectile hits the ground). Thus, the total time of flight \\(T\\) is: \\[ T = \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\]","title":"1.2 Solving the Basic Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-horizontal-range-of-the-projectile","text":"Now that we have the time of flight, we can use the horizontal motion equation to find the range of the projectile. The horizontal distance traveled is given by: \\[ R = x(T) = v_0 \\cdot \\cos(\\theta) \\cdot T \\] Substitute \\(T\\) from the earlier equation: \\[ R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2 v_0 \\cdot \\sin(\\theta)}{g} \\] Simplify the expression: \\[ R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Thus, the range of the projectile as a function of the launch angle is: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\]","title":"1.3 Horizontal Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-family-of-solutions","text":"The general form of the range equation shows that the range depends on several parameters: Initial velocity \\(v_0\\) : The range increases with the square of the initial velocity. Launch angle \\(\\theta\\) : The range is maximized when \\(\\theta = 45^\\circ\\) , as \\(\\sin(2\\theta)\\) reaches its maximum value of 1 at this angle. Gravitational acceleration \\(g\\) : The range decreases with an increase in gravitational acceleration. Thus, the relationship between the angle and the range can be explored by varying these parameters.","title":"1.4 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-points","text":"The projectile follows a parabolic trajectory. The launch angle \\(\\theta\\) has a significant impact on the horizontal range. For a given initial velocity, the optimal launch angle for maximum range is \\(\\theta = 45^\\circ\\) .","title":"Key Points"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#analysis-of-the-range","text":"","title":"Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-investigating-the-horizontal-range-as-a-function-of-the-angle-of-projection","text":"","title":"1. Investigating the Horizontal Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-range-equation-recap","text":"The horizontal range \\(R\\) of a projectile is given by the equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] Where: \\(v_0\\) is the initial velocity, \\(\\theta\\) is the launch angle, \\(g\\) is the gravitational acceleration.","title":"1.1 Range Equation Recap"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-range-as-a-function-of-angle","text":"To investigate how the range depends on the angle of projection, we need to analyze the behavior of the function \\(R(\\theta)\\) for various values of \\(\\theta\\) . The range increases with the sine of \\(2\\theta\\) . This means that the range is maximized when \\(2\\theta = 90^\\circ\\) , which occurs at \\(\\theta = 45^\\circ\\) . At \\(\\theta = 0^\\circ\\) and \\(\\theta = 90^\\circ\\) , the range is zero because \\(\\sin(0^\\circ) = \\sin(180^\\circ) = 0\\) . The general behavior of the range as a function of angle is symmetric, meaning that the range for an angle \\(\\theta\\) is the same as for the angle \\(90^\\circ - \\theta\\) .","title":"1.2 Range as a Function of Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-graphical-representation","text":"We can plot \\(R(\\theta)\\) for a given initial velocity \\(v_0\\) and gravitational acceleration \\(g\\) to visualize how the range changes with the launch angle.","title":"1.3 Graphical Representation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analyzing-the-influence-of-initial-velocity-and-gravitational-acceleration","text":"","title":"2. Analyzing the Influence of Initial Velocity and Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-effect-of-initial-velocity-v_0","text":"From the range equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] The range increases with the square of the initial velocity \\(v_0\\) . This means that for a higher initial velocity, the projectile will travel further for the same angle. The influence of \\(v_0\\) is more significant than the angle, meaning that for the same angle, doubling the initial velocity will quadruple the range.","title":"2.1 Effect of Initial Velocity \\(v_0\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-effect-of-gravitational-acceleration-g","text":"Again, from the range equation: \\[ R(\\theta) = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g} \\] The range decreases as the gravitational acceleration \\(g\\) increases. This means that in stronger gravitational fields (e.g., on planets with higher gravity), the range will be shorter for the same initial velocity and launch angle. The effect of \\(g\\) is inversely proportional, meaning that for a given initial velocity, increasing the gravitational acceleration reduces the range.","title":"2.2 Effect of Gravitational Acceleration \\(g\\)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-summary-of-effects-on-range","text":"","title":"3. Summary of Effects on Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-dependence-on-launch-angle","text":"Range increases as the launch angle increases from \\(0^\\circ\\) to \\(45^\\circ\\) . The maximum range occurs at \\(\\theta = 45^\\circ\\) . The relationship is symmetric around \\(45^\\circ\\) .","title":"3.1 Dependence on Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-dependence-on-initial-velocity","text":"The range increases quadratically with the initial velocity \\(v_0\\) . Doubling the initial velocity results in a fourfold increase in range.","title":"3.2 Dependence on Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-dependence-on-gravitational-acceleration","text":"The range decreases as the gravitational acceleration \\(g\\) increases. The effect is inversely proportional to \\(g\\) .","title":"3.3 Dependence on Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-code-for-visualizing-the-range","text":"import numpy as np import matplotlib.pyplot as plt # Constants v0 = 50 g = 9.81 angles_deg = [15, 45, 75] angles_rad = np.radians(angles_deg) # Plot setup plt.figure(figsize=(10, 6)) colors = ['b', 'g', 'r'] # Plot trajectory for each angle for angle_rad, angle_deg, color in zip(angles_rad, angles_deg, colors): t_flight = 2 * v0 * np.sin(angle_rad) / g t = np.linspace(0, t_flight, 1000) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 plt.plot(x, y, color=color, label=f'Angle = {angle_deg}\u00b0') # Plot customization plt.xlabel('Horizontal Distance (m)') plt.ylabel('Height (m)') plt.title('Projectile Motion Trajectories') plt.grid(True) plt.legend() plt.axhline(0, color='black', linewidth=0.5) plt.axvline(0, color='black', linewidth=0.5) # Save the plot plt.savefig('projectile_motion.png')","title":"4. Python Code for Visualizing the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#practical-applications-of-projectile-motion","text":"","title":"Practical Applications of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-reflection-on-real-world-situations","text":"While the basic projectile motion model provides valuable insights into how an object moves through the air, real-world situations often introduce additional complexities that the idealized model does not account for. Below, we explore some real-world scenarios and the adjustments needed for a more accurate description.","title":"1. Reflection on Real-World Situations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-uneven-terrain","text":"Effect of Uneven Terrain : In the ideal model, the projectile is launched from and lands on flat ground. However, in real-world scenarios, the launch or landing height might vary due to uneven terrain. If the launch and landing points are at different heights, the range equation must be modified to account for the difference in elevation. The new range equation with an initial height \\(h_0\\) becomes: \\[R(\\theta) = \\frac{v_0 \\cos(\\theta)}{g} \\left( v_0 \\sin(\\theta) + \\sqrt{(v_0 \\sin(\\theta))^2 + 2gh_0} \\right)\\] Where: \\(h_0\\) is the initial height from which the projectile is launched. Effect of Sloped Terrain : When the terrain is sloped, the trajectory and landing location change based on the angle of the slope. The equation for the range becomes more complex and involves solving for the intersection of the projectile's path with the slope of the ground.","title":"1.1 Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-air-resistance","text":"Impact of Air Resistance : Air resistance (drag) significantly alters the trajectory of a projectile. The ideal model assumes no air resistance, but in real life, air resistance slows down the projectile as it travels. The general form of the motion with drag can be described by the following second-order differential equations: \\( \\(\\frac{d^2x}{dt^2}=-\\frac{C_d\\rho A}{2m}v\\frac{dx}{dt}\\) \\) \\( \\(\\frac{d^2y}{dt^2}=-g-\\frac{C_d\\rho A}{2m}v\\frac{dy}{dt}\\) \\) Where: - \\(C_d\\) is the drag coefficient, - \\(\\rho\\) is the air density, - \\(A\\) is the cross-sectional area of the projectile, - \\(m\\) is the mass of the projectile, - \\(v\\) is the velocity of the projectile. Numerical Methods : Solving these differential equations requires numerical methods such as Euler's method, Runge-Kutta, or other integration techniques. These methods can provide an accurate simulation of the trajectory that accounts for the effects of drag.","title":"1.2 Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-wind-and-environmental-factors","text":"Wind Effects : Wind can alter the trajectory of a projectile, either increasing or decreasing its range depending on the wind direction. The wind\u2019s influence on the trajectory can be modeled by adding a velocity term to the equations that represent the wind speed and direction. If the wind velocity is represented by \\(v_w\\) , the horizontal velocity of the projectile becomes: \\( \\(v_x' = v_x + v_w\\) \\) Where: - \\(v_x\\) is the horizontal velocity of the projectile, - \\(v_w\\) is the wind velocity. Temperature and Air Density : The air density \\(\\rho\\) depends on environmental factors such as temperature and pressure. In warmer conditions, the air density decreases, which reduces air resistance and can increase the range of the projectile.","title":"1.3 Wind and Environmental Factors"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-real-world-examples","text":"Sports : In sports like basketball or soccer, air resistance and launch height are crucial. A basketball shot will differ depending on the angle and initial velocity, but also on the height of the player and the presence of wind. Military and Engineering Applications : In military applications, such as missile trajectories, engineers must account for air resistance, wind, and terrain elevation. High-precision models that include drag and varying gravitational fields are used for accurate targeting. Space Exploration : For objects launched into space, air resistance is negligible at high altitudes, but gravitational variation (due to Earth's curvature) and velocity are still factors that affect trajectory calculations.","title":"1.4 Real-World Examples"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#implementation-of-projectile-motion-simulation","text":"","title":"Implementation of Projectile Motion Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-developing-a-computational-tool","text":"To simulate projectile motion and visualize the range as a function of the angle of projection, we need to use a computational approach that considers the basic equations of motion. The key to building this simulation involves solving the projectile's motion under the influence of gravity and accounting for various parameters such as initial velocity , launch angle , and gravitational acceleration .","title":"1. Developing a Computational Tool"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-governing-equations","text":"The equations of motion for projectile motion without air resistance are: Horizontal motion: \\( \\(x(t) = v_0 \\cos(\\theta) t\\) \\) Vertical motion: \\( \\(y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\) \\) Where: \\(v_0\\) is the initial velocity of the projectile, \\(\\theta\\) is the launch angle, \\(g\\) is the gravitational acceleration, \\(x(t)\\) and \\(y(t)\\) are the horizontal and vertical displacements, respectively. The range \\(R\\) of the projectile (the distance it travels before hitting the ground) can be obtained when the projectile reaches \\(y=0\\) . This condition gives the time of flight as: \\[t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\] Substituting this into the equation for horizontal motion, we get the range \\(R\\) : \\[R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\]","title":"1.1 Governing Equations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-algorithm-design","text":"Input Parameters : Initial velocity \\(v_0\\) Launch angle \\(\\theta\\) Gravitational acceleration \\(g\\) Steps : Define the initial conditions (velocity, angle). Use the equations of motion to calculate the horizontal and vertical displacements at each time step. Compute the time of flight and the range \\(R\\) . Visualize the range \\(R\\) for different launch angles by plotting it as a function of the angle of projection.","title":"1.2 Algorithm Design"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-visualizing-the-range-as-a-function-of-the-launch-angle","text":"To explore how the range changes with different angles of projection, we will create a plot of the range \\(R\\) for a range of angles, keeping the initial velocity and gravitational acceleration constant. Range Equation : \\( \\(R(\\theta) = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) \\) This equation will be used to calculate the range for various values of \\(\\theta\\) (from 0\u00b0 to 90\u00b0).","title":"2. Visualizing the Range as a Function of the Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-python-code-implementation","text":"","title":"2.1 Python Code Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#below-is-the-python-code-that-simulates-the-projectile-motion-and-visualizes-the-range-as-a-function-of-the-launch-angle-for-a-given-initial-velocity","text":"```python import numpy as np import matplotlib.pyplot as plt # Constants v_0 = 20 # Initial velocity in m/s g = 9.81 # Gravitational acceleration in m/s^2 # Function to calculate the range for different launch angles def calculate_range(v_0, g, theta): # Convert angle to radians theta_rad = np.radians(theta) # Range equation R = (v_0**2 * np.sin(2*theta_rad)) / g return R # Launch angles from 0 to 90 degrees angles = np.linspace(0, 90, 100) # Calculate the range for each angle ranges = [calculate_range(v_0, g, angle) for angle in angles] # Plotting the range as a function of the launch angle plt.plot(angles, ranges) plt.title('Projectile Range vs Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.show()","title":"Below is the Python code that simulates the projectile motion and visualizes the range as a function of the launch angle for a given initial velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum: Dynamics and Analysis 1. Theoretical Framework The forced damped pendulum is modeled by a second-order nonlinear ordinary differential equation (ODE) describing angular displacement under damping and periodic external forcing. 1.1 Governing Equation The equation of motion is: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=A\\cos(\\omega t)\\] Variables : \\(\\theta(t)\\) : Angular displacement (radians) \\(b\\) : Damping coefficient (s \\(^{-1}\\) ) \\(g\\) : Gravitational acceleration (m/s \\(^2\\) ) \\(L\\) : Pendulum length (m) \\(A\\) : Driving amplitude (s \\(^{-2}\\) ) \\(\\omega\\) : Driving frequency (rad/s) 1.2 Small-Angle Approximation For small angles ( \\(\\theta\\ll 1\\) ), the nonlinear term simplifies: \\[\\sin\\theta\\approx\\theta\\] This yields a linear ODE: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\theta=A\\cos(\\omega t)\\] 1.3 Solution to Linearized Equation The solution combines homogeneous and particular components: Homogeneous Solution : The characteristic equation is: \\( \\(r^2+br+(g/L)=0\\) \\) Roots are: \\( \\(r_{1,2}=(-b\\pm\\sqrt{b^2-4(g/L)})/2\\) \\) The homogeneous solution is: \\[\\theta_h(t)=C_1e^{r_1t}+C_2e^{r_2t}\\] For underdamped systems ( \\(b^2<4(g/L)\\) ): \\[\\theta_h(t)=e^{-(b/2)t}(C_1\\cos(\\omega_dt)+C_2\\sin(\\omega_dt))\\] Where damped frequency is: \\[\\omega_d=\\sqrt{(g/L)-(b^2/4)}\\] Particular Solution : Assume a steady-state form: \\[\\theta_p(t)=B\\cos(\\omega t-\\delta)\\] The amplitude \\(B\\) is: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\] The phase shift \\(\\delta\\) is: \\[\\tan\\delta=(b\\omega)/((g/L)-\\omega^2)\\] 1.3.1 Pendulum Motion Visualization The time evolution of \\(\\theta(t)\\) illustrates the combined effects of damping and external forcing, as described by the nonlinear ODE: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=A\\cos(\\omega t)\\] The following Python code solves this ODE numerically using parameters \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , \\(A=0.5\\) s \\(^{-2}\\) , and \\(\\omega=0.8\\sqrt{g/L}\\) , plotting \\(\\theta(t)\\) over time. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint Additional Visualization: Simple Pendulum Motion (Undamped, No Forcing) To further illustrate the basic pendulum dynamics without damping ( \\(b=0\\) ) and without external forcing ( \\(A=0\\) ), we plot \\(\\theta(t)\\) over time for small initial displacement. This captures the pure periodic motion expected from an ideal pendulum. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Simple pendulum parameters b = 0.0 # damping A = 0.0 # forcing omega_f = 0.0 g = 9.81 L = 1.0 def simple_pendulum(t, y): theta, omega = y dydt = [omega, -(g/L)*np.sin(theta)] return dydt # Time points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [0.2, 0.0] # initial conditions: [angle, angular velocity] # Solve sol = solve_ivp(simple_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'r') axs[0].set_title('Simple Pendulum - Time Series') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'r') axs[1].set_title('Simple Pendulum - Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show() 1.4 Resonance Resonance occurs when \\(\\omega\\) approaches the natural frequency: \\[\\omega_0=\\sqrt{g/L}\\] Undamped Case ( \\(b=0\\) ): \\[B\\to\\infty\\text{ as }\\omega\\to\\omega_0\\] Damped Case : Maximum amplitude occurs at: \\[\\omega_{\\text{res}}=\\sqrt{\\omega_0^2-(b^2/2)}\\] With maximum amplitude: \\[B_{\\text{max}}=A/(b\\sqrt{\\omega_0^2-(b^2/4)})\\] 1.4.1 Resonance Curve Visualization The resonance curve plots the steady-state amplitude \\(B\\) against driving frequency \\(\\omega\\) , as given by: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\] The following Python code computes \\(B\\) for \\(\\omega\\) from 0.1 to 5 rad/s, with \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , and \\(A=0.5\\) s \\(^{-2}\\) . Additional Visualization: Resonance Behavior in the Undamped Pendulum Below we show the amplitude response \\(B\\) versus driving frequency \\(\\omega\\) for an undamped pendulum ( \\(b=0\\) ). As expected, the amplitude diverges sharply near the natural frequency \\(\\omega_0=\\sqrt{g/L}\\) , showing the classical resonance peak. import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 b = 0.2 A = 0.5 # Frequency range omega = np.linspace(0.1, 5, 500) # Amplitude B B = A / np.sqrt(((g/L) - omega**2)**2 + (b*omega)**2) # Plot plt.figure(figsize=(8, 5)) plt.plot(omega, B, label=r'Amplitude $B$') plt.xlabel(r'Driving Frequency $\\omega$ (rad/s)') plt.ylabel(r'Amplitude $B$ (rad)') plt.title('Resonance Curve of Forced Damped Pendulum') plt.grid(True) plt.legend() plt.show() 1.5 Energy Dynamics Total mechanical energy is: \\[E(t)=(1/2)mL^2(d\\theta/dt)^2+mgL(1-\\cos\\theta)\\] At resonance: Undamped: Energy grows without bound. Damped: Energy balances input and dissipation, yielding: \\[E_{\\text{steady}}\\approx(1/2)mL^2B^2\\omega^2\\] Energy Evolution Over Time The plot below shows the total mechanical energy \\(E(t)\\) of the pendulum over time for both damped and undamped cases. In the undamped case, energy remains constant (or grows under forcing); in the damped case, energy stabilizes after transient behavior. # Forced pendulum parameters b = 0.0 # no damping A = 1.2 # forcing amplitude omega_f = 2.0/3.0 # forcing frequency def forced_pendulum(t, y): theta, omega = y dydt = [omega, -(g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'c') axs[0].set_title('Forced Pendulum - Time Series') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'c') axs[1].set_title('Forced Pendulum - Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show() 1.6 Summary The nonlinear ODE governs pendulum motion. Small-angle approximation linearizes the system. Solutions include damped and forced components. Resonance amplifies oscillations, moderated by damping. 2. Parametric Effects This section analyzes how parameters affect dynamics, focusing on damping, driving amplitude, and frequency. 2.1 Damping Coefficient ( \\(b\\) ) Damping influences oscillation decay: Low \\(b\\) : Sustained oscillations. Solution approximates undamped case: \\[\\theta(t)\\approx B\\cos(\\omega t-\\delta)\\] High \\(b\\) : Rapid decay to equilibrium. Overdamped solution ( \\(b^2>4(g/L)\\) ): \\[\\theta(t)=C_1e^{r_1t}+C_2e^{r_2t}\\] 2.2 Driving Amplitude ( \\(A\\) ) The amplitude \\(A\\) scales the external force: Small \\(A\\) : Oscillations decay unless near resonance. Amplitude scales linearly: \\[B\\propto A\\] Large \\(A\\) : Increases steady-state amplitude: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\] 2.3 Driving Frequency ( \\(\\omega\\) ) Frequency determines forcing efficiency: Near \\(\\omega_0\\) : Large oscillations due to resonance. Amplitude peaks at \\(\\omega_{\\text{res}}\\) . Far from \\(\\omega_0\\) : Reduced amplitude: \\[B\\approx A/|(g/L)-\\omega^2|\\] 2.4 Chaos and Nonlinearity For large \\(A\\) or specific \\(\\omega\\) , the nonlinear \\(\\sin\\theta\\) term induces chaos: Periodic Motion : Stable at low \\(A\\) , described by: \\[\\theta(t)\\approx B\\cos(\\omega t-\\delta)\\] Chaotic Motion : Sensitive to initial conditions. Characterized by positive Lyapunov exponent: \\[\\lambda>0\\] 2.5 Visualization Tools Phase Portrait : Plots \\(\\theta\\) vs. \\(d\\theta/dt\\) . Periodic motion: Closed loops. Chaotic motion: Irregular patterns. The following Python code generates a phase portrait for the pendulum with \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , \\(A=0.5\\) s \\(^{-2}\\) , and \\(\\omega=0.8\\sqrt{g/L}\\) , showing a closed loop indicative of periodic motion. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 L = 1.0 b = 0.2 A = 0.5 omega = 0.8 * np.sqrt(g/L) # ODE system def pendulum(state, t, b, g, L, A, omega): theta, omega = state dtheta_dt = omega domega_dt = -b*omega - (g/L)*np.sin(theta) + A*np.cos(omega*t) return [dtheta_dt, domega_dt] # Time array t = np.linspace(0, 20, 1000) # Initial conditions state0 = [0.1, 0.0] # Solve ODE solution = odeint(pendulum, state0, t, args=(b, g, L, A, omega)) theta = solution[:, 0] dtheta_dt = solution[:, 1] # Plot plt.figure(figsize=(8, 5)) plt.plot(theta, dtheta_dt, label=r\"$\\text{Phase Trajectory}$\") plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\frac{d\\theta}{dt}$ (rad/s)\") plt.title(r\"$\\text{Phase Portrait of Forced Damped Pendulum}$\") plt.grid(True) plt.legend() plt.show() # Poincar\u00e9 Section Description: # Samples at $t=2\\pi n/\\omega$. # Periodic: Discrete points. # Chaotic: Scattered points. 2.6 Summary Damping controls oscillation decay. Amplitude scales forcing strength. Frequency drives resonance or chaos. Nonlinear effects lead to complex dynamics. 3. Applications The model applies to systems with oscillatory dynamics. 3.1 Energy Harvesting Vibrational harvesters convert motion to energy: Model : Driving force: Ambient vibrations. Power output: \\[P=(1/2)mL^2(d\\theta/dt)^2\\] Optimization : Maximize at resonance: \\[\\omega=\\omega_0\\] 3.2 Structural Engineering Bridges oscillate under external loads: Equation : Similar to pendulum: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=F_{\\text{ext}}(t)\\] Design : Increase \\(b\\) to avoid resonance. 3.3 Electrical Circuits RLC circuits mirror pendulum dynamics: Equation : Charge dynamics: \\[Ld^2q/dt^2+R\\,dq/dt+(1/C)q=V_{\\text{ext}}(t)\\] Resonance : Maximizes current at: \\[\\omega=1/\\sqrt{LC}\\] 3.4 Summary Energy harvesting optimizes power at resonance. Structures require damping to prevent failure. Circuits control resonance for stability. Additional Visualization: Phase Portraits Under Different Conditions The following phase diagram shows the behavior of the pendulum for different scenarios: - (i) No damping and no external force (pure closed loops), - (ii) With damping (spiraling into equilibrium), - (iii) With external driving (limit cycles or chaotic behavior). # Forced damped pendulum parameters (resonance-like) b = 0.05 # light damping A = 1.2 # forcing amplitude omega_f = 2.0/3.0 # forcing frequency def forced_damped_pendulum(t, y): theta, omega = y dydt = [omega, -(b)*omega - (g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'm') axs[0].set_title('Forced Damped Pendulum - Time Series (Resonance-like)') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'm') axs[1].set_title('Forced Damped Pendulum - Phase Portrait (Resonance-like)') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show() Poincar\u00e9 Section: Visualization of Periodicity and Chaos Below we plot the Poincar\u00e9 section, sampling the pendulum's phase space at regular intervals ( \\(t=2\\pi n/\\omega\\) ): - For periodic motion: discrete isolated points appear. - For chaotic motion: scattered clouds of points emerge. # Forced damped pendulum parameters (chaotic) b = 0.2 # stronger damping A = 1.5 # larger forcing omega_f = 2.0/3.0 # forcing frequency def chaotic_forced_damped_pendulum(t, y): theta, omega = y dydt = [omega, -(b)*omega - (g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(chaotic_forced_damped_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'g') axs[0].set_title('Forced Damped Pendulum - Time Series (Chaotic)') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'g') axs[1].set_title('Forced Damped Pendulum - Phase Portrait (Chaotic)') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-dynamics-and-analysis","text":"","title":"Forced Damped Pendulum: Dynamics and Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-framework","text":"The forced damped pendulum is modeled by a second-order nonlinear ordinary differential equation (ODE) describing angular displacement under damping and periodic external forcing.","title":"1. Theoretical Framework"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#11-governing-equation","text":"The equation of motion is: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=A\\cos(\\omega t)\\] Variables : \\(\\theta(t)\\) : Angular displacement (radians) \\(b\\) : Damping coefficient (s \\(^{-1}\\) ) \\(g\\) : Gravitational acceleration (m/s \\(^2\\) ) \\(L\\) : Pendulum length (m) \\(A\\) : Driving amplitude (s \\(^{-2}\\) ) \\(\\omega\\) : Driving frequency (rad/s)","title":"1.1 Governing Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#12-small-angle-approximation","text":"For small angles ( \\(\\theta\\ll 1\\) ), the nonlinear term simplifies: \\[\\sin\\theta\\approx\\theta\\] This yields a linear ODE: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\theta=A\\cos(\\omega t)\\]","title":"1.2 Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#13-solution-to-linearized-equation","text":"The solution combines homogeneous and particular components: Homogeneous Solution : The characteristic equation is: \\( \\(r^2+br+(g/L)=0\\) \\) Roots are: \\( \\(r_{1,2}=(-b\\pm\\sqrt{b^2-4(g/L)})/2\\) \\) The homogeneous solution is: \\[\\theta_h(t)=C_1e^{r_1t}+C_2e^{r_2t}\\] For underdamped systems ( \\(b^2<4(g/L)\\) ): \\[\\theta_h(t)=e^{-(b/2)t}(C_1\\cos(\\omega_dt)+C_2\\sin(\\omega_dt))\\] Where damped frequency is: \\[\\omega_d=\\sqrt{(g/L)-(b^2/4)}\\] Particular Solution : Assume a steady-state form: \\[\\theta_p(t)=B\\cos(\\omega t-\\delta)\\] The amplitude \\(B\\) is: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\] The phase shift \\(\\delta\\) is: \\[\\tan\\delta=(b\\omega)/((g/L)-\\omega^2)\\]","title":"1.3 Solution to Linearized Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#131-pendulum-motion-visualization","text":"The time evolution of \\(\\theta(t)\\) illustrates the combined effects of damping and external forcing, as described by the nonlinear ODE: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=A\\cos(\\omega t)\\] The following Python code solves this ODE numerically using parameters \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , \\(A=0.5\\) s \\(^{-2}\\) , and \\(\\omega=0.8\\sqrt{g/L}\\) , plotting \\(\\theta(t)\\) over time. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint","title":"1.3.1 Pendulum Motion Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#additional-visualization-simple-pendulum-motion-undamped-no-forcing","text":"To further illustrate the basic pendulum dynamics without damping ( \\(b=0\\) ) and without external forcing ( \\(A=0\\) ), we plot \\(\\theta(t)\\) over time for small initial displacement. This captures the pure periodic motion expected from an ideal pendulum.","title":"Additional Visualization: Simple Pendulum Motion (Undamped, No Forcing)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Simple pendulum parameters b = 0.0 # damping A = 0.0 # forcing omega_f = 0.0 g = 9.81 L = 1.0 def simple_pendulum(t, y): theta, omega = y dydt = [omega, -(g/L)*np.sin(theta)] return dydt # Time points t_span = (0, 20) t_eval = np.linspace(*t_span, 1000) y0 = [0.2, 0.0] # initial conditions: [angle, angular velocity] # Solve sol = solve_ivp(simple_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'r') axs[0].set_title('Simple Pendulum - Time Series') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'r') axs[1].set_title('Simple Pendulum - Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#14-resonance","text":"Resonance occurs when \\(\\omega\\) approaches the natural frequency: \\[\\omega_0=\\sqrt{g/L}\\] Undamped Case ( \\(b=0\\) ): \\[B\\to\\infty\\text{ as }\\omega\\to\\omega_0\\] Damped Case : Maximum amplitude occurs at: \\[\\omega_{\\text{res}}=\\sqrt{\\omega_0^2-(b^2/2)}\\] With maximum amplitude: \\[B_{\\text{max}}=A/(b\\sqrt{\\omega_0^2-(b^2/4)})\\]","title":"1.4 Resonance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#141-resonance-curve-visualization","text":"The resonance curve plots the steady-state amplitude \\(B\\) against driving frequency \\(\\omega\\) , as given by: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\] The following Python code computes \\(B\\) for \\(\\omega\\) from 0.1 to 5 rad/s, with \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , and \\(A=0.5\\) s \\(^{-2}\\) .","title":"1.4.1 Resonance Curve Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#additional-visualization-resonance-behavior-in-the-undamped-pendulum","text":"Below we show the amplitude response \\(B\\) versus driving frequency \\(\\omega\\) for an undamped pendulum ( \\(b=0\\) ). As expected, the amplitude diverges sharply near the natural frequency \\(\\omega_0=\\sqrt{g/L}\\) , showing the classical resonance peak.","title":"Additional Visualization: Resonance Behavior in the Undamped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_2","text":"import numpy as np import matplotlib.pyplot as plt # Parameters g = 9.81 L = 1.0 b = 0.2 A = 0.5 # Frequency range omega = np.linspace(0.1, 5, 500) # Amplitude B B = A / np.sqrt(((g/L) - omega**2)**2 + (b*omega)**2) # Plot plt.figure(figsize=(8, 5)) plt.plot(omega, B, label=r'Amplitude $B$') plt.xlabel(r'Driving Frequency $\\omega$ (rad/s)') plt.ylabel(r'Amplitude $B$ (rad)') plt.title('Resonance Curve of Forced Damped Pendulum') plt.grid(True) plt.legend() plt.show()","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#15-energy-dynamics","text":"Total mechanical energy is: \\[E(t)=(1/2)mL^2(d\\theta/dt)^2+mgL(1-\\cos\\theta)\\] At resonance: Undamped: Energy grows without bound. Damped: Energy balances input and dissipation, yielding: \\[E_{\\text{steady}}\\approx(1/2)mL^2B^2\\omega^2\\]","title":"1.5 Energy Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#energy-evolution-over-time","text":"The plot below shows the total mechanical energy \\(E(t)\\) of the pendulum over time for both damped and undamped cases. In the undamped case, energy remains constant (or grows under forcing); in the damped case, energy stabilizes after transient behavior. # Forced pendulum parameters b = 0.0 # no damping A = 1.2 # forcing amplitude omega_f = 2.0/3.0 # forcing frequency def forced_pendulum(t, y): theta, omega = y dydt = [omega, -(g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(forced_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'c') axs[0].set_title('Forced Pendulum - Time Series') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'c') axs[1].set_title('Forced Pendulum - Phase Portrait') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":"Energy Evolution Over Time"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#16-summary","text":"The nonlinear ODE governs pendulum motion. Small-angle approximation linearizes the system. Solutions include damped and forced components. Resonance amplifies oscillations, moderated by damping.","title":"1.6 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-parametric-effects","text":"This section analyzes how parameters affect dynamics, focusing on damping, driving amplitude, and frequency.","title":"2. Parametric Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#21-damping-coefficient-b","text":"Damping influences oscillation decay: Low \\(b\\) : Sustained oscillations. Solution approximates undamped case: \\[\\theta(t)\\approx B\\cos(\\omega t-\\delta)\\] High \\(b\\) : Rapid decay to equilibrium. Overdamped solution ( \\(b^2>4(g/L)\\) ): \\[\\theta(t)=C_1e^{r_1t}+C_2e^{r_2t}\\]","title":"2.1 Damping Coefficient (\\(b\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#22-driving-amplitude-a","text":"The amplitude \\(A\\) scales the external force: Small \\(A\\) : Oscillations decay unless near resonance. Amplitude scales linearly: \\[B\\propto A\\] Large \\(A\\) : Increases steady-state amplitude: \\[B=A/\\sqrt{((g/L)-\\omega^2)^2+(b\\omega)^2}\\]","title":"2.2 Driving Amplitude (\\(A\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#23-driving-frequency-omega","text":"Frequency determines forcing efficiency: Near \\(\\omega_0\\) : Large oscillations due to resonance. Amplitude peaks at \\(\\omega_{\\text{res}}\\) . Far from \\(\\omega_0\\) : Reduced amplitude: \\[B\\approx A/|(g/L)-\\omega^2|\\]","title":"2.3 Driving Frequency (\\(\\omega\\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#24-chaos-and-nonlinearity","text":"For large \\(A\\) or specific \\(\\omega\\) , the nonlinear \\(\\sin\\theta\\) term induces chaos: Periodic Motion : Stable at low \\(A\\) , described by: \\[\\theta(t)\\approx B\\cos(\\omega t-\\delta)\\] Chaotic Motion : Sensitive to initial conditions. Characterized by positive Lyapunov exponent: \\[\\lambda>0\\]","title":"2.4 Chaos and Nonlinearity"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#25-visualization-tools","text":"Phase Portrait : Plots \\(\\theta\\) vs. \\(d\\theta/dt\\) . Periodic motion: Closed loops. Chaotic motion: Irregular patterns. The following Python code generates a phase portrait for the pendulum with \\(g=9.81\\) m/s \\(^2\\) , \\(L=1\\) m, \\(b=0.2\\) s \\(^{-1}\\) , \\(A=0.5\\) s \\(^{-2}\\) , and \\(\\omega=0.8\\sqrt{g/L}\\) , showing a closed loop indicative of periodic motion. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint # Parameters g = 9.81 L = 1.0 b = 0.2 A = 0.5 omega = 0.8 * np.sqrt(g/L) # ODE system def pendulum(state, t, b, g, L, A, omega): theta, omega = state dtheta_dt = omega domega_dt = -b*omega - (g/L)*np.sin(theta) + A*np.cos(omega*t) return [dtheta_dt, domega_dt] # Time array t = np.linspace(0, 20, 1000) # Initial conditions state0 = [0.1, 0.0] # Solve ODE solution = odeint(pendulum, state0, t, args=(b, g, L, A, omega)) theta = solution[:, 0] dtheta_dt = solution[:, 1] # Plot plt.figure(figsize=(8, 5)) plt.plot(theta, dtheta_dt, label=r\"$\\text{Phase Trajectory}$\") plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\frac{d\\theta}{dt}$ (rad/s)\") plt.title(r\"$\\text{Phase Portrait of Forced Damped Pendulum}$\") plt.grid(True) plt.legend() plt.show() # Poincar\u00e9 Section Description: # Samples at $t=2\\pi n/\\omega$. # Periodic: Discrete points. # Chaotic: Scattered points.","title":"2.5 Visualization Tools"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#26-summary","text":"Damping controls oscillation decay. Amplitude scales forcing strength. Frequency drives resonance or chaos. Nonlinear effects lead to complex dynamics.","title":"2.6 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-applications","text":"The model applies to systems with oscillatory dynamics.","title":"3. Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#31-energy-harvesting","text":"Vibrational harvesters convert motion to energy: Model : Driving force: Ambient vibrations. Power output: \\[P=(1/2)mL^2(d\\theta/dt)^2\\] Optimization : Maximize at resonance: \\[\\omega=\\omega_0\\]","title":"3.1 Energy Harvesting"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#32-structural-engineering","text":"Bridges oscillate under external loads: Equation : Similar to pendulum: \\[d^2\\theta/dt^2+b\\,d\\theta/dt+(g/L)\\sin\\theta=F_{\\text{ext}}(t)\\] Design : Increase \\(b\\) to avoid resonance.","title":"3.2 Structural Engineering"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#33-electrical-circuits","text":"RLC circuits mirror pendulum dynamics: Equation : Charge dynamics: \\[Ld^2q/dt^2+R\\,dq/dt+(1/C)q=V_{\\text{ext}}(t)\\] Resonance : Maximizes current at: \\[\\omega=1/\\sqrt{LC}\\]","title":"3.3 Electrical Circuits"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#34-summary","text":"Energy harvesting optimizes power at resonance. Structures require damping to prevent failure. Circuits control resonance for stability.","title":"3.4 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#additional-visualization-phase-portraits-under-different-conditions","text":"The following phase diagram shows the behavior of the pendulum for different scenarios: - (i) No damping and no external force (pure closed loops), - (ii) With damping (spiraling into equilibrium), - (iii) With external driving (limit cycles or chaotic behavior). # Forced damped pendulum parameters (resonance-like) b = 0.05 # light damping A = 1.2 # forcing amplitude omega_f = 2.0/3.0 # forcing frequency def forced_damped_pendulum(t, y): theta, omega = y dydt = [omega, -(b)*omega - (g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'm') axs[0].set_title('Forced Damped Pendulum - Time Series (Resonance-like)') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'm') axs[1].set_title('Forced Damped Pendulum - Phase Portrait (Resonance-like)') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":"Additional Visualization: Phase Portraits Under Different Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section-visualization-of-periodicity-and-chaos","text":"Below we plot the Poincar\u00e9 section, sampling the pendulum's phase space at regular intervals ( \\(t=2\\pi n/\\omega\\) ): - For periodic motion: discrete isolated points appear. - For chaotic motion: scattered clouds of points emerge. # Forced damped pendulum parameters (chaotic) b = 0.2 # stronger damping A = 1.5 # larger forcing omega_f = 2.0/3.0 # forcing frequency def chaotic_forced_damped_pendulum(t, y): theta, omega = y dydt = [omega, -(b)*omega - (g/L)*np.sin(theta) + A*np.cos(omega_f*t)] return dydt # Solve sol = solve_ivp(chaotic_forced_damped_pendulum, t_span, y0, t_eval=t_eval) # Plot fig, axs = plt.subplots(1,2, figsize=(12,5)) axs[0].plot(sol.t, sol.y[0], 'g') axs[0].set_title('Forced Damped Pendulum - Time Series (Chaotic)') axs[0].set_xlabel('Time (s)') axs[0].set_ylabel('Angle (rad)') axs[1].plot(sol.y[0], sol.y[1], 'g') axs[1].set_title('Forced Damped Pendulum - Phase Portrait (Chaotic)') axs[1].set_xlabel('Angle (rad)') axs[1].set_ylabel('Angular Velocity (rad/s)') plt.tight_layout() plt.show()","title":"Poincar\u00e9 Section: Visualization of Periodicity and Chaos"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \ud83c\udf0c Deriving Kepler\u2019s Third Law for Circular Orbits Kepler\u2019s Third Law states that the square of the orbital period of a planet is directly proportional to the cube of the semi-major axis of its orbit. For circular orbits, the semi-major axis is equal to the orbital radius. Let's derive this from fundamental physical principles. \u2696\ufe0f Step 1: Newton\u2019s Law of Universal Gravitation Newton's Law of Gravitation gives the attractive force between two masses: \\[F_{\\text{gravity}} = G\\frac{Mm}{r^2}\\] \\(G\\) = Gravitational constant \\(M\\) = Mass of the central body (e.g., Earth or Sun) \\(m\\) = Mass of the orbiting object (e.g., satellite or planet) \\(r\\) = Radius of the circular orbit \ud83d\udd04 Step 2: Centripetal Force for Circular Motion Any object in a circular orbit must experience a centripetal force to stay on its path: \\[F_{\\text{centripetal}} = \\frac{mv^2}{r}\\] \u2696\ufe0f Step 3: Equating Gravitational and Centripetal Forces Since gravity provides the centripetal force: \\[\\frac{mv^2}{r} = G\\frac{Mm}{r^2}\\] Cancel out \\(m\\) (mass of the orbiting body): \\[\\frac{v^2}{r} = G\\frac{M}{r^2}\\] Multiply both sides by \\(r\\) : \\[v^2 = \\frac{GM}{r}\\] \u23f1\ufe0f Step 4: Express Orbital Velocity in Terms of Period Orbital velocity \\(v\\) is the distance traveled in one orbit divided by the orbital period \\(T\\) : \\[v = \\frac{2\\pi r}{T}\\] Substitute into the velocity equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\] Simplify: \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r}\\] Multiply both sides by \\(r\\) : \\[\\frac{4\\pi^2 r^3}{T^2} = GM\\] \ud83d\udcd0 Final Form: Kepler\u2019s Third Law Rearranging for \\(T^2\\) : \\[T^2 = \\frac{4\\pi^2}{GM} \\cdot r^3\\] \u2705 This is Kepler's Third Law for circular orbits! \\(T^2 \\propto r^3\\) The constant of proportionality depends on the central mass \\(M\\) \ud83c\udf20 Physical Meaning of Kepler\u2019s Third Law We previously derived Kepler's Third Law for circular orbits: \\[T^2=\\frac{4\\pi^2}{GM}\\cdot r^3\\] This relationship elegantly connects time (orbital period) with space (orbital radius) through the gravitational constant and the mass of the central body . \ud83d\udd0d Interpretation of Each Term \\(T\\) : Orbital period \u2014 how long it takes to complete one full orbit \\(r\\) : Orbital radius \u2014 the distance between the orbiting body and the central mass \\(G\\) : Universal gravitational constant \u2014 governs strength of gravitational interaction \\(M\\) : Mass of the central body (e.g., Earth, Sun) \ud83e\udde0 Physical Insights 1. Gravitational Control of Motion The period \\(T\\) depends only on the mass of the central body \\(M\\) and the radius \\(r\\) of the orbit. The orbiting body\u2019s own mass \\(m\\) does not appear in the final formula \u2014 this reflects the equivalence principle. 2. Increased Radius = Slower Orbit From the formula: \\( \\(T\\propto r^{3/2}\\) \\) Larger orbits take significantly longer to complete. This explains why outer planets (like Neptune) move much slower than inner ones (like Mercury). 3. Scaling and Proportionality A doubling of \\(r\\) increases \\(T\\) by a factor of: \\( \\(T\\propto(2r)^{3/2}=2^{3/2}\\approx2.83\\) \\) Time grows faster than radius \u2014 orbital systems are not linear. \ud83d\udd2d Astronomical Applications \u2705 1. Estimating Masses of Celestial Bodies Rearranging: \\( \\(M=\\frac{4\\pi^2r^3}{GT^2}\\) \\) If we know the radius and period of a satellite or moon, we can compute the mass of the planet/star it orbits. \u2705 2. Predicting Orbital Times Given a known central mass and radius, we can compute how long any object will take to orbit. \u2705 3. Comparing Planetary Systems By comparing \\(T^2/r^3\\) across different systems, we can verify gravitational consistency: \\( \\(\\frac{T^2}{r^3}=\\text{constant for a given }M\\) \\) \ud83c\udf0d Real-World Applications of Kepler's Third Law Kepler\u2019s Third Law allows us to predict orbital periods and distances for a variety of celestial bodies. By analyzing real-world examples such as the Moon\u2019s orbit around Earth , planetary orbits (like Earth\u2019s orbit around the Sun), and Jupiter\u2019s moons , we can see the practical utility of this fundamental law. 1. \ud83c\udf19 Moon\u2019s Orbit Around Earth 1.1. Known Values Orbital period \\(T_{\\text{moon}}\\) of the Moon: \\(T_{\\text{moon}} = 27.3\\) days (converted to seconds: \\(T_{\\text{moon}} = 27.3 \\times 86400\\) seconds) Average distance between the Earth and the Moon: \\(r = 3.84 \\times 10^8\\) meters Mass of Earth: \\(M_{\\text{Earth}} = 5.972 \\times 10^{24}\\) kg Using Kepler\u2019s Third Law for the Moon\u2019s orbit around Earth: \\[T^2 = \\frac{4\\pi^2 r^3}{GM_{\\text{Earth}}}\\] 1.2. Orbital Period Calculation We can calculate the orbital period of the Moon by rearranging the above equation to solve for \\(T\\) : \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM_{\\text{Earth}}}}\\] Let\u2019s calculate this in Python: import numpy as np # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 (gravitational constant) M_earth = 5.972e24 # kg (mass of Earth) r_moon = 3.84e8 # meters (average distance from Earth to Moon) # Orbital period calculation (in seconds) T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (G * M_earth)) T_moon_days = T_moon / (60 * 60 * 24) # Convert from seconds to days print(f\"Orbital period of the Moon: {T_moon_days:.2f} days\") 2. \ud83d\udda5\ufe0f Python Script to Simulate Circular Orbits We can use the derived formulas to simulate the motion of a satellite in a circular orbit. Below is a Python script that simulates and visualizes the orbit of a satellite around a central body. 2.1. Python Code Implementation import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 (gravitational constant) M = 5.972e24 # kg (mass of Earth) r = 7.5e6 # meters (orbital radius) T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital period v = np.sqrt(G * M / r) # Orbital velocity # Time settings for animation omega = 2 * np.pi / T # Angular velocity (rad/s) t = np.linspace(0, T, 360) # Time array for one orbit x = r * np.cos(omega * t) # X positions over time y = r * np.sin(omega * t) # Y positions over time # Set up the figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-r*1.5, r*1.5) ax.set_ylim(-r*1.5, r*1.5) ax.set_title(\"Satellite Orbit Animation\", color='darkgreen') ax.set_xlabel(\"X (m)\", color='darkgreen') ax.set_ylabel(\"Y (m)\", color='darkgreen') # Draw the central body and initialize the satellite central_body = plt.Circle((0, 0), r*0.05, color='red', label='Earth') satellite, = plt.plot([], [], 'o', color='cyan', label='Satellite') orbit, = plt.plot(x, y, linestyle='--', color='gray', alpha=0.5) # Add the central body to the plot ax.add_artist(central_body) ax.legend(loc=\"upper right\") ax.grid(True, linestyle='--', alpha=0.7) # Animation update function def update(frame): satellite.set_data([x[frame]], [y[frame]]) return satellite, # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) plt.show() # Output the orbital period and velocity print(f\"Orbital Period: {T/86400:.2f} days\") print(f\"Orbital Velocity: {v/1000:.2f} km/s\") \ud83e\ude90 Verifying Kepler\u2019s Third Law Numerically In this section, we will verify Kepler's Third Law numerically by calculating the orbital period of a planet or moon and comparing it to the values predicted by the law. Kepler's Third Law states that the square of the orbital period ( \\(T^2\\) ) is directly proportional to the cube of the orbital radius ( \\(r^3\\) ). Mathematically, this relationship can be written as: \\[T^2 \\propto r^3\\] In terms of gravitational forces, the orbital period \\(T\\) for a circular orbit is given by: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\] Where: - \\(T\\) is the orbital period . - \\(r\\) is the orbital radius . - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ). - \\(M\\) is the mass of the central body (e.g., the Sun for planetary orbits). We will now use this formula to verify Kepler\u2019s Third Law numerically for a set of planets and moons. \ud83e\uddee Calculating Masses of Earth and Sun import numpy as np # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) AU_to_m = 1.496e11 # Meters per AU year_to_s = 3.156e7 # Seconds per year day_to_s = 86400 # Seconds per day # Data for Earth's orbit around the Sun (to calculate Sun's mass) r_sun = 1.000 * AU_to_m # Earth's semi-major axis (m) T_sun = 1.000 * year_to_s # Earth's orbital period (s) # Data for Moon's orbit around Earth (to calculate Earth's mass) r_moon = 3.84e8 # Average distance from Earth to Moon (m) T_moon = 27.3 * day_to_s # Moon's orbital period (s) # Calculate Sun's mass r_sun_cubed = r_sun ** 3 T_sun_squared = T_sun ** 2 M_sun = (4 * np.pi**2 * r_sun_cubed) / (G * T_sun_squared) print(f\"Mass of the Sun: {M_sun:.3e} kg\") # Calculate Earth's mass r_moon_cubed = r_moon ** 3 T_moon_squared = T_moon ** 2 M_earth = (4 * np.pi**2 * r_moon_cubed) / (G * T_moon_squared) print(f\"Mass of the Earth: {M_earth:.3e} kg\") 1. \ud83e\uddee Kepler\u2019s Third Law Formula From Kepler's Third Law, the orbital period for a circular orbit is: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\] 1.1. Gravitational Constant and Units \\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) . Mass of the central body ( \\(M\\) ) is given in kg . Orbital radius ( \\(r\\) ) is given in meters . The orbital period \\(T\\) will be calculated in seconds . 2. \ud83d\udd2d Numerical Verification Let\u2019s now calculate the orbital period for different celestial bodies, such as Earth and Jupiter , using Kepler\u2019s Third Law. 2.1. Python Code Implementation The following code will calculate the orbital period for different celestial bodies by using their orbital radii and masses . We will also visualize the relationship between the square of the orbital period ( \\(T^2\\) ) and the cube of the orbital radius ( \\(r^3\\) ). import numpy as np import matplotlib.pyplot as plt # Conversion factors AU_to_m = 1.496e11 # Meters per AU year_to_s = 3.156e7 # Seconds per year # Data for Mercury, Venus, Earth, Mars (semi-major axis in AU, period in years) planets = { \"Mercury\": {\"r\": 0.387 * AU_to_m, \"T\": 0.241 * year_to_s}, \"Venus\": {\"r\": 0.723 * AU_to_m, \"T\": 0.615 * year_to_s}, \"Earth\": {\"r\": 1.000 * AU_to_m, \"T\": 1.000 * year_to_s}, \"Mars\": {\"r\": 1.524 * AU_to_m, \"T\": 1.881 * year_to_s}, } # Compute r^3 and T^2 r_cubed = [data[\"r\"]**3 for data in planets.values()] T_squared = [data[\"T\"]**2 for data in planets.values()] planet_names = list(planets.keys()) # Plot T^2 vs r^3 (should be a straight line) plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='blue', label=\"Planets\") for i, name in enumerate(planet_names): plt.annotate(name, (r_cubed[i], T_squared[i]), fontsize=9, ha='right') plt.plot(r_cubed, np.poly1d(np.polyfit(r_cubed, T_squared, 1))(r_cubed), color='red', linestyle='--', label=\"Best Fit Line\") plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$ for Planets\") plt.xlabel(\"$r^3$ (m\u00b3)\") plt.ylabel(\"$T^2$ (s\u00b2)\") plt.legend() plt.grid(True) plt.savefig('kepler_third_law_plot.png') # Save the plot as per guidelines","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deriving-keplers-third-law-for-circular-orbits","text":"Kepler\u2019s Third Law states that the square of the orbital period of a planet is directly proportional to the cube of the semi-major axis of its orbit. For circular orbits, the semi-major axis is equal to the orbital radius. Let's derive this from fundamental physical principles.","title":"\ud83c\udf0c Deriving Kepler\u2019s Third Law for Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-newtons-law-of-universal-gravitation","text":"Newton's Law of Gravitation gives the attractive force between two masses: \\[F_{\\text{gravity}} = G\\frac{Mm}{r^2}\\] \\(G\\) = Gravitational constant \\(M\\) = Mass of the central body (e.g., Earth or Sun) \\(m\\) = Mass of the orbiting object (e.g., satellite or planet) \\(r\\) = Radius of the circular orbit","title":"\u2696\ufe0f Step 1: Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-centripetal-force-for-circular-motion","text":"Any object in a circular orbit must experience a centripetal force to stay on its path: \\[F_{\\text{centripetal}} = \\frac{mv^2}{r}\\]","title":"\ud83d\udd04 Step 2: Centripetal Force for Circular Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-3-equating-gravitational-and-centripetal-forces","text":"Since gravity provides the centripetal force: \\[\\frac{mv^2}{r} = G\\frac{Mm}{r^2}\\] Cancel out \\(m\\) (mass of the orbiting body): \\[\\frac{v^2}{r} = G\\frac{M}{r^2}\\] Multiply both sides by \\(r\\) : \\[v^2 = \\frac{GM}{r}\\]","title":"\u2696\ufe0f Step 3: Equating Gravitational and Centripetal Forces"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-4-express-orbital-velocity-in-terms-of-period","text":"Orbital velocity \\(v\\) is the distance traveled in one orbit divided by the orbital period \\(T\\) : \\[v = \\frac{2\\pi r}{T}\\] Substitute into the velocity equation: \\[\\left(\\frac{2\\pi r}{T}\\right)^2 = \\frac{GM}{r}\\] Simplify: \\[\\frac{4\\pi^2 r^2}{T^2} = \\frac{GM}{r}\\] Multiply both sides by \\(r\\) : \\[\\frac{4\\pi^2 r^3}{T^2} = GM\\]","title":"\u23f1\ufe0f Step 4: Express Orbital Velocity in Terms of Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#final-form-keplers-third-law","text":"Rearranging for \\(T^2\\) : \\[T^2 = \\frac{4\\pi^2}{GM} \\cdot r^3\\] \u2705 This is Kepler's Third Law for circular orbits! \\(T^2 \\propto r^3\\) The constant of proportionality depends on the central mass \\(M\\)","title":"\ud83d\udcd0 Final Form: Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#physical-meaning-of-keplers-third-law","text":"We previously derived Kepler's Third Law for circular orbits: \\[T^2=\\frac{4\\pi^2}{GM}\\cdot r^3\\] This relationship elegantly connects time (orbital period) with space (orbital radius) through the gravitational constant and the mass of the central body .","title":"\ud83c\udf20 Physical Meaning of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#interpretation-of-each-term","text":"\\(T\\) : Orbital period \u2014 how long it takes to complete one full orbit \\(r\\) : Orbital radius \u2014 the distance between the orbiting body and the central mass \\(G\\) : Universal gravitational constant \u2014 governs strength of gravitational interaction \\(M\\) : Mass of the central body (e.g., Earth, Sun)","title":"\ud83d\udd0d Interpretation of Each Term"},{"location":"1%20Physics/2%20Gravity/Problem_1/#physical-insights","text":"","title":"\ud83e\udde0 Physical Insights"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-gravitational-control-of-motion","text":"The period \\(T\\) depends only on the mass of the central body \\(M\\) and the radius \\(r\\) of the orbit. The orbiting body\u2019s own mass \\(m\\) does not appear in the final formula \u2014 this reflects the equivalence principle.","title":"1. Gravitational Control of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-increased-radius-slower-orbit","text":"From the formula: \\( \\(T\\propto r^{3/2}\\) \\) Larger orbits take significantly longer to complete. This explains why outer planets (like Neptune) move much slower than inner ones (like Mercury).","title":"2. Increased Radius = Slower Orbit"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-scaling-and-proportionality","text":"A doubling of \\(r\\) increases \\(T\\) by a factor of: \\( \\(T\\propto(2r)^{3/2}=2^{3/2}\\approx2.83\\) \\) Time grows faster than radius \u2014 orbital systems are not linear.","title":"3. Scaling and Proportionality"},{"location":"1%20Physics/2%20Gravity/Problem_1/#astronomical-applications","text":"","title":"\ud83d\udd2d Astronomical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-estimating-masses-of-celestial-bodies","text":"Rearranging: \\( \\(M=\\frac{4\\pi^2r^3}{GT^2}\\) \\) If we know the radius and period of a satellite or moon, we can compute the mass of the planet/star it orbits.","title":"\u2705 1. Estimating Masses of Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-predicting-orbital-times","text":"Given a known central mass and radius, we can compute how long any object will take to orbit.","title":"\u2705 2. Predicting Orbital Times"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-comparing-planetary-systems","text":"By comparing \\(T^2/r^3\\) across different systems, we can verify gravitational consistency: \\( \\(\\frac{T^2}{r^3}=\\text{constant for a given }M\\) \\)","title":"\u2705 3. Comparing Planetary Systems"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-applications-of-keplers-third-law","text":"Kepler\u2019s Third Law allows us to predict orbital periods and distances for a variety of celestial bodies. By analyzing real-world examples such as the Moon\u2019s orbit around Earth , planetary orbits (like Earth\u2019s orbit around the Sun), and Jupiter\u2019s moons , we can see the practical utility of this fundamental law.","title":"\ud83c\udf0d Real-World Applications of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-moons-orbit-around-earth","text":"","title":"1. \ud83c\udf19 Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-known-values","text":"Orbital period \\(T_{\\text{moon}}\\) of the Moon: \\(T_{\\text{moon}} = 27.3\\) days (converted to seconds: \\(T_{\\text{moon}} = 27.3 \\times 86400\\) seconds) Average distance between the Earth and the Moon: \\(r = 3.84 \\times 10^8\\) meters Mass of Earth: \\(M_{\\text{Earth}} = 5.972 \\times 10^{24}\\) kg Using Kepler\u2019s Third Law for the Moon\u2019s orbit around Earth: \\[T^2 = \\frac{4\\pi^2 r^3}{GM_{\\text{Earth}}}\\]","title":"1.1. Known Values"},{"location":"1%20Physics/2%20Gravity/Problem_1/#12-orbital-period-calculation","text":"We can calculate the orbital period of the Moon by rearranging the above equation to solve for \\(T\\) : \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM_{\\text{Earth}}}}\\] Let\u2019s calculate this in Python: import numpy as np # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 (gravitational constant) M_earth = 5.972e24 # kg (mass of Earth) r_moon = 3.84e8 # meters (average distance from Earth to Moon) # Orbital period calculation (in seconds) T_moon = 2 * np.pi * np.sqrt(r_moon**3 / (G * M_earth)) T_moon_days = T_moon / (60 * 60 * 24) # Convert from seconds to days print(f\"Orbital period of the Moon: {T_moon_days:.2f} days\")","title":"1.2. Orbital Period Calculation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-python-script-to-simulate-circular-orbits","text":"We can use the derived formulas to simulate the motion of a satellite in a circular orbit. Below is a Python script that simulates and visualizes the orbit of a satellite around a central body.","title":"2. \ud83d\udda5\ufe0f Python Script to Simulate Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#21-python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 (gravitational constant) M = 5.972e24 # kg (mass of Earth) r = 7.5e6 # meters (orbital radius) T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital period v = np.sqrt(G * M / r) # Orbital velocity # Time settings for animation omega = 2 * np.pi / T # Angular velocity (rad/s) t = np.linspace(0, T, 360) # Time array for one orbit x = r * np.cos(omega * t) # X positions over time y = r * np.sin(omega * t) # Y positions over time # Set up the figure and axis fig, ax = plt.subplots(figsize=(6, 6)) ax.set_aspect('equal') ax.set_xlim(-r*1.5, r*1.5) ax.set_ylim(-r*1.5, r*1.5) ax.set_title(\"Satellite Orbit Animation\", color='darkgreen') ax.set_xlabel(\"X (m)\", color='darkgreen') ax.set_ylabel(\"Y (m)\", color='darkgreen') # Draw the central body and initialize the satellite central_body = plt.Circle((0, 0), r*0.05, color='red', label='Earth') satellite, = plt.plot([], [], 'o', color='cyan', label='Satellite') orbit, = plt.plot(x, y, linestyle='--', color='gray', alpha=0.5) # Add the central body to the plot ax.add_artist(central_body) ax.legend(loc=\"upper right\") ax.grid(True, linestyle='--', alpha=0.7) # Animation update function def update(frame): satellite.set_data([x[frame]], [y[frame]]) return satellite, # Create animation ani = FuncAnimation(fig, update, frames=len(t), interval=50, blit=True) plt.show() # Output the orbital period and velocity print(f\"Orbital Period: {T/86400:.2f} days\") print(f\"Orbital Velocity: {v/1000:.2f} km/s\")","title":"2.1. Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#verifying-keplers-third-law-numerically","text":"In this section, we will verify Kepler's Third Law numerically by calculating the orbital period of a planet or moon and comparing it to the values predicted by the law. Kepler's Third Law states that the square of the orbital period ( \\(T^2\\) ) is directly proportional to the cube of the orbital radius ( \\(r^3\\) ). Mathematically, this relationship can be written as: \\[T^2 \\propto r^3\\] In terms of gravitational forces, the orbital period \\(T\\) for a circular orbit is given by: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\] Where: - \\(T\\) is the orbital period . - \\(r\\) is the orbital radius . - \\(G\\) is the gravitational constant ( \\(6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) ). - \\(M\\) is the mass of the central body (e.g., the Sun for planetary orbits). We will now use this formula to verify Kepler\u2019s Third Law numerically for a set of planets and moons.","title":"\ud83e\ude90 Verifying Kepler\u2019s Third Law Numerically"},{"location":"1%20Physics/2%20Gravity/Problem_1/#calculating-masses-of-earth-and-sun","text":"import numpy as np # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) AU_to_m = 1.496e11 # Meters per AU year_to_s = 3.156e7 # Seconds per year day_to_s = 86400 # Seconds per day # Data for Earth's orbit around the Sun (to calculate Sun's mass) r_sun = 1.000 * AU_to_m # Earth's semi-major axis (m) T_sun = 1.000 * year_to_s # Earth's orbital period (s) # Data for Moon's orbit around Earth (to calculate Earth's mass) r_moon = 3.84e8 # Average distance from Earth to Moon (m) T_moon = 27.3 * day_to_s # Moon's orbital period (s) # Calculate Sun's mass r_sun_cubed = r_sun ** 3 T_sun_squared = T_sun ** 2 M_sun = (4 * np.pi**2 * r_sun_cubed) / (G * T_sun_squared) print(f\"Mass of the Sun: {M_sun:.3e} kg\") # Calculate Earth's mass r_moon_cubed = r_moon ** 3 T_moon_squared = T_moon ** 2 M_earth = (4 * np.pi**2 * r_moon_cubed) / (G * T_moon_squared) print(f\"Mass of the Earth: {M_earth:.3e} kg\")","title":"\ud83e\uddee Calculating Masses of Earth and Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-keplers-third-law-formula","text":"From Kepler's Third Law, the orbital period for a circular orbit is: \\[T = 2\\pi \\sqrt{\\frac{r^3}{GM}}\\]","title":"1. \ud83e\uddee Kepler\u2019s Third Law Formula"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-gravitational-constant-and-units","text":"\\(G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\, \\text{kg}^{-1} \\, \\text{s}^{-2}\\) . Mass of the central body ( \\(M\\) ) is given in kg . Orbital radius ( \\(r\\) ) is given in meters . The orbital period \\(T\\) will be calculated in seconds .","title":"1.1. Gravitational Constant and Units"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-numerical-verification","text":"Let\u2019s now calculate the orbital period for different celestial bodies, such as Earth and Jupiter , using Kepler\u2019s Third Law.","title":"2. \ud83d\udd2d Numerical Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#21-python-code-implementation_1","text":"The following code will calculate the orbital period for different celestial bodies by using their orbital radii and masses . We will also visualize the relationship between the square of the orbital period ( \\(T^2\\) ) and the cube of the orbital radius ( \\(r^3\\) ). import numpy as np import matplotlib.pyplot as plt # Conversion factors AU_to_m = 1.496e11 # Meters per AU year_to_s = 3.156e7 # Seconds per year # Data for Mercury, Venus, Earth, Mars (semi-major axis in AU, period in years) planets = { \"Mercury\": {\"r\": 0.387 * AU_to_m, \"T\": 0.241 * year_to_s}, \"Venus\": {\"r\": 0.723 * AU_to_m, \"T\": 0.615 * year_to_s}, \"Earth\": {\"r\": 1.000 * AU_to_m, \"T\": 1.000 * year_to_s}, \"Mars\": {\"r\": 1.524 * AU_to_m, \"T\": 1.881 * year_to_s}, } # Compute r^3 and T^2 r_cubed = [data[\"r\"]**3 for data in planets.values()] T_squared = [data[\"T\"]**2 for data in planets.values()] planet_names = list(planets.keys()) # Plot T^2 vs r^3 (should be a straight line) plt.figure(figsize=(8, 6)) plt.scatter(r_cubed, T_squared, color='blue', label=\"Planets\") for i, name in enumerate(planet_names): plt.annotate(name, (r_cubed[i], T_squared[i]), fontsize=9, ha='right') plt.plot(r_cubed, np.poly1d(np.polyfit(r_cubed, T_squared, 1))(r_cubed), color='red', linestyle='--', label=\"Best Fit Line\") plt.title(\"Kepler's Third Law: $T^2$ vs $r^3$ for Planets\") plt.xlabel(\"$r^3$ (m\u00b3)\") plt.ylabel(\"$T^2$ (s\u00b2)\") plt.legend() plt.grid(True) plt.savefig('kepler_third_law_plot.png') # Save the plot as per guidelines","title":"2.1. Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Cosmic Velocities: Derivations, Calculations, and Comparisons 1. Definitions of Cosmic Velocities Cosmic velocities are critical thresholds in astrodynamics, defining minimum speeds for orbital and escape maneuvers: First Cosmic Velocity \\(v_1\\) : Definition : The speed required for an object to maintain a circular orbit near a celestial body's surface. Equation : \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second Cosmic Velocity \\(v_2\\) : Definition : The speed required to escape a celestial body's gravitational pull. Equation : \\(v_2 = \\sqrt{\\frac{2GM}{R}}\\) Third Cosmic Velocity \\(v_3\\) : Definition : The speed required to escape a star system from a planet's orbit. Equation : \\(v_3 = \\sqrt{v_2^2 + (v_{\\text{esc,Sun}} - v_{\\text{orbit}})^2}\\) 2. Derivations 2.1 First Cosmic Velocity ( \\(v_1\\) ) import numpy as np import matplotlib.pyplot as plt # Constants and calculations G = 6.67430e-11 M = 5.972e24 radii = np.linspace(1e6, 1.5e7, 500) v1 = np.sqrt(G * M / radii) v1_km_s = v1 / 1000 # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Main plot line with enhanced styling main_line, = plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='#0066cc', linewidth=3) # Enhanced text elements ax.set_xlabel('Planet Radius (km)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_ylabel('First Cosmic Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('First Cosmic Velocity vs Planet Radius', fontsize=16, fontweight='bold', pad=20, color='black') # High-visibility legend legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) legend.get_texts()[0].set_color('black') legend.get_texts()[0].set_fontweight('bold') # Grid and frame ax.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # Add direct label to curve for extra clarity ax.text(8000, 7.5, r'$v_1 = \\sqrt{\\frac{GM}{R}}$', fontsize=14, fontweight='bold', color='#0066cc') # Make ticks more visible ax.tick_params(axis='both', which='both', labelsize=12, color='black') plt.tight_layout() plt.show() Derivation : Gravitational force equals centripetal force: $$ \\frac{GMm}{R^2}=\\frac{mv_1^2}{R} \\implies v_1=\\sqrt{\\frac{GM}{R}} $$ 2.2 Second Cosmic Velocity ( \\(v_2\\) ) import numpy as np import matplotlib.pyplot as plt # Data v1 = np.linspace(0, 20, 500) v2 = np.sqrt(2) * v1 # Plot setup with high visibility text plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Plot lines with contrasting colors main_line, = plt.plot(v1, v2, color='#0066cc', linewidth=3, label=r'$v_2 = \\sqrt{2} \\times v_1$') ref_line, = plt.plot(v1, v1, linestyle='--', color='#cc3300', linewidth=2, label=r'$v_2 = v_1$ (reference line)') # Enhanced text elements ax.set_xlabel('First Cosmic Velocity $v_1$ (km/s)', fontsize=14, fontweight='bold', color='black') ax.set_ylabel('Second Cosmic Velocity $v_2$ (km/s)', fontsize=14, fontweight='bold', color='black') ax.set_title('Relationship between First and Second Cosmic Velocities', fontsize=16, fontweight='bold', pad=20, color='black') # High-visibility legend legend = ax.legend( handles=[main_line, ref_line], loc='upper left', frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1 ) legend.get_frame().set_linewidth(2) # Make all text elements black and bold for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') # Grid and ticks ax.grid(True, linestyle=':', color='gray', alpha=0.4) ax.tick_params(axis='both', which='major', labelsize=12, colors='black') # Add direct labels to lines for extra clarity ax.text(15, 28, r'$v_2 = \\sqrt{2}v_1$', fontsize=14, fontweight='bold', color='#0066cc') ax.text(15, 15, r'$v_2 = v_1$', fontsize=14, fontweight='bold', color='#cc3300') # Frame for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) plt.tight_layout() plt.show() Derivation : Energy conservation (kinetic + potential = 0 at infinity): \\[ \\frac{1}{2}mv_2^2 - \\frac{GMm}{R} = 0 \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\] 2.3 Third Cosmic Velocity ( \\(v_3\\) ) Derivation : Escape Sun's gravity at planet's orbital distance: $$ v_{\\text{esc,Sun}}=\\sqrt{\\frac{2GM_{\\text{Sun}}}{R_{\\text{orbit}}}} $$ Planet's orbital velocity around Sun: $$ v_{\\text{orbit}}=\\sqrt{\\frac{GM_{\\text{Sun}}}{R_{\\text{orbit}}}} $$ Total velocity from planet's surface: $$ v_3=\\sqrt{v_2^2+(v_{\\text{esc,Sun}}-v_{\\text{orbit}})^2} $$ 3. Cosmic Velocities for Earth Parameters : - \\(M_{\\text{Earth}} = 5.972 \\times 10^{24} \\text{ kg}\\) - \\(R_{\\text{Earth}} = 6.371 \\times 10^6 \\text{ m}\\) - \\(R_{\\text{Earth-Sun}} = 1.496 \\times 10^{11} \\text{ m}\\) Calculations : - \\(v_1 = \\sqrt{\\frac{GM_{\\text{Earth}}}{R_{\\text{Earth}}}} \\approx 7.91 \\text{ km/s}\\) - \\(v_2 = \\sqrt{2} \\cdot v_1 \\approx 11.19 \\text{ km/s}\\) - \\(v_3 = \\sqrt{v_2^2 + (\\sqrt{\\frac{2GM_{\\text{Sun}}}{R_{\\text{Earth-Sun}}}} - \\sqrt{\\frac{GM_{\\text{Sun}}}{R_{\\text{Earth-Sun}}}})^2} \\approx 16.64 \\text{ km/s}\\) 4. Comparison with Moon, Mars, and Jupiter import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced styling bar_width = 0.25 bar1 = plt.bar(x, v1, width=bar_width, label='First Cosmic Velocity (v1)', color='#0066cc', edgecolor='black', linewidth=1.5) bar2 = plt.bar([i + bar_width for i in x], v2, width=bar_width, label='Second Cosmic Velocity (v2)', color='#cc3300', edgecolor='black', linewidth=1.5) bar3 = plt.bar([i + 2*bar_width for i in x], [v if v else 0 for v in v3], width=bar_width, label='Third Cosmic Velocity (v3)', color='#009966', edgecolor='black', linewidth=1.5) # Special styling for Moon's v3 (None value) bar3[1].set_hatch('//') bar3[1].set_color('#ff9999') # Enhanced text elements ax.set_ylabel('Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('Comparison of Cosmic Velocities', fontsize=16, fontweight='bold', pad=20, color='black') ax.set_xticks([i + bar_width for i in x]) ax.set_xticklabels(bodies, fontsize=12, fontweight='bold', color='black') # High-visibility legend legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') # Add value labels on bars for bars, offset in zip([bar1, bar2, bar3], [0, bar_width, 2*bar_width]): for i, bar in enumerate(bars): height = bar.get_height() if height > 0: # Only label non-zero bars ax.text(bar.get_x() + bar.get_width()/2., height + 1, f'{height:.1f}', ha='center', va='bottom', fontsize=11, fontweight='bold') # Special annotation for Moon's v3 ax.text(1 + 2*bar_width, 1, 'N/A', ha='center', va='bottom', fontsize=11, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) plt.tight_layout() plt.show() Parameters : Body Mass (kg) Radius (m) Orbital Radius (m) Moon \\(7.342 \\times 10^{22}\\) \\(1.737 \\times 10^6\\) \\(1.496 \\times 10^{11}\\) (Earth's) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.899 \\times 10^{27}\\) \\(6.991 \\times 10^7\\) \\(7.785 \\times 10^{11}\\) Calculated Velocities (km/s) : Body \\(v_1\\) \\(v_2\\) \\(v_3\\) Earth 7.91 11.19 16.64 Moon 1.68 2.38 16.51 Mars 3.55 5.03 13.09 Jupiter 42.14 59.57 9.67 5. Visualizations 5.1 Cosmic Velocities Comparison import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_sun = 1.989e30 # Celestial body parameters: [mass (kg), radius (m), orbital radius (m)] bodies = { 'Earth': [5.972e24, 6.371e6, 1.496e11], 'Moon': [7.342e22, 1.737e6, 1.496e11], 'Mars': [6.417e23, 3.390e6, 2.279e11], 'Jupiter': [1.899e27, 6.991e7, 7.785e11] } # Calculate cosmic velocities velocities = {'v1': {}, 'v2': {}, 'v3': {}} for body, (M, R, R_orbit) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 v2 = np.sqrt(2 * G * M / R) / 1000 v_esc_sun = np.sqrt(2 * G * M_sun / R_orbit) / 1000 v_orbit = np.sqrt(G * M_sun / R_orbit) / 1000 v3 = np.sqrt(v2**2 + (v_esc_sun - v_orbit)**2) velocities['v1'][body] = v1 velocities['v2'][body] = v2 velocities['v3'][body] = v3 # Plot fig, ax = plt.subplots(figsize=(12, 7)) x = np.arange(len(bodies)) width = 0.25 bars1 = ax.bar(x - width, velocities['v1'].values(), width, label='$v_1$') bars2 = ax.bar(x, velocities['v2'].values(), width, label='$v_2$') bars3 = ax.bar(x + width, velocities['v3'].values(), width, label='$v_3$') # Annotations for bars in [bars1, bars2, bars3]: for bar in bars: height = bar.get_height() ax.annotate(f'{height:.2f}', xy=(bar.get_x() + bar.get_width() / 2, height), xytext=(0, 3), textcoords=\"offset points\", ha='center', va='bottom') ax.set_yscale('log') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (km/s, log scale)') ax.set_title('Cosmic Velocities Comparison') ax.set_xticks(x) ax.set_xticklabels(bodies.keys()) ax.legend() ax.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('cosmic_velocities_comparison.png') plt.show() import numpy as np import matplotlib.pyplot as plt # Constants and data G = 6.67430e-11 bodies = { \"Earth\": {\"R\": 6.371e6, \"M\": 5.97e24}, \"Moon\": {\"R\": 1.74e6, \"M\": 7.35e22}, \"Mars\": {\"R\": 3.39e6, \"M\": 6.42e23}, \"Jupiter\": {\"R\": 7.15e7, \"M\": 1.90e27} } # Calculate values radii = [] v2_values = [] labels = [] for body, data in bodies.items(): R = data[\"R\"] M = data[\"M\"] v2 = np.sqrt(2 * G * M / R) / 1000 radii.append(R / 1e6) v2_values.append(v2) labels.append(body) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced styling bars = plt.bar(labels, v2_values, color=['#0066cc', '#cc3300', '#009966', '#6633cc'], edgecolor='black', linewidth=1.5, width=0.6) # Enhanced text elements ax.set_title('Second Cosmic Velocity (Escape Velocity) vs Planet Radius', fontsize=16, fontweight='bold', pad=20, color='black') ax.set_xlabel('Celestial Body', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_ylabel('Escape Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) # Value labels on bars for bar in bars: height = bar.get_height() ax.text(bar.get_x() + bar.get_width()/2., height + 0.5, f'{height:.1f} km/s', ha='center', va='bottom', fontsize=12, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # X-axis ticks ax.set_xticklabels(labels, fontsize=12, fontweight='bold', color='black') plt.tight_layout() plt.show() import matplotlib.pyplot as plt # Data celestial_bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] escape_velocities = [16.7, None, 14.1, 18.5] # Third Cosmic Velocity (km/s) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced visibility bars = plt.bar(celestial_bodies, [vel if vel else 0 for vel in escape_velocities], color=['#0066cc', '#cc3300', '#009966', '#6633cc'], width=0.6, edgecolor='black', linewidth=1.5) # Special marking for Moon (None value) bars[1].set_hatch('//') bars[1].set_color('#ff9999') bars[1].set_edgecolor('black') # Enhanced text elements ax.set_ylabel('Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('Third Cosmic Velocity Comparison for Celestial Bodies', fontsize=16, fontweight='bold', pad=20, color='black') # X-axis labels ax.set_xticklabels(celestial_bodies, fontsize=12, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # High-visibility legend legend = ax.legend(['Third Cosmic Velocity (v3)'], frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) legend.get_texts()[0].set_color('black') legend.get_texts()[0].set_fontweight('bold') # Add value labels on top of bars for bar in bars: height = bar.get_height() if height > 0: # Only label non-zero bars ax.text(bar.get_x() + bar.get_width()/2., height + 0.5, f'{height:.1f}', ha='center', va='bottom', fontsize=12, fontweight='bold') # Special annotation for Moon ax.text(bars[1].get_x() + bars[1].get_width()/2., 1, 'N/A', ha='center', va='bottom', fontsize=12, fontweight='bold', color='black') plt.tight_layout() plt.show()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-derivations-calculations-and-comparisons","text":"","title":"Cosmic Velocities: Derivations, Calculations, and Comparisons"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-of-cosmic-velocities","text":"Cosmic velocities are critical thresholds in astrodynamics, defining minimum speeds for orbital and escape maneuvers: First Cosmic Velocity \\(v_1\\) : Definition : The speed required for an object to maintain a circular orbit near a celestial body's surface. Equation : \\(v_1 = \\sqrt{\\frac{GM}{R}}\\) Second Cosmic Velocity \\(v_2\\) : Definition : The speed required to escape a celestial body's gravitational pull. Equation : \\(v_2 = \\sqrt{\\frac{2GM}{R}}\\) Third Cosmic Velocity \\(v_3\\) : Definition : The speed required to escape a star system from a planet's orbit. Equation : \\(v_3 = \\sqrt{v_2^2 + (v_{\\text{esc,Sun}} - v_{\\text{orbit}})^2}\\)","title":"1. Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-derivations","text":"","title":"2. Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#21-first-cosmic-velocity-v_1","text":"import numpy as np import matplotlib.pyplot as plt # Constants and calculations G = 6.67430e-11 M = 5.972e24 radii = np.linspace(1e6, 1.5e7, 500) v1 = np.sqrt(G * M / radii) v1_km_s = v1 / 1000 # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Main plot line with enhanced styling main_line, = plt.plot(radii/1000, v1_km_s, label='First Cosmic Velocity', color='#0066cc', linewidth=3) # Enhanced text elements ax.set_xlabel('Planet Radius (km)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_ylabel('First Cosmic Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('First Cosmic Velocity vs Planet Radius', fontsize=16, fontweight='bold', pad=20, color='black') # High-visibility legend legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) legend.get_texts()[0].set_color('black') legend.get_texts()[0].set_fontweight('bold') # Grid and frame ax.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # Add direct label to curve for extra clarity ax.text(8000, 7.5, r'$v_1 = \\sqrt{\\frac{GM}{R}}$', fontsize=14, fontweight='bold', color='#0066cc') # Make ticks more visible ax.tick_params(axis='both', which='both', labelsize=12, color='black') plt.tight_layout() plt.show() Derivation : Gravitational force equals centripetal force: $$ \\frac{GMm}{R^2}=\\frac{mv_1^2}{R} \\implies v_1=\\sqrt{\\frac{GM}{R}} $$","title":"2.1 First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#22-second-cosmic-velocity-v_2","text":"import numpy as np import matplotlib.pyplot as plt # Data v1 = np.linspace(0, 20, 500) v2 = np.sqrt(2) * v1 # Plot setup with high visibility text plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Plot lines with contrasting colors main_line, = plt.plot(v1, v2, color='#0066cc', linewidth=3, label=r'$v_2 = \\sqrt{2} \\times v_1$') ref_line, = plt.plot(v1, v1, linestyle='--', color='#cc3300', linewidth=2, label=r'$v_2 = v_1$ (reference line)') # Enhanced text elements ax.set_xlabel('First Cosmic Velocity $v_1$ (km/s)', fontsize=14, fontweight='bold', color='black') ax.set_ylabel('Second Cosmic Velocity $v_2$ (km/s)', fontsize=14, fontweight='bold', color='black') ax.set_title('Relationship between First and Second Cosmic Velocities', fontsize=16, fontweight='bold', pad=20, color='black') # High-visibility legend legend = ax.legend( handles=[main_line, ref_line], loc='upper left', frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1 ) legend.get_frame().set_linewidth(2) # Make all text elements black and bold for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') # Grid and ticks ax.grid(True, linestyle=':', color='gray', alpha=0.4) ax.tick_params(axis='both', which='major', labelsize=12, colors='black') # Add direct labels to lines for extra clarity ax.text(15, 28, r'$v_2 = \\sqrt{2}v_1$', fontsize=14, fontweight='bold', color='#0066cc') ax.text(15, 15, r'$v_2 = v_1$', fontsize=14, fontweight='bold', color='#cc3300') # Frame for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) plt.tight_layout() plt.show() Derivation : Energy conservation (kinetic + potential = 0 at infinity): \\[ \\frac{1}{2}mv_2^2 - \\frac{GMm}{R} = 0 \\implies v_2 = \\sqrt{\\frac{2GM}{R}} \\]","title":"2.2 Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#23-third-cosmic-velocity-v_3","text":"Derivation : Escape Sun's gravity at planet's orbital distance: $$ v_{\\text{esc,Sun}}=\\sqrt{\\frac{2GM_{\\text{Sun}}}{R_{\\text{orbit}}}} $$ Planet's orbital velocity around Sun: $$ v_{\\text{orbit}}=\\sqrt{\\frac{GM_{\\text{Sun}}}{R_{\\text{orbit}}}} $$ Total velocity from planet's surface: $$ v_3=\\sqrt{v_2^2+(v_{\\text{esc,Sun}}-v_{\\text{orbit}})^2} $$","title":"2.3 Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-cosmic-velocities-for-earth","text":"Parameters : - \\(M_{\\text{Earth}} = 5.972 \\times 10^{24} \\text{ kg}\\) - \\(R_{\\text{Earth}} = 6.371 \\times 10^6 \\text{ m}\\) - \\(R_{\\text{Earth-Sun}} = 1.496 \\times 10^{11} \\text{ m}\\) Calculations : - \\(v_1 = \\sqrt{\\frac{GM_{\\text{Earth}}}{R_{\\text{Earth}}}} \\approx 7.91 \\text{ km/s}\\) - \\(v_2 = \\sqrt{2} \\cdot v_1 \\approx 11.19 \\text{ km/s}\\) - \\(v_3 = \\sqrt{v_2^2 + (\\sqrt{\\frac{2GM_{\\text{Sun}}}{R_{\\text{Earth-Sun}}}} - \\sqrt{\\frac{GM_{\\text{Sun}}}{R_{\\text{Earth-Sun}}}})^2} \\approx 16.64 \\text{ km/s}\\)","title":"3. Cosmic Velocities for Earth"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-comparison-with-moon-mars-and-jupiter","text":"import matplotlib.pyplot as plt # Data bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] v1 = [7.9, 1.68, 3.55, 42.1] v2 = [11.2, 2.38, 5.03, 59.5] v3 = [16.7, None, 14.1, 18.5] # Moon doesn't have v3 in same sense x = range(len(bodies)) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced styling bar_width = 0.25 bar1 = plt.bar(x, v1, width=bar_width, label='First Cosmic Velocity (v1)', color='#0066cc', edgecolor='black', linewidth=1.5) bar2 = plt.bar([i + bar_width for i in x], v2, width=bar_width, label='Second Cosmic Velocity (v2)', color='#cc3300', edgecolor='black', linewidth=1.5) bar3 = plt.bar([i + 2*bar_width for i in x], [v if v else 0 for v in v3], width=bar_width, label='Third Cosmic Velocity (v3)', color='#009966', edgecolor='black', linewidth=1.5) # Special styling for Moon's v3 (None value) bar3[1].set_hatch('//') bar3[1].set_color('#ff9999') # Enhanced text elements ax.set_ylabel('Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('Comparison of Cosmic Velocities', fontsize=16, fontweight='bold', pad=20, color='black') ax.set_xticks([i + bar_width for i in x]) ax.set_xticklabels(bodies, fontsize=12, fontweight='bold', color='black') # High-visibility legend legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') # Add value labels on bars for bars, offset in zip([bar1, bar2, bar3], [0, bar_width, 2*bar_width]): for i, bar in enumerate(bars): height = bar.get_height() if height > 0: # Only label non-zero bars ax.text(bar.get_x() + bar.get_width()/2., height + 1, f'{height:.1f}', ha='center', va='bottom', fontsize=11, fontweight='bold') # Special annotation for Moon's v3 ax.text(1 + 2*bar_width, 1, 'N/A', ha='center', va='bottom', fontsize=11, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) plt.tight_layout() plt.show() Parameters : Body Mass (kg) Radius (m) Orbital Radius (m) Moon \\(7.342 \\times 10^{22}\\) \\(1.737 \\times 10^6\\) \\(1.496 \\times 10^{11}\\) (Earth's) Mars \\(6.417 \\times 10^{23}\\) \\(3.390 \\times 10^6\\) \\(2.279 \\times 10^{11}\\) Jupiter \\(1.899 \\times 10^{27}\\) \\(6.991 \\times 10^7\\) \\(7.785 \\times 10^{11}\\) Calculated Velocities (km/s) : Body \\(v_1\\) \\(v_2\\) \\(v_3\\) Earth 7.91 11.19 16.64 Moon 1.68 2.38 16.51 Mars 3.55 5.03 13.09 Jupiter 42.14 59.57 9.67","title":"4. Comparison with Moon, Mars, and Jupiter"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-visualizations","text":"","title":"5. Visualizations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#51-cosmic-velocities-comparison","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 M_sun = 1.989e30 # Celestial body parameters: [mass (kg), radius (m), orbital radius (m)] bodies = { 'Earth': [5.972e24, 6.371e6, 1.496e11], 'Moon': [7.342e22, 1.737e6, 1.496e11], 'Mars': [6.417e23, 3.390e6, 2.279e11], 'Jupiter': [1.899e27, 6.991e7, 7.785e11] } # Calculate cosmic velocities velocities = {'v1': {}, 'v2': {}, 'v3': {}} for body, (M, R, R_orbit) in bodies.items(): v1 = np.sqrt(G * M / R) / 1000 v2 = np.sqrt(2 * G * M / R) / 1000 v_esc_sun = np.sqrt(2 * G * M_sun / R_orbit) / 1000 v_orbit = np.sqrt(G * M_sun / R_orbit) / 1000 v3 = np.sqrt(v2**2 + (v_esc_sun - v_orbit)**2) velocities['v1'][body] = v1 velocities['v2'][body] = v2 velocities['v3'][body] = v3 # Plot fig, ax = plt.subplots(figsize=(12, 7)) x = np.arange(len(bodies)) width = 0.25 bars1 = ax.bar(x - width, velocities['v1'].values(), width, label='$v_1$') bars2 = ax.bar(x, velocities['v2'].values(), width, label='$v_2$') bars3 = ax.bar(x + width, velocities['v3'].values(), width, label='$v_3$') # Annotations for bars in [bars1, bars2, bars3]: for bar in bars: height = bar.get_height() ax.annotate(f'{height:.2f}', xy=(bar.get_x() + bar.get_width() / 2, height), xytext=(0, 3), textcoords=\"offset points\", ha='center', va='bottom') ax.set_yscale('log') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (km/s, log scale)') ax.set_title('Cosmic Velocities Comparison') ax.set_xticks(x) ax.set_xticklabels(bodies.keys()) ax.legend() ax.grid(True, alpha=0.3) plt.tight_layout() plt.savefig('cosmic_velocities_comparison.png') plt.show() import numpy as np import matplotlib.pyplot as plt # Constants and data G = 6.67430e-11 bodies = { \"Earth\": {\"R\": 6.371e6, \"M\": 5.97e24}, \"Moon\": {\"R\": 1.74e6, \"M\": 7.35e22}, \"Mars\": {\"R\": 3.39e6, \"M\": 6.42e23}, \"Jupiter\": {\"R\": 7.15e7, \"M\": 1.90e27} } # Calculate values radii = [] v2_values = [] labels = [] for body, data in bodies.items(): R = data[\"R\"] M = data[\"M\"] v2 = np.sqrt(2 * G * M / R) / 1000 radii.append(R / 1e6) v2_values.append(v2) labels.append(body) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced styling bars = plt.bar(labels, v2_values, color=['#0066cc', '#cc3300', '#009966', '#6633cc'], edgecolor='black', linewidth=1.5, width=0.6) # Enhanced text elements ax.set_title('Second Cosmic Velocity (Escape Velocity) vs Planet Radius', fontsize=16, fontweight='bold', pad=20, color='black') ax.set_xlabel('Celestial Body', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_ylabel('Escape Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) # Value labels on bars for bar in bars: height = bar.get_height() ax.text(bar.get_x() + bar.get_width()/2., height + 0.5, f'{height:.1f} km/s', ha='center', va='bottom', fontsize=12, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # X-axis ticks ax.set_xticklabels(labels, fontsize=12, fontweight='bold', color='black') plt.tight_layout() plt.show() import matplotlib.pyplot as plt # Data celestial_bodies = ['Earth', 'Moon', 'Mars', 'Jupiter'] escape_velocities = [16.7, None, 14.1, 18.5] # Third Cosmic Velocity (km/s) # Plot setup with high visibility plt.figure(figsize=(10, 6), facecolor='white') ax = plt.gca() # Bar plot with enhanced visibility bars = plt.bar(celestial_bodies, [vel if vel else 0 for vel in escape_velocities], color=['#0066cc', '#cc3300', '#009966', '#6633cc'], width=0.6, edgecolor='black', linewidth=1.5) # Special marking for Moon (None value) bars[1].set_hatch('//') bars[1].set_color('#ff9999') bars[1].set_edgecolor('black') # Enhanced text elements ax.set_ylabel('Velocity (km/s)', fontsize=14, fontweight='bold', color='black', labelpad=12) ax.set_title('Third Cosmic Velocity Comparison for Celestial Bodies', fontsize=16, fontweight='bold', pad=20, color='black') # X-axis labels ax.set_xticklabels(celestial_bodies, fontsize=12, fontweight='bold', color='black') # Grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2) # High-visibility legend legend = ax.legend(['Third Cosmic Velocity (v3)'], frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1) legend.get_texts()[0].set_color('black') legend.get_texts()[0].set_fontweight('bold') # Add value labels on top of bars for bar in bars: height = bar.get_height() if height > 0: # Only label non-zero bars ax.text(bar.get_x() + bar.get_width()/2., height + 0.5, f'{height:.1f}', ha='center', va='bottom', fontsize=12, fontweight='bold') # Special annotation for Moon ax.text(bars[1].get_x() + bars[1].get_width()/2., 1, 'N/A', ha='center', va='bottom', fontsize=12, fontweight='bold', color='black') plt.tight_layout() plt.show()","title":"5.1 Cosmic Velocities Comparison"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Theoretical Analysis 1. Equations of Motion The payload's trajectory is governed by Newton's Law of Gravitation and Newton's Second Law : Newton's Law of Gravitation : \\(\\mathbf{F} = -\\frac{GMm}{r^2}\\hat{\\mathbf{r}}\\) where: - \\(G\\) = Gravitational constant ( \\(6.674 \\times 10^{-11}\\,\\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) ) - \\(M\\) = Mass of Earth ( \\(5.972 \\times 10^{24}\\,\\text{kg}\\) ) - \\(m\\) = Mass of payload (neglected for trajectory analysis) - \\(r\\) = Distance between payload and Earth's center Equation of Motion (2D Polar Coordinates) : \\(\\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3}\\mathbf{r}\\) Decomposed into Cartesian coordinates ( \\(x, y\\) ): \\(\\frac{d^2x}{dt^2} = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{(x^2 + y^2)^{3/2}}\\) 2. Trajectory Types The shape of the orbit depends on the specific orbital energy ( \\(E\\) ) and eccentricity ( \\(e\\) ): Elliptical Orbit ( \\(E < 0\\) , \\(0 \\leq e < 1\\) ): Bound orbit (e.g., satellites) Initial velocity below escape velocity: \\(v < v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}}\\) Parabolic Orbit ( \\(E = 0\\) , \\(e = 1\\) ): Escape trajectory (minimum escape condition) Initial velocity equals escape velocity: \\(v = v_{\\text{esc}}\\) Hyperbolic Orbit ( \\(E > 0\\) , \\(e > 1\\) ): Unbound trajectory (e.g., interplanetary probes) Initial velocity exceeds escape velocity: \\(v > v_{\\text{esc}}\\) 3. Initial Velocity Impact Key velocity thresholds for a payload at altitude \\(h = r - R_E\\) (Earth's radius \\(R_E = 6371\\,\\text{km}\\) ): Scenario Velocity Condition Outcome Suborbital \\(v < \\sqrt{\\frac{GM}{r}}\\) Reentry (ballistic trajectory) Circular Orbit \\(v = \\sqrt{\\frac{GM}{r}}\\) Stable orbit Elliptical Orbit \\(\\sqrt{\\frac{GM}{r}} < v < v_{\\text{esc}}\\) Apogee/perigee variation Escape \\(v \\geq v_{\\text{esc}}\\) Leaves Earth's influence Note : - Orbital Insertion : Requires precise \\(v\\) to match desired orbit - Reentry : Achieved by reducing \\(v\\) (e.g., retrograde thrust or atmospheric drag) - Escape : Requires \\(v \\geq \\sqrt{\\frac{2GM}{r}}\\) (parabolic/hyperbolic) Python Code Snippet (Symbolic Derivation) import sympy as sp # Define variables t, G, M = sp.symbols('t G M') x, y = sp.Function('x')(t), sp.Function('y')(t) # Equations of motion eq1 = sp.Eq(sp.diff(x, t, 2), -G * M * x / (x**2 + y**2)**(3/2)) eq2 = sp.Eq(sp.diff(y, t, 2), -G * M * y / (x**2 + y**2)**(3/2)) print(\"Equation for x:\", eq1) print(\"Equation for y:\", eq2) Numerical Simulation Setup 1. Initial Conditions We define the payload's initial state in Cartesian coordinates: Position : \\( \\(x_0=(R_E+h)\\cos\\theta\\) \\) \\( \\(y_0=(R_E+h)\\sin\\theta\\) \\) where: - \\(R_E=6371\\,\\text{km}\\) (Earth's radius) - \\(h\\) =altitude above surface - \\(\\theta\\) =angular position from reference axis Velocity : \\( \\(v_{x0}=v_0\\cos\\phi\\) \\) \\( \\(v_{y0}=v_0\\sin\\phi\\) \\) where: - \\(v_0\\) =initial speed - \\(\\phi\\) =launch angle from horizontal 2. Numerical Method Selection We solve the coupled ODEs using the 4th-order Runge-Kutta method (RK4) for higher accuracy: The general RK4 formulation for \\(\\frac{dy}{dt}=f(t,y)\\) : \\(k_1=f(t_n,y_n)\\) \\(k_2=f(t_n+\\frac{h}{2},y_n+\\frac{h}{2}k_1)\\) \\(k_3=f(t_n+\\frac{h}{2},y_n+\\frac{h}{2}k_2)\\) \\(k_4=f(t_n+h,y_n+hk_3)\\) \\(y_{n+1}=y_n+\\frac{h}{6}(k_1+2k_2+2k_3+k_4)\\) S 3. Implementation Framework Python Implementation import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_E = 6371e3 # m def equations_of_motion(t, state): \"\"\"ODE system for payload trajectory\"\"\" x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] def simulate_trajectory(h, v0, theta, phi, t_span, dt): \"\"\"Run trajectory simulation\"\"\" # Initial conditions r0 = R_E + h x0 = r0 * np.cos(theta) y0 = r0 * np.sin(theta) vx0 = v0 * np.cos(phi) vy0 = v0 * np.sin(phi) # Time points t_eval = np.arange(t_span[0], t_span[1], dt) # Solve ODE sol = solve_ivp(equations_of_motion, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') return sol # Example usage h = 500e3 # 500 km altitude v0 = 7.5e3 # 7.5 km/s theta = 0 # Initial angle phi = np.pi/4 # 45 degree launch angle t_span = [0, 3600*2] # 2 hour simulation dt = 10 # 10 second timestep solution = simulate_trajectory(h, v0, theta, phi, t_span, dt) \ud83d\udcd8 Projectile Motion Simulation \u2014 Computational Implementation \ud83c\udfaf Objective To simulate the trajectory of a projectile under idealized physics using Python, with adjustable parameters such as: Initial speed \\(v_0\\) Launch angle \\(\\theta\\) Initial height \\(h_0\\) Gravitational acceleration \\(g\\) \ud83e\uddee Governing Equations The equations of motion for a projectile launched at an angle \\(\\theta\\) from an initial height \\(h_0\\) are: Horizontal velocity: $$ v_x = v_0\\cos(\\theta) $$ Vertical velocity: $$ v_y = v_0\\sin(\\theta) $$ Position as a function of time: $$ x(t) = v_0\\cos(\\theta)\\cdot t $$ $$ y(t) = h_0 + v_0\\sin(\\theta)\\cdot t - \\frac{1}{2}gt^2 $$ Time of flight (solving \\(y(t) = 0\\) ): $$ t = \\frac{v_0\\sin(\\theta)}{g} + \\sqrt{\\left(\\frac{v_0\\sin(\\theta)}{g}\\right)^2 + \\frac{2h_0}{g}} $$ \ud83e\uddf0 Required Libraries numpy \u2013 numerical calculations matplotlib.pyplot \u2013 visualization \ud83e\uddea Python Code Implementation import numpy as np import matplotlib.pyplot as plt # Adjustable parameters v0 = 30 # Initial speed (m/s) theta_deg = 45 # Launch angle in degrees h0 = 0 # Initial height (m) g = 9.81 # Gravity (m/s^2) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight t_flight = (v0 * np.sin(theta) / g) + np.sqrt((v0 * np.sin(theta) / g) ** 2 + (2 * h0 / g)) # Time points t = np.linspace(0, t_flight, num=500) # Position calculations x = v0 * np.cos(theta) * t y = h0 + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot trajectory plt.figure(figsize=(10, 5)) plt.plot(x, y, label=f'{v0} m/s at {theta_deg}\u00b0') plt.title('Projectile Motion Simulation') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.axhline(0, color='gray', linestyle='--', linewidth=0.7) plt.legend() plt.show() \ud83c\udf0d Trajectory Visualization \u2014 Orbital Mechanics \ud83d\ude80 Objective To visualize the trajectory of a payload launched from Earth under different initial velocity conditions: Suborbital Orbital Escape trajectory \ud83c\udfaf Key Features Plot the trajectory of the payload relative to Earth Highlight: Perigee : Closest approach to Earth Apogee : Farthest point in bound trajectory Escape condition : Payload escapes Earth's gravity Compare different initial velocities and their effects \ud83e\uddee Governing Equations We assume: Two-body problem (Earth and payload) Only gravitational force acts (no atmosphere, no thrust) Let: \\(G\\) = gravitational constant \\(M\\) = mass of Earth \\(r\\) = radial distance from Earth's center \\(v\\) = speed \\(\\mu=GM\\) = standard gravitational parameter Kinetic and Potential Energy Kinetic energy per unit mass: \\(KE=\\frac{1}{2}v^2\\) Gravitational potential energy per unit mass: \\(PE=-\\frac{\\mu}{r}\\) Total specific energy: \\(\\varepsilon=KE+PE=\\frac{1}{2}v^2-\\frac{\\mu}{r}\\) Trajectory Type If \\(\\varepsilon<0\\) : Bound (elliptical) \u2013 orbital or suborbital If \\(\\varepsilon=0\\) : Parabolic escape If \\(\\varepsilon>0\\) : Hyperbolic escape \ud83e\uddf0 Required Libraries numpy \u2013 numerical integration and array math matplotlib \u2013 for plotting scipy.integrate \u2013 to solve equations of motion \ud83e\uddea Python Code Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Earth mass (kg) mu = G * M R_earth = 6.371e6 # Earth radius in meters # Initial conditions altitude = 300e3 # 300 km above Earth's surface r0 = R_earth + altitude theta0 = 0 positions = [] labels = [] # Different initial velocities (m/s) v_suborbital = 6500 # Less than orbital v_orbital = np.sqrt(mu / r0) # Circular orbit speed v_escape = np.sqrt(2 * mu / r0) # Escape velocity initial_scenarios = [ (\"Suborbital\", v_suborbital), (\"Orbital\", v_orbital), (\"Escape\", v_escape) ] # Equations of motion in polar coordinates def orbital_dynamics(t, y): x, y_, vx, vy = y r = np.sqrt(x**2 + y_**2) ax = -mu * x / r**3 ay = -mu * y_ / r**3 return [vx, vy, ax, ay] # Time span for simulation t_span = (0, 6000) t_eval = np.linspace(t_span[0], t_span[1], 5000) # Solve and plot each scenario plt.figure(figsize=(8, 8)) for label, v0 in initial_scenarios: y0 = [r0, 0, 0, v0] # [x, y, vx, vy] sol = solve_ivp(orbital_dynamics, t_span, y0, t_eval=t_eval, rtol=1e-8) x = sol.y[0] y = sol.y[1] plt.plot(x / 1e3, y / 1e3, label=f\"{label} ({v0:.0f} m/s)\") # Plot Earth theta = np.linspace(0, 2*np.pi, 1000) earth_x = R_earth * np.cos(theta) / 1e3 earth_y = R_earth * np.sin(theta) / 1e3 plt.fill(earth_x, earth_y, 'lightblue', label='Earth') # Plot formatting plt.title(\"Trajectory Visualization: Suborbital, Orbital, Escape\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show() \ud83e\udde0 Analysis & Discussion \u2014 Orbital Trajectory Behavior \ud83d\udd04 Impact of Varying Initial Conditions \ud83d\udea6 Initial Speed The trajectory of a payload launched from Earth depends critically on its initial velocity ( \\(v_0\\) ) : If \\(v_0<\\sqrt{\\frac{\\mu}{r_0}}\\) : Trajectory is suborbital Payload returns to Earth after reaching maximum altitude (like ballistic missile) If \\(v_0=\\sqrt{\\frac{\\mu}{r_0}}\\) : Trajectory is circular orbit Stable orbit at constant altitude If \\(v_0\\) is such that \\(0<\\varepsilon<0\\) : Elliptical orbit , where perigee and apogee differ If \\(v_0=\\sqrt{\\frac{2\\mu}{r_0}}\\) : Parabolic trajectory (escape) If \\(v_0>\\sqrt{\\frac{2\\mu}{r_0}}\\) : Hyperbolic escape from Earth's gravity Here, \\(\\mu=GM\\) is the standard gravitational parameter, and \\(r_0\\) is the initial radial distance from Earth\u2019s center. \ud83c\udf10 Real-World Applications Trajectory Type Application Example Suborbital Space tourism, sounding rockets Circular Orbit Low Earth Orbit (LEO) satellites Elliptical Orbit Molniya orbits, Geostationary Transfer Orbit Escape Interplanetary missions (e.g., Voyager, JWST) \ud83d\udd2c Validation Against Orbital Mechanics We validate the numerical simulations using known orbital mechanics principles , including Kepler\u2019s Laws : 1. Kepler\u2019s First Law Every planet moves in an ellipse with the Sun (or Earth) at one focus. For bound orbits ( \\(\\varepsilon<0\\) ), our simulated trajectories are elliptical. For \\(v_0=\\sqrt{\\mu/r_0}\\) , the orbit becomes a special case: a circle . 2. Kepler\u2019s Second Law A line joining a planet and the Sun sweeps out equal areas in equal times. Since gravity is a central force , angular momentum is conserved: \\( \\(\\vec{r}\\times\\vec{v}=\\text{constant}\\) \\) Numerically, this is evident as orbital speed increases at perigee and decreases at apogee. 3. Kepler\u2019s Third Law The square of the orbital period is proportional to the cube of the semi-major axis: \\( \\(T^2\\propto a^3\\) \\) For circular orbits: \\( \\(T=2\\pi\\sqrt{\\frac{r_0^3}{\\mu}}\\) \\) Simulation-derived periods match this analytical value closely. \u2705 Takeaways Initial velocity is the primary control variable for trajectory shaping. The simulated motion adheres to Keplerian dynamics under ideal conditions. Such tools are vital in: Mission planning Satellite deployment strategies Trajectory correction maneuvers Reentry analysis for crewed missions \ud83d\udcd8 Further Enhancements Include atmospheric drag for low-altitude missions. Account for Earth\u2019s rotation and non-spherical mass distribution . Add thrust profiles for real rocket burns and transfers (e.g., Hohmann transfers). \ud83d\udcc4 Trajectory Simulation: Methodology and Findings \ud83e\uddf0 1. Methodology Overview We analyze the motion of a payload launched from Earth under varying initial speeds. The goal is to understand how different initial velocities affect orbital trajectories. \ud83d\udd27 Assumptions: Two-body system: Earth and payload. No atmospheric drag or thrust during flight. Earth is a perfect sphere. Gravitational force is central and inverse-square. Let: \\(G\\) : Gravitational constant \\(M\\) : Mass of Earth \\(\\mu=GM\\) : Standard gravitational parameter \\(r\\) : Radial distance from Earth's center \\(v\\) : Speed of payload \\(\\varepsilon\\) : Specific mechanical energy import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.97e24 # Mass of Earth (kg) radius_earth = 6.371e6 # Radius of Earth (m) # Time parameters dt = 100 # Time step (seconds) T = 3600 * 24 # Total time of simulation (1 day) # Initial conditions: (initial position, initial velocity) initial_conditions = { 'x0': 1.5 * radius_earth, # 1.5 Earth radii from Earth's center (m) 'y0': 0, # Along the x-axis (horizontal direction) 'vx0': 0, # Initial velocity in x-direction (m/s) 'vy0': 5000 # Initial velocity in y-direction (m/s) } # Function to compute acceleration due to gravity def gravity_acceleration(x, y): r = np.sqrt(x**2 + y**2) # Fixed: Correct distance from Earth's center a = -G * M / r**2 # Gravitational acceleration ax = a * x / r # Acceleration in x-direction ay = a * y / r # Acceleration in y-direction return ax, ay # Initialize position and velocity arrays x, y = [initial_conditions['x0']], [initial_conditions['y0']] vx, vy = [initial_conditions['vx0']], [initial_conditions['vy0']] # Numerical integration using Euler's method for t in np.arange(0, T, dt): ax, ay = gravity_acceleration(x[-1], y[-1]) # Get acceleration at current position # Update velocities vx.append(vx[-1] + ax * dt) vy.append(vy[-1] + ay * dt) # Update positions x.append(x[-1] + vx[-1] * dt) y.append(y[-1] + vy[-1] * dt) # Convert the results into numpy arrays for easier plotting x = np.array(x) y = np.array(y) # Plot setup with high-visibility and cool styling plt.figure(figsize=(8, 6), facecolor='white') ax = plt.gca() # Plot the trajectory with vibrant styling plt.plot(x / 1e3, y / 1e3, color='#0066cc', linewidth=3, label='Payload Trajectory', linestyle='-', alpha=0.9) plt.scatter([0], [0], color='#cc3300', s=150, edgecolor='black', linewidth=2, label='Earth', marker='o', zorder=5) # Add a cool gradient-like effect to the trajectory plt.plot(x / 1e3, y / 1e3, color='#009966', linewidth=1.5, linestyle='--', alpha=0.5) # Enhanced text elements with bold, modern fonts ax.set_xlabel('X Position (km)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_ylabel('Y Position (km)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_title('Payload Trajectory Near Earth', fontsize=18, fontweight='bold', pad=20, color='black', family='Arial') # High-visibility legend with a sleek look legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1, loc='upper right') for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') text.set_fontfamily('Arial') # Add a subtle annotation for the starting point ax.annotate('Start', xy=(x[0] / 1e3, y[0] / 1e3), xytext=(x[0] / 1e3 + 500, y[0] / 1e3 + 500), arrowprops=dict(facecolor='black', arrowstyle='->'), fontsize=10, fontweight='bold', color='black', family='Arial') # Cool grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) ax.xaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2.5) # Set a sleek background and axis styling ax.set_facecolor('#f5f5f5') plt.axis('equal') plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R = 6.371e6 # radius of Earth in meters altitude = 800e3 # 800 km above the surface initial_distance = R + altitude time_step = 1 # seconds total_time = 7000 # simulate up to 7000 seconds n_steps = int(total_time / time_step) # Initial velocities in m/s velocities = np.arange(5000, 13500, 500) # from 5 km/s to 13 km/s # Plot setup with high-visibility and cool styling plt.figure(figsize=(10, 10), facecolor='white') ax = plt.gca() # Create Earth plot with enhanced styling theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) earth_y = R * np.sin(theta) plt.fill(earth_x, earth_y, color='#0066cc', alpha=0.6, edgecolor='black', linewidth=2, label='Earth') # Function to compute gravity acceleration def gravity(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # Simulate each trajectory with distinct colors colors = ['#cc3300', '#009966', '#ff6600', '#660099', '#ff3399', '#006666', '#cc9900', '#990000', '#00cc99', '#ff9933', '#3333cc', '#ff0066', '#669900', '#9900cc', '#00ff66', '#cc0066'] for i, v in enumerate(velocities): pos = np.array([initial_distance, 0.0]) vel = np.array([0.0, v]) traj = [] for _ in range(n_steps): acc = gravity(pos) vel += acc * time_step pos += vel * time_step traj.append(pos.copy()) if np.linalg.norm(pos) <= R: break traj = np.array(traj) plt.plot(traj[:, 0], traj[:, 1], color=colors[i % len(colors)], linewidth=2.5, label=f'{v/1000:.1f} km/s', alpha=0.9) # Plot center of Earth plt.scatter([0], [0], color='black', s=100, edgecolor='black', linewidth=2, marker='o', label='Center of Earth', zorder=5) # Add annotation for starting point plt.annotate('Start', xy=(initial_distance, 0), xytext=(initial_distance + 1e6, 0.5e6), arrowprops=dict(facecolor='black', arrowstyle='->'), fontsize=10, fontweight='bold', color='black', family='Arial') # Enhanced text elements with bold, modern fonts ax.set_xlabel('X Position (m)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_ylabel('Y Position (m)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_title('Trajectories of Objects from 800 km Altitude with Varying Speeds', fontsize=18, fontweight='bold', pad=20, color='black', family='Arial') # High-visibility legend with a sleek look legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=10, borderpad=1, loc='upper right') for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') text.set_fontfamily('Arial') # Cool grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) ax.xaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2.5) # Set a sleek background and axis styling ax.set_facecolor('#f5f5f5') plt.axis('equal') plt.tight_layout() plt.savefig('multi_trajectory_plot.png')","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-analysis","text":"","title":"Theoretical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-equations-of-motion","text":"The payload's trajectory is governed by Newton's Law of Gravitation and Newton's Second Law : Newton's Law of Gravitation : \\(\\mathbf{F} = -\\frac{GMm}{r^2}\\hat{\\mathbf{r}}\\) where: - \\(G\\) = Gravitational constant ( \\(6.674 \\times 10^{-11}\\,\\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) ) - \\(M\\) = Mass of Earth ( \\(5.972 \\times 10^{24}\\,\\text{kg}\\) ) - \\(m\\) = Mass of payload (neglected for trajectory analysis) - \\(r\\) = Distance between payload and Earth's center Equation of Motion (2D Polar Coordinates) : \\(\\frac{d^2\\mathbf{r}}{dt^2} = -\\frac{GM}{r^3}\\mathbf{r}\\) Decomposed into Cartesian coordinates ( \\(x, y\\) ): \\(\\frac{d^2x}{dt^2} = -\\frac{GMx}{(x^2 + y^2)^{3/2}}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{(x^2 + y^2)^{3/2}}\\)","title":"1. Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-trajectory-types","text":"The shape of the orbit depends on the specific orbital energy ( \\(E\\) ) and eccentricity ( \\(e\\) ): Elliptical Orbit ( \\(E < 0\\) , \\(0 \\leq e < 1\\) ): Bound orbit (e.g., satellites) Initial velocity below escape velocity: \\(v < v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}}\\) Parabolic Orbit ( \\(E = 0\\) , \\(e = 1\\) ): Escape trajectory (minimum escape condition) Initial velocity equals escape velocity: \\(v = v_{\\text{esc}}\\) Hyperbolic Orbit ( \\(E > 0\\) , \\(e > 1\\) ): Unbound trajectory (e.g., interplanetary probes) Initial velocity exceeds escape velocity: \\(v > v_{\\text{esc}}\\)","title":"2. Trajectory Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-initial-velocity-impact","text":"Key velocity thresholds for a payload at altitude \\(h = r - R_E\\) (Earth's radius \\(R_E = 6371\\,\\text{km}\\) ): Scenario Velocity Condition Outcome Suborbital \\(v < \\sqrt{\\frac{GM}{r}}\\) Reentry (ballistic trajectory) Circular Orbit \\(v = \\sqrt{\\frac{GM}{r}}\\) Stable orbit Elliptical Orbit \\(\\sqrt{\\frac{GM}{r}} < v < v_{\\text{esc}}\\) Apogee/perigee variation Escape \\(v \\geq v_{\\text{esc}}\\) Leaves Earth's influence Note : - Orbital Insertion : Requires precise \\(v\\) to match desired orbit - Reentry : Achieved by reducing \\(v\\) (e.g., retrograde thrust or atmospheric drag) - Escape : Requires \\(v \\geq \\sqrt{\\frac{2GM}{r}}\\) (parabolic/hyperbolic)","title":"3. Initial Velocity Impact"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-snippet-symbolic-derivation","text":"import sympy as sp # Define variables t, G, M = sp.symbols('t G M') x, y = sp.Function('x')(t), sp.Function('y')(t) # Equations of motion eq1 = sp.Eq(sp.diff(x, t, 2), -G * M * x / (x**2 + y**2)**(3/2)) eq2 = sp.Eq(sp.diff(y, t, 2), -G * M * y / (x**2 + y**2)**(3/2)) print(\"Equation for x:\", eq1) print(\"Equation for y:\", eq2)","title":"Python Code Snippet (Symbolic Derivation)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-setup","text":"","title":"Numerical Simulation Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-initial-conditions","text":"We define the payload's initial state in Cartesian coordinates: Position : \\( \\(x_0=(R_E+h)\\cos\\theta\\) \\) \\( \\(y_0=(R_E+h)\\sin\\theta\\) \\) where: - \\(R_E=6371\\,\\text{km}\\) (Earth's radius) - \\(h\\) =altitude above surface - \\(\\theta\\) =angular position from reference axis Velocity : \\( \\(v_{x0}=v_0\\cos\\phi\\) \\) \\( \\(v_{y0}=v_0\\sin\\phi\\) \\) where: - \\(v_0\\) =initial speed - \\(\\phi\\) =launch angle from horizontal","title":"1. Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-numerical-method-selection","text":"We solve the coupled ODEs using the 4th-order Runge-Kutta method (RK4) for higher accuracy: The general RK4 formulation for \\(\\frac{dy}{dt}=f(t,y)\\) : \\(k_1=f(t_n,y_n)\\) \\(k_2=f(t_n+\\frac{h}{2},y_n+\\frac{h}{2}k_1)\\) \\(k_3=f(t_n+\\frac{h}{2},y_n+\\frac{h}{2}k_2)\\) \\(k_4=f(t_n+h,y_n+hk_3)\\) \\(y_{n+1}=y_n+\\frac{h}{6}(k_1+2k_2+2k_3+k_4)\\) S","title":"2. Numerical Method Selection"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-implementation-framework","text":"","title":"3. Implementation Framework"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # kg R_E = 6371e3 # m def equations_of_motion(t, state): \"\"\"ODE system for payload trajectory\"\"\" x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] def simulate_trajectory(h, v0, theta, phi, t_span, dt): \"\"\"Run trajectory simulation\"\"\" # Initial conditions r0 = R_E + h x0 = r0 * np.cos(theta) y0 = r0 * np.sin(theta) vx0 = v0 * np.cos(phi) vy0 = v0 * np.sin(phi) # Time points t_eval = np.arange(t_span[0], t_span[1], dt) # Solve ODE sol = solve_ivp(equations_of_motion, t_span, [x0, y0, vx0, vy0], t_eval=t_eval, method='RK45') return sol # Example usage h = 500e3 # 500 km altitude v0 = 7.5e3 # 7.5 km/s theta = 0 # Initial angle phi = np.pi/4 # 45 degree launch angle t_span = [0, 3600*2] # 2 hour simulation dt = 10 # 10 second timestep solution = simulate_trajectory(h, v0, theta, phi, t_span, dt)","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#projectile-motion-simulation-computational-implementation","text":"","title":"\ud83d\udcd8 Projectile Motion Simulation \u2014 Computational Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective","text":"To simulate the trajectory of a projectile under idealized physics using Python, with adjustable parameters such as: Initial speed \\(v_0\\) Launch angle \\(\\theta\\) Initial height \\(h_0\\) Gravitational acceleration \\(g\\)","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations","text":"The equations of motion for a projectile launched at an angle \\(\\theta\\) from an initial height \\(h_0\\) are: Horizontal velocity: $$ v_x = v_0\\cos(\\theta) $$ Vertical velocity: $$ v_y = v_0\\sin(\\theta) $$ Position as a function of time: $$ x(t) = v_0\\cos(\\theta)\\cdot t $$ $$ y(t) = h_0 + v_0\\sin(\\theta)\\cdot t - \\frac{1}{2}gt^2 $$ Time of flight (solving \\(y(t) = 0\\) ): $$ t = \\frac{v_0\\sin(\\theta)}{g} + \\sqrt{\\left(\\frac{v_0\\sin(\\theta)}{g}\\right)^2 + \\frac{2h_0}{g}} $$","title":"\ud83e\uddee Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#required-libraries","text":"numpy \u2013 numerical calculations matplotlib.pyplot \u2013 visualization","title":"\ud83e\uddf0 Required Libraries"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Adjustable parameters v0 = 30 # Initial speed (m/s) theta_deg = 45 # Launch angle in degrees h0 = 0 # Initial height (m) g = 9.81 # Gravity (m/s^2) # Convert angle to radians theta = np.radians(theta_deg) # Time of flight t_flight = (v0 * np.sin(theta) / g) + np.sqrt((v0 * np.sin(theta) / g) ** 2 + (2 * h0 / g)) # Time points t = np.linspace(0, t_flight, num=500) # Position calculations x = v0 * np.cos(theta) * t y = h0 + v0 * np.sin(theta) * t - 0.5 * g * t**2 # Plot trajectory plt.figure(figsize=(10, 5)) plt.plot(x, y, label=f'{v0} m/s at {theta_deg}\u00b0') plt.title('Projectile Motion Simulation') plt.xlabel('Horizontal Distance (m)') plt.ylabel('Vertical Height (m)') plt.grid(True) plt.axhline(0, color='gray', linestyle='--', linewidth=0.7) plt.legend() plt.show()","title":"\ud83e\uddea Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-visualization-orbital-mechanics","text":"","title":"\ud83c\udf0d Trajectory Visualization \u2014 Orbital Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#objective_1","text":"To visualize the trajectory of a payload launched from Earth under different initial velocity conditions: Suborbital Orbital Escape trajectory","title":"\ud83d\ude80 Objective"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-features","text":"Plot the trajectory of the payload relative to Earth Highlight: Perigee : Closest approach to Earth Apogee : Farthest point in bound trajectory Escape condition : Payload escapes Earth's gravity Compare different initial velocities and their effects","title":"\ud83c\udfaf Key Features"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-equations_1","text":"We assume: Two-body problem (Earth and payload) Only gravitational force acts (no atmosphere, no thrust) Let: \\(G\\) = gravitational constant \\(M\\) = mass of Earth \\(r\\) = radial distance from Earth's center \\(v\\) = speed \\(\\mu=GM\\) = standard gravitational parameter","title":"\ud83e\uddee Governing Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#kinetic-and-potential-energy","text":"Kinetic energy per unit mass: \\(KE=\\frac{1}{2}v^2\\) Gravitational potential energy per unit mass: \\(PE=-\\frac{\\mu}{r}\\) Total specific energy: \\(\\varepsilon=KE+PE=\\frac{1}{2}v^2-\\frac{\\mu}{r}\\)","title":"Kinetic and Potential Energy"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-type","text":"If \\(\\varepsilon<0\\) : Bound (elliptical) \u2013 orbital or suborbital If \\(\\varepsilon=0\\) : Parabolic escape If \\(\\varepsilon>0\\) : Hyperbolic escape","title":"Trajectory Type"},{"location":"1%20Physics/2%20Gravity/Problem_3/#required-libraries_1","text":"numpy \u2013 numerical integration and array math matplotlib \u2013 for plotting scipy.integrate \u2013 to solve equations of motion","title":"\ud83e\uddf0 Required Libraries"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-code-implementation_1","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (m^3/kg/s^2) M = 5.972e24 # Earth mass (kg) mu = G * M R_earth = 6.371e6 # Earth radius in meters # Initial conditions altitude = 300e3 # 300 km above Earth's surface r0 = R_earth + altitude theta0 = 0 positions = [] labels = [] # Different initial velocities (m/s) v_suborbital = 6500 # Less than orbital v_orbital = np.sqrt(mu / r0) # Circular orbit speed v_escape = np.sqrt(2 * mu / r0) # Escape velocity initial_scenarios = [ (\"Suborbital\", v_suborbital), (\"Orbital\", v_orbital), (\"Escape\", v_escape) ] # Equations of motion in polar coordinates def orbital_dynamics(t, y): x, y_, vx, vy = y r = np.sqrt(x**2 + y_**2) ax = -mu * x / r**3 ay = -mu * y_ / r**3 return [vx, vy, ax, ay] # Time span for simulation t_span = (0, 6000) t_eval = np.linspace(t_span[0], t_span[1], 5000) # Solve and plot each scenario plt.figure(figsize=(8, 8)) for label, v0 in initial_scenarios: y0 = [r0, 0, 0, v0] # [x, y, vx, vy] sol = solve_ivp(orbital_dynamics, t_span, y0, t_eval=t_eval, rtol=1e-8) x = sol.y[0] y = sol.y[1] plt.plot(x / 1e3, y / 1e3, label=f\"{label} ({v0:.0f} m/s)\") # Plot Earth theta = np.linspace(0, 2*np.pi, 1000) earth_x = R_earth * np.cos(theta) / 1e3 earth_y = R_earth * np.sin(theta) / 1e3 plt.fill(earth_x, earth_y, 'lightblue', label='Earth') # Plot formatting plt.title(\"Trajectory Visualization: Suborbital, Orbital, Escape\") plt.xlabel(\"X Position (km)\") plt.ylabel(\"Y Position (km)\") plt.axis('equal') plt.grid(True) plt.legend() plt.show()","title":"\ud83e\uddea Python Code Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#analysis-discussion-orbital-trajectory-behavior","text":"","title":"\ud83e\udde0 Analysis &amp; Discussion \u2014 Orbital Trajectory Behavior"},{"location":"1%20Physics/2%20Gravity/Problem_3/#impact-of-varying-initial-conditions","text":"","title":"\ud83d\udd04 Impact of Varying Initial Conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-speed","text":"The trajectory of a payload launched from Earth depends critically on its initial velocity ( \\(v_0\\) ) : If \\(v_0<\\sqrt{\\frac{\\mu}{r_0}}\\) : Trajectory is suborbital Payload returns to Earth after reaching maximum altitude (like ballistic missile) If \\(v_0=\\sqrt{\\frac{\\mu}{r_0}}\\) : Trajectory is circular orbit Stable orbit at constant altitude If \\(v_0\\) is such that \\(0<\\varepsilon<0\\) : Elliptical orbit , where perigee and apogee differ If \\(v_0=\\sqrt{\\frac{2\\mu}{r_0}}\\) : Parabolic trajectory (escape) If \\(v_0>\\sqrt{\\frac{2\\mu}{r_0}}\\) : Hyperbolic escape from Earth's gravity Here, \\(\\mu=GM\\) is the standard gravitational parameter, and \\(r_0\\) is the initial radial distance from Earth\u2019s center.","title":"\ud83d\udea6 Initial Speed"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-applications","text":"Trajectory Type Application Example Suborbital Space tourism, sounding rockets Circular Orbit Low Earth Orbit (LEO) satellites Elliptical Orbit Molniya orbits, Geostationary Transfer Orbit Escape Interplanetary missions (e.g., Voyager, JWST)","title":"\ud83c\udf10 Real-World Applications"},{"location":"1%20Physics/2%20Gravity/Problem_3/#validation-against-orbital-mechanics","text":"We validate the numerical simulations using known orbital mechanics principles , including Kepler\u2019s Laws :","title":"\ud83d\udd2c Validation Against Orbital Mechanics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-keplers-first-law","text":"Every planet moves in an ellipse with the Sun (or Earth) at one focus. For bound orbits ( \\(\\varepsilon<0\\) ), our simulated trajectories are elliptical. For \\(v_0=\\sqrt{\\mu/r_0}\\) , the orbit becomes a special case: a circle .","title":"1. Kepler\u2019s First Law"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-keplers-second-law","text":"A line joining a planet and the Sun sweeps out equal areas in equal times. Since gravity is a central force , angular momentum is conserved: \\( \\(\\vec{r}\\times\\vec{v}=\\text{constant}\\) \\) Numerically, this is evident as orbital speed increases at perigee and decreases at apogee.","title":"2. Kepler\u2019s Second Law"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-keplers-third-law","text":"The square of the orbital period is proportional to the cube of the semi-major axis: \\( \\(T^2\\propto a^3\\) \\) For circular orbits: \\( \\(T=2\\pi\\sqrt{\\frac{r_0^3}{\\mu}}\\) \\) Simulation-derived periods match this analytical value closely.","title":"3. Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_3/#takeaways","text":"Initial velocity is the primary control variable for trajectory shaping. The simulated motion adheres to Keplerian dynamics under ideal conditions. Such tools are vital in: Mission planning Satellite deployment strategies Trajectory correction maneuvers Reentry analysis for crewed missions","title":"\u2705 Takeaways"},{"location":"1%20Physics/2%20Gravity/Problem_3/#further-enhancements","text":"Include atmospheric drag for low-altitude missions. Account for Earth\u2019s rotation and non-spherical mass distribution . Add thrust profiles for real rocket burns and transfers (e.g., Hohmann transfers).","title":"\ud83d\udcd8 Further Enhancements"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectory-simulation-methodology-and-findings","text":"","title":"\ud83d\udcc4 Trajectory Simulation: Methodology and Findings"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-methodology-overview","text":"We analyze the motion of a payload launched from Earth under varying initial speeds. The goal is to understand how different initial velocities affect orbital trajectories.","title":"\ud83e\uddf0 1. Methodology Overview"},{"location":"1%20Physics/2%20Gravity/Problem_3/#assumptions","text":"Two-body system: Earth and payload. No atmospheric drag or thrust during flight. Earth is a perfect sphere. Gravitational force is central and inverse-square. Let: \\(G\\) : Gravitational constant \\(M\\) : Mass of Earth \\(\\mu=GM\\) : Standard gravitational parameter \\(r\\) : Radial distance from Earth's center \\(v\\) : Speed of payload \\(\\varepsilon\\) : Specific mechanical energy import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.97e24 # Mass of Earth (kg) radius_earth = 6.371e6 # Radius of Earth (m) # Time parameters dt = 100 # Time step (seconds) T = 3600 * 24 # Total time of simulation (1 day) # Initial conditions: (initial position, initial velocity) initial_conditions = { 'x0': 1.5 * radius_earth, # 1.5 Earth radii from Earth's center (m) 'y0': 0, # Along the x-axis (horizontal direction) 'vx0': 0, # Initial velocity in x-direction (m/s) 'vy0': 5000 # Initial velocity in y-direction (m/s) } # Function to compute acceleration due to gravity def gravity_acceleration(x, y): r = np.sqrt(x**2 + y**2) # Fixed: Correct distance from Earth's center a = -G * M / r**2 # Gravitational acceleration ax = a * x / r # Acceleration in x-direction ay = a * y / r # Acceleration in y-direction return ax, ay # Initialize position and velocity arrays x, y = [initial_conditions['x0']], [initial_conditions['y0']] vx, vy = [initial_conditions['vx0']], [initial_conditions['vy0']] # Numerical integration using Euler's method for t in np.arange(0, T, dt): ax, ay = gravity_acceleration(x[-1], y[-1]) # Get acceleration at current position # Update velocities vx.append(vx[-1] + ax * dt) vy.append(vy[-1] + ay * dt) # Update positions x.append(x[-1] + vx[-1] * dt) y.append(y[-1] + vy[-1] * dt) # Convert the results into numpy arrays for easier plotting x = np.array(x) y = np.array(y) # Plot setup with high-visibility and cool styling plt.figure(figsize=(8, 6), facecolor='white') ax = plt.gca() # Plot the trajectory with vibrant styling plt.plot(x / 1e3, y / 1e3, color='#0066cc', linewidth=3, label='Payload Trajectory', linestyle='-', alpha=0.9) plt.scatter([0], [0], color='#cc3300', s=150, edgecolor='black', linewidth=2, label='Earth', marker='o', zorder=5) # Add a cool gradient-like effect to the trajectory plt.plot(x / 1e3, y / 1e3, color='#009966', linewidth=1.5, linestyle='--', alpha=0.5) # Enhanced text elements with bold, modern fonts ax.set_xlabel('X Position (km)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_ylabel('Y Position (km)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_title('Payload Trajectory Near Earth', fontsize=18, fontweight='bold', pad=20, color='black', family='Arial') # High-visibility legend with a sleek look legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=12, borderpad=1, loc='upper right') for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') text.set_fontfamily('Arial') # Add a subtle annotation for the starting point ax.annotate('Start', xy=(x[0] / 1e3, y[0] / 1e3), xytext=(x[0] / 1e3 + 500, y[0] / 1e3 + 500), arrowprops=dict(facecolor='black', arrowstyle='->'), fontsize=10, fontweight='bold', color='black', family='Arial') # Cool grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) ax.xaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2.5) # Set a sleek background and axis styling ax.set_facecolor('#f5f5f5') plt.axis('equal') plt.tight_layout() plt.show() import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant M = 5.972e24 # mass of Earth R = 6.371e6 # radius of Earth in meters altitude = 800e3 # 800 km above the surface initial_distance = R + altitude time_step = 1 # seconds total_time = 7000 # simulate up to 7000 seconds n_steps = int(total_time / time_step) # Initial velocities in m/s velocities = np.arange(5000, 13500, 500) # from 5 km/s to 13 km/s # Plot setup with high-visibility and cool styling plt.figure(figsize=(10, 10), facecolor='white') ax = plt.gca() # Create Earth plot with enhanced styling theta = np.linspace(0, 2*np.pi, 300) earth_x = R * np.cos(theta) earth_y = R * np.sin(theta) plt.fill(earth_x, earth_y, color='#0066cc', alpha=0.6, edgecolor='black', linewidth=2, label='Earth') # Function to compute gravity acceleration def gravity(pos): r = np.linalg.norm(pos) return -G * M * pos / r**3 # Simulate each trajectory with distinct colors colors = ['#cc3300', '#009966', '#ff6600', '#660099', '#ff3399', '#006666', '#cc9900', '#990000', '#00cc99', '#ff9933', '#3333cc', '#ff0066', '#669900', '#9900cc', '#00ff66', '#cc0066'] for i, v in enumerate(velocities): pos = np.array([initial_distance, 0.0]) vel = np.array([0.0, v]) traj = [] for _ in range(n_steps): acc = gravity(pos) vel += acc * time_step pos += vel * time_step traj.append(pos.copy()) if np.linalg.norm(pos) <= R: break traj = np.array(traj) plt.plot(traj[:, 0], traj[:, 1], color=colors[i % len(colors)], linewidth=2.5, label=f'{v/1000:.1f} km/s', alpha=0.9) # Plot center of Earth plt.scatter([0], [0], color='black', s=100, edgecolor='black', linewidth=2, marker='o', label='Center of Earth', zorder=5) # Add annotation for starting point plt.annotate('Start', xy=(initial_distance, 0), xytext=(initial_distance + 1e6, 0.5e6), arrowprops=dict(facecolor='black', arrowstyle='->'), fontsize=10, fontweight='bold', color='black', family='Arial') # Enhanced text elements with bold, modern fonts ax.set_xlabel('X Position (m)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_ylabel('Y Position (m)', fontsize=14, fontweight='bold', color='black', labelpad=15, family='Arial') ax.set_title('Trajectories of Objects from 800 km Altitude with Varying Speeds', fontsize=18, fontweight='bold', pad=20, color='black', family='Arial') # High-visibility legend with a sleek look legend = ax.legend(frameon=True, framealpha=1, edgecolor='black', facecolor='white', fontsize=10, borderpad=1, loc='upper right') for text in legend.get_texts(): text.set_color('black') text.set_fontweight('bold') text.set_fontfamily('Arial') # Cool grid and frame ax.yaxis.grid(True, linestyle=':', color='gray', alpha=0.4) ax.xaxis.grid(True, linestyle=':', color='gray', alpha=0.4) for spine in ax.spines.values(): spine.set_edgecolor('black') spine.set_linewidth(2.5) # Set a sleek background and axis styling ax.set_facecolor('#f5f5f5') plt.axis('equal') plt.tight_layout() plt.savefig('multi_trajectory_plot.png')","title":"\ud83d\udd27 Assumptions:"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Wave Interference Patterns on a Water Surface 1. Selecting a Regular Polygon Introduction In wave physics, interference occurs when two or more waves overlap, resulting in regions of constructive and destructive interference. To systematically analyze these patterns, we consider multiple point wave sources positioned at the vertices of a regular polygon . This setup allows us to explore how symmetric arrangements of sources influence the resulting wave field. Mathematical Definition of a Regular Polygon A regular polygon with \\(N\\) sides is a closed geometric figure where all sides are of equal length and all internal angles are equal. The vertices of such a polygon, when inscribed in a circle of radius \\(R\\) , can be determined using trigonometric functions. For a polygon centered at the origin, the coordinates of the \\(i\\) -th vertex are given by: \\[x_i=R\\cos\\left(\\frac{2\\pi i}{N}\\right),\\quad y_i=R\\sin\\left(\\frac{2\\pi i}{N}\\right),\\quad i=0,1,2,\\dots,N-1\\] where: - \\(R\\) is the circumradius of the polygon, \\(N\\) is the number of sides (hence, the number of sources), \\(i\\) indexes the vertices counterclockwise starting from an initial reference point. Choosing the Regular Polygon The choice of \\(N\\) influences the symmetry of the interference pattern. Common selections include: Equilateral Triangle ( \\(N=3\\) ) : Yields a threefold symmetric interference pattern. Square ( \\(N=4\\) ) : Produces a fourfold symmetric pattern with central and diagonal wave reinforcements. Pentagon ( \\(N=5\\) ) : Generates more complex wave interactions with fivefold rotational symmetry. Hexagon ( \\(N=6\\) ) : Approximates circular symmetry while retaining noticeable interference fringes. 2. Positioning the Sources Determining the Coordinates of the Polygonal Vertices To systematically analyze interference, we must precisely position the wave sources at the vertices of a chosen regular polygon. Given a polygon inscribed within a circle of radius \\(R\\) , the coordinates of its vertices are: \\[x_i=R\\cos\\left(\\frac{2\\pi i}{N}\\right),\\quad y_i=R\\sin\\left(\\frac{2\\pi i}{N}\\right),\\quad i=0,1,2,\\dots,N-1\\] Assigning Each Vertex as a Wave Source Each vertex serves as a point source emitting circular waves with identical amplitude and frequency. The total wave field results from the superposition of these waves. Each wave propagates outward from its source with a displacement function: \\[\\eta_i(x,y,t)=\\frac{A}{r_i}\\cos\\left(kr_i-\\omega t+\\phi_i\\right)\\] where: \\(r_i=\\sqrt{(x-x_i)^2+(y-y_i)^2}\\) is the radial distance to the observation point. 3. Defining the Wave Equations Mathematical Representation of Wave Motion Each wave emitted from a point source follows the equation: \\[\\eta_i(x,y,t)=\\frac{A}{r_i}\\cos\\left(kr_i-\\omega t+\\phi_i\\right)\\] where: \\(A\\) is the amplitude, \\(k=\\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega=2\\pi f\\) is the angular frequency, \\(\\phi_i\\) is the phase, \\(r_i\\) is the radial distance from the \\(i\\) -th source. Uniformity Assumptions To maintain coherence in interference analysis, we assume: All waves have the same amplitude , i.e., \\(A\\) is constant. All waves have the same wavelength \\(\\lambda\\) and frequency \\(f\\) . Initial phase differences between sources remain fixed. 4. Applying the Superposition Principle Summation of Wave Displacements According to the principle of superposition, the resultant displacement at any point on the water surface is the sum of individual wave contributions: \\[\\eta_{\\text{sum}}(x,y,t)=\\sum_{i=1}^{N}\\eta_i(x,y,t)\\] This summation captures constructive and destructive interference effects. Constructive and Destructive Interference Conditions Constructive interference: Occurs when phase differences satisfy: \\[kr_i-\\omega t+\\phi_i=2m\\pi,\\quad m\\in\\mathbb{Z}\\] Destructive interference: Occurs when phase differences satisfy: \\[kr_i-\\omega t+\\phi_i=(2m+1)\\pi,\\quad m\\in\\mathbb{Z}\\] 5. Analyzing the Interference Patterns Identifying Interference Zones By computing \\(\\eta_{\\text{sum}}(x,y,t)\\) , we can classify different regions: - High amplitude zones: Result from constructive interference. - Low amplitude zones: Result from destructive interference. Temporal Evolution of the Pattern As time progresses, the interference pattern evolves dynamically, influenced by wave frequency and phase differences. 6. Visualization and Simulation Graphical Representations Using numerical simulations, we generate: - Static interference maps for different polygons. - Time-evolving wave fields to observe changing interference dynamics. Python Implementation A Python script implementing the above equations will: Define wave parameters. Compute the interference pattern on a 2D grid. Visualize results using heatmaps and contour plots. The next step is to implement and analyze these interference patterns computationally. Python/Models import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Define the grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Define wave parameters wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi / 5 # Angular frequency t = 0 # Static time for snapshot (can be animated) # Function to create a wave from a single source def single_wave(X, Y, source): r = np.sqrt((X - source[0])**2 + (Y - source[1])**2) return np.sin(k * r - omega * t) # Function to sum multiple waves from different sources def multiple_waves(X, Y, sources): Z = np.zeros_like(X) for source in sources: Z += single_wave(X, Y, source) return Z # ------------------------ # Sources definitions # ------------------------ sources_1 = [(0, 0)] distance = 5 sources_4 = [(-distance, -distance), (-distance, distance), (distance, -distance), (distance, distance)] radius = 5 angles = np.linspace(0, 2 * np.pi, 6)[:-1] sources_5 = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Custom color map blending burgundy (#800020) and lighter blue (#4682B4) colors = ['#800020', '#400010', '#4682B4', '#87CEEB', '#800080'] custom_cmap = plt.cm.colors.LinearSegmentedColormap.from_list('burgundy_lightblue', colors) # ------------------------ # Plotting Function # ------------------------ def plot_wave(Z, title): fig, axs = plt.subplots(1, 2, figsize=(18, 8)) # BIGGER SIZE # Heatmap im = axs[0].imshow(Z, extent=[-10, 10, -10, 10], origin='lower', cmap=custom_cmap) axs[0].set_title(f\"{title} - Heatmap\", fontsize=18) axs[0].set_xlabel('X axis', fontsize=14) axs[0].set_ylabel('Y axis', fontsize=14) plt.colorbar(im, ax=axs[0]) # 3D Surface ax = fig.add_subplot(1, 2, 2, projection='3d') ax.plot_surface(X, Y, Z, cmap=custom_cmap, edgecolor='none') ax.set_title(f\"{title} - 3D Surface\", fontsize=18) ax.set_xlabel('X axis', fontsize=14) ax.set_ylabel('Y axis', fontsize=14) ax.set_zlabel('Amplitude', fontsize=14) plt.tight_layout() # Removed plt.show() from inside the function # ------------------------ # Calculate and plot all # ------------------------ Z1 = multiple_waves(X, Y, sources_1) Z4 = multiple_waves(X, Y, sources_4) Z5 = multiple_waves(X, Y, sources_5) plot_wave(Z1, \"Single Source\") plot_wave(Z4, \"Four Sources (Square)\") plot_wave(Z5, \"Five Sources (Pentagon)\") plt.show() # Moved plt.show() here to display all plots import numpy as np import matplotlib.pyplot as plt import imageio import os # Define the grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Define wave parameters wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi / 5 # Angular frequency # Function to create a wave from a single source def single_wave(X, Y, source, t): r = np.sqrt((X - source[0])**2 + (Y - source[1])**2) return np.sin(k * r - omega * t) # Function to sum multiple waves from different sources def multiple_waves(X, Y, sources, t): Z = np.zeros_like(X) for source in sources: Z += single_wave(X, Y, source, t) return Z # Sources definitions for 5 sources (in a pentagon) radius = 5 angles = np.linspace(0, 2 * np.pi, 6)[:-1] sources_5 = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Create 3_waves folder if it doesn't exist OUTPUT_DIR = \"3_waves\" if not os.path.exists(OUTPUT_DIR): os.makedirs(OUTPUT_DIR) # Custom color map blending burgundy (#800020) and lighter blue (#4682B4) colors = ['#800020', '#400010', '#4682B4', '#87CEEB', '#800080'] custom_cmap = plt.cm.colors.LinearSegmentedColormap.from_list('burgundy_lightblue', colors) # Create GIF frames num_frames = 100 gif_frames = [] # Create the GIF frames for time from 0 to 2*pi for i in range(num_frames): t = i * 2 * np.pi / num_frames # Varying time Z = multiple_waves(X, Y, sources_5, t) # Plotting the frame fig, ax = plt.subplots(figsize=(8, 6)) im = ax.imshow(Z, extent=[-10, 10, -10, 10], origin='lower', cmap=custom_cmap, animated=True) ax.set_title(f\"Interference of 5 Sources - Time = {t:.2f}\", fontsize=16) ax.set_xlabel('X axis', fontsize=14) ax.set_ylabel('Y axis', fontsize=14) plt.colorbar(im, ax=ax) # Ensure proper rendering plt.tight_layout() # Draw the figure to make sure it's rendered correctly before saving fig.canvas.draw() # Convert to image and append to GIF frames gif_frames.append(np.array(fig.canvas.renderer.buffer_rgba())) # Close the plot to avoid memory issues in the loop plt.close(fig) # Create and save the GIF in the 3_waves folder gif_path = os.path.join(OUTPUT_DIR, \"interference_5_sources.gif\") imageio.mimsave(gif_path, gif_frames, duration=0.1) print(f\"GIF saved as {gif_path}\")","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-patterns-on-a-water-surface","text":"","title":"Wave Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-selecting-a-regular-polygon","text":"","title":"1. Selecting a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#introduction","text":"In wave physics, interference occurs when two or more waves overlap, resulting in regions of constructive and destructive interference. To systematically analyze these patterns, we consider multiple point wave sources positioned at the vertices of a regular polygon . This setup allows us to explore how symmetric arrangements of sources influence the resulting wave field.","title":"Introduction"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-definition-of-a-regular-polygon","text":"A regular polygon with \\(N\\) sides is a closed geometric figure where all sides are of equal length and all internal angles are equal. The vertices of such a polygon, when inscribed in a circle of radius \\(R\\) , can be determined using trigonometric functions. For a polygon centered at the origin, the coordinates of the \\(i\\) -th vertex are given by: \\[x_i=R\\cos\\left(\\frac{2\\pi i}{N}\\right),\\quad y_i=R\\sin\\left(\\frac{2\\pi i}{N}\\right),\\quad i=0,1,2,\\dots,N-1\\] where: - \\(R\\) is the circumradius of the polygon, \\(N\\) is the number of sides (hence, the number of sources), \\(i\\) indexes the vertices counterclockwise starting from an initial reference point.","title":"Mathematical Definition of a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#choosing-the-regular-polygon","text":"The choice of \\(N\\) influences the symmetry of the interference pattern. Common selections include: Equilateral Triangle ( \\(N=3\\) ) : Yields a threefold symmetric interference pattern. Square ( \\(N=4\\) ) : Produces a fourfold symmetric pattern with central and diagonal wave reinforcements. Pentagon ( \\(N=5\\) ) : Generates more complex wave interactions with fivefold rotational symmetry. Hexagon ( \\(N=6\\) ) : Approximates circular symmetry while retaining noticeable interference fringes.","title":"Choosing the Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-positioning-the-sources","text":"","title":"2. Positioning the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#determining-the-coordinates-of-the-polygonal-vertices","text":"To systematically analyze interference, we must precisely position the wave sources at the vertices of a chosen regular polygon. Given a polygon inscribed within a circle of radius \\(R\\) , the coordinates of its vertices are: \\[x_i=R\\cos\\left(\\frac{2\\pi i}{N}\\right),\\quad y_i=R\\sin\\left(\\frac{2\\pi i}{N}\\right),\\quad i=0,1,2,\\dots,N-1\\]","title":"Determining the Coordinates of the Polygonal Vertices"},{"location":"1%20Physics/3%20Waves/Problem_1/#assigning-each-vertex-as-a-wave-source","text":"Each vertex serves as a point source emitting circular waves with identical amplitude and frequency. The total wave field results from the superposition of these waves. Each wave propagates outward from its source with a displacement function: \\[\\eta_i(x,y,t)=\\frac{A}{r_i}\\cos\\left(kr_i-\\omega t+\\phi_i\\right)\\] where: \\(r_i=\\sqrt{(x-x_i)^2+(y-y_i)^2}\\) is the radial distance to the observation point.","title":"Assigning Each Vertex as a Wave Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-defining-the-wave-equations","text":"","title":"3. Defining the Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-representation-of-wave-motion","text":"Each wave emitted from a point source follows the equation: \\[\\eta_i(x,y,t)=\\frac{A}{r_i}\\cos\\left(kr_i-\\omega t+\\phi_i\\right)\\] where: \\(A\\) is the amplitude, \\(k=\\frac{2\\pi}{\\lambda}\\) is the wave number, \\(\\omega=2\\pi f\\) is the angular frequency, \\(\\phi_i\\) is the phase, \\(r_i\\) is the radial distance from the \\(i\\) -th source.","title":"Mathematical Representation of Wave Motion"},{"location":"1%20Physics/3%20Waves/Problem_1/#uniformity-assumptions","text":"To maintain coherence in interference analysis, we assume: All waves have the same amplitude , i.e., \\(A\\) is constant. All waves have the same wavelength \\(\\lambda\\) and frequency \\(f\\) . Initial phase differences between sources remain fixed.","title":"Uniformity Assumptions"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-applying-the-superposition-principle","text":"","title":"4. Applying the Superposition Principle"},{"location":"1%20Physics/3%20Waves/Problem_1/#summation-of-wave-displacements","text":"According to the principle of superposition, the resultant displacement at any point on the water surface is the sum of individual wave contributions: \\[\\eta_{\\text{sum}}(x,y,t)=\\sum_{i=1}^{N}\\eta_i(x,y,t)\\] This summation captures constructive and destructive interference effects.","title":"Summation of Wave Displacements"},{"location":"1%20Physics/3%20Waves/Problem_1/#constructive-and-destructive-interference-conditions","text":"Constructive interference: Occurs when phase differences satisfy: \\[kr_i-\\omega t+\\phi_i=2m\\pi,\\quad m\\in\\mathbb{Z}\\] Destructive interference: Occurs when phase differences satisfy: \\[kr_i-\\omega t+\\phi_i=(2m+1)\\pi,\\quad m\\in\\mathbb{Z}\\]","title":"Constructive and Destructive Interference Conditions"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analyzing-the-interference-patterns","text":"","title":"5. Analyzing the Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#identifying-interference-zones","text":"By computing \\(\\eta_{\\text{sum}}(x,y,t)\\) , we can classify different regions: - High amplitude zones: Result from constructive interference. - Low amplitude zones: Result from destructive interference.","title":"Identifying Interference Zones"},{"location":"1%20Physics/3%20Waves/Problem_1/#temporal-evolution-of-the-pattern","text":"As time progresses, the interference pattern evolves dynamically, influenced by wave frequency and phase differences.","title":"Temporal Evolution of the Pattern"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-visualization-and-simulation","text":"","title":"6. Visualization and Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#graphical-representations","text":"Using numerical simulations, we generate: - Static interference maps for different polygons. - Time-evolving wave fields to observe changing interference dynamics.","title":"Graphical Representations"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-implementation","text":"A Python script implementing the above equations will: Define wave parameters. Compute the interference pattern on a 2D grid. Visualize results using heatmaps and contour plots. The next step is to implement and analyze these interference patterns computationally.","title":"Python Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/#pythonmodels","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Define the grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Define wave parameters wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi / 5 # Angular frequency t = 0 # Static time for snapshot (can be animated) # Function to create a wave from a single source def single_wave(X, Y, source): r = np.sqrt((X - source[0])**2 + (Y - source[1])**2) return np.sin(k * r - omega * t) # Function to sum multiple waves from different sources def multiple_waves(X, Y, sources): Z = np.zeros_like(X) for source in sources: Z += single_wave(X, Y, source) return Z # ------------------------ # Sources definitions # ------------------------ sources_1 = [(0, 0)] distance = 5 sources_4 = [(-distance, -distance), (-distance, distance), (distance, -distance), (distance, distance)] radius = 5 angles = np.linspace(0, 2 * np.pi, 6)[:-1] sources_5 = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Custom color map blending burgundy (#800020) and lighter blue (#4682B4) colors = ['#800020', '#400010', '#4682B4', '#87CEEB', '#800080'] custom_cmap = plt.cm.colors.LinearSegmentedColormap.from_list('burgundy_lightblue', colors) # ------------------------ # Plotting Function # ------------------------ def plot_wave(Z, title): fig, axs = plt.subplots(1, 2, figsize=(18, 8)) # BIGGER SIZE # Heatmap im = axs[0].imshow(Z, extent=[-10, 10, -10, 10], origin='lower', cmap=custom_cmap) axs[0].set_title(f\"{title} - Heatmap\", fontsize=18) axs[0].set_xlabel('X axis', fontsize=14) axs[0].set_ylabel('Y axis', fontsize=14) plt.colorbar(im, ax=axs[0]) # 3D Surface ax = fig.add_subplot(1, 2, 2, projection='3d') ax.plot_surface(X, Y, Z, cmap=custom_cmap, edgecolor='none') ax.set_title(f\"{title} - 3D Surface\", fontsize=18) ax.set_xlabel('X axis', fontsize=14) ax.set_ylabel('Y axis', fontsize=14) ax.set_zlabel('Amplitude', fontsize=14) plt.tight_layout() # Removed plt.show() from inside the function # ------------------------ # Calculate and plot all # ------------------------ Z1 = multiple_waves(X, Y, sources_1) Z4 = multiple_waves(X, Y, sources_4) Z5 = multiple_waves(X, Y, sources_5) plot_wave(Z1, \"Single Source\") plot_wave(Z4, \"Four Sources (Square)\") plot_wave(Z5, \"Five Sources (Pentagon)\") plt.show() # Moved plt.show() here to display all plots import numpy as np import matplotlib.pyplot as plt import imageio import os # Define the grid x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) # Define wave parameters wavelength = 2 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi / 5 # Angular frequency # Function to create a wave from a single source def single_wave(X, Y, source, t): r = np.sqrt((X - source[0])**2 + (Y - source[1])**2) return np.sin(k * r - omega * t) # Function to sum multiple waves from different sources def multiple_waves(X, Y, sources, t): Z = np.zeros_like(X) for source in sources: Z += single_wave(X, Y, source, t) return Z # Sources definitions for 5 sources (in a pentagon) radius = 5 angles = np.linspace(0, 2 * np.pi, 6)[:-1] sources_5 = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Create 3_waves folder if it doesn't exist OUTPUT_DIR = \"3_waves\" if not os.path.exists(OUTPUT_DIR): os.makedirs(OUTPUT_DIR) # Custom color map blending burgundy (#800020) and lighter blue (#4682B4) colors = ['#800020', '#400010', '#4682B4', '#87CEEB', '#800080'] custom_cmap = plt.cm.colors.LinearSegmentedColormap.from_list('burgundy_lightblue', colors) # Create GIF frames num_frames = 100 gif_frames = [] # Create the GIF frames for time from 0 to 2*pi for i in range(num_frames): t = i * 2 * np.pi / num_frames # Varying time Z = multiple_waves(X, Y, sources_5, t) # Plotting the frame fig, ax = plt.subplots(figsize=(8, 6)) im = ax.imshow(Z, extent=[-10, 10, -10, 10], origin='lower', cmap=custom_cmap, animated=True) ax.set_title(f\"Interference of 5 Sources - Time = {t:.2f}\", fontsize=16) ax.set_xlabel('X axis', fontsize=14) ax.set_ylabel('Y axis', fontsize=14) plt.colorbar(im, ax=ax) # Ensure proper rendering plt.tight_layout() # Draw the figure to make sure it's rendered correctly before saving fig.canvas.draw() # Convert to image and append to GIF frames gif_frames.append(np.array(fig.canvas.renderer.buffer_rgba())) # Close the plot to avoid memory issues in the loop plt.close(fig) # Create and save the GIF in the 3_waves folder gif_path = os.path.join(OUTPUT_DIR, \"interference_5_sources.gif\") imageio.mimsave(gif_path, gif_frames, duration=0.1) print(f\"GIF saved as {gif_path}\")","title":"Python/Models"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force 1. Introduction and Motivation The Lorentz force governs the motion of charged particles in electromagnetic fields and is essential in understanding systems like: - Particle accelerators \u2013 guiding and accelerating beams. - Mass spectrometers \u2013 separating particles based on mass-to-charge ratio. - Plasma confinement devices (e.g., tokamaks) \u2013 controlling plasma using magnetic fields. Understanding the Lorentz force enables the design and analysis of such systems. 2. Lorentz Force Equation The Lorentz force \\(\\vec{F}\\) acting on a charged particle is given by: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\(q\\) : Charge of the particle - \\(\\vec{E}\\) : Electric field - \\(\\vec{B}\\) : Magnetic field - \\(\\vec{v}\\) : Particle velocity Using Newton\u2019s Second Law: \\[ \\vec{F} = m \\frac{d\\vec{v}}{dt} \\] We obtain the equation of motion: \\[ m \\frac{d\\vec{v}}{dt} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This equation is generally solved numerically due to the complexity of \\(\\vec{v} \\times \\vec{B}\\) . 3. Simulation Overview We simulate particle trajectories using the 4th-order Runge-Kutta method for accuracy. Scenarios Simulated: 1. Uniform magnetic field only: Circular motion. 2. Parallel \\(\\vec{E}\\) and \\(\\vec{B}\\) : Helical motion. 3. Crossed fields: Drift motion. Parameters that can be varied: - Electric field strength \\(\\vec{E}\\) - Magnetic field strength \\(\\vec{B}\\) - Initial velocity \\(\\vec{v}_0\\) - Charge \\(q\\) and mass \\(m\\) 4. Code Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from matplotlib.collections import LineCollection import os # Required for operating system functions (like creating directories) from IPython.display import Image, display # For displaying in Colab # --- Constants --- q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # --- Initial conditions --- r0 = np.array([1.0, 0.0, 0.0]) # Initial position (m) v0 = np.array([0.0, 1.0, 0.0]) # Initial velocity perpendicular to B (m/s) y0 = np.concatenate((r0, v0)) # Combine position and velocity # --- Lorentz force differential equation --- def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # --- Time setup --- t_span = (0, 10) t_eval = np.linspace(*t_span, 500) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y = sol.y[0], sol.y[1] # --- Color gradient path --- points = np.array([x, y]).T.reshape(-1, 1, 2) segments = np.concatenate([points[:-1], points[1:]], axis=1) norm = plt.Normalize(t_eval.min(), t_eval.max()) # Using 'magma' or 'viridis' for a cooler gradient lc = LineCollection(segments, cmap='viridis', norm=norm) lc.set_array(t_eval) lc.set_linewidth(3.0) # Slightly thicker line for better visibility # --- Plot --- fig, ax = plt.subplots(figsize=(9, 7)) # Slightly larger figure fig.patch.set_facecolor('#282C34') # Dark background for the figure ax.set_facecolor('#21252B') # Dark background for the plot area ax.add_collection(lc) # Add the colored line collection to the plot # Particle start and end points with distinct markers and colors ax.scatter(x[0], y[0], color='#00FF00', s=100, label='Start Point', zorder=5, edgecolors='white', linewidth=0.8) # Bright green, larger ax.scatter(x[-1], y[-1], color='#FF4500', s=100, label='End Point', zorder=5, edgecolors='white', linewidth=0.8) # Orange-red, larger # Labels and Title ax.set_xlabel('X Position (m)', color='#ABB2BF', fontsize=12) ax.set_ylabel('Y Position (m)', color='#ABB2BF', fontsize=12) ax.set_title('Charged Particle Trajectory in a Uniform Magnetic Field', color='#61AFEF', fontsize=18, weight='bold') # Blue, larger, bold title # Grid and Ticks ax.grid(True, linestyle='--', alpha=0.4, color='#3E4452') # Subtler grid ax.tick_params(axis='x', colors='#ABB2BF', labelsize=10) ax.tick_params(axis='y', colors='#ABB2BF', labelsize=10) # Aspect Ratio ax.axis('equal') # Ensures circular motion appears circular # Color bar for time cbar = fig.colorbar(lc, ax=ax, label='Time (s)', shrink=0.75, pad=0.03) # Shrink and position cbar.set_label('Time (s)', color='#ABB2BF', fontsize=12) cbar.ax.tick_params(colors='#ABB2BF') # Colorbar tick labels # Legend ax.legend(facecolor='#21252B', edgecolor='#3E4452', labelcolor='white', fontsize=10) # Styled legend plt.tight_layout() # Adjust plot to prevent labels from overlapping # --- Save to PNG (or JPG if preferred, for static images) --- # For GitHub Pages, saving as PNG is often good for static plots. # The image will be saved in the \"4 Electromagnetism\" folder. output_dir = \"4 Electromagnetism\" # Your target directory name os.makedirs(output_dir, exist_ok=True) # Create the directory if it doesn't exist # Using a descriptive filename for the static plot image_path = os.path.join(output_dir, \"charged_particle_trajectory.png\") plt.savefig(image_path, dpi=300, bbox_inches='tight', facecolor=fig.get_facecolor()) # Save the plot with high DPI plt.close(fig) # Close the plot to free memory # --- Display in Notebook (if using Jupyter/Colab) --- display(Image(filename=image_path)) import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from scipy.integrate import solve_ivp from IPython.display import Image, display import os # \u0130\u015fletim sistemi fonksiyonlar\u0131 i\u00e7in gerekli # --- Constants --- q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # --- Initial Conditions --- v0 = np.array([1.0, 0.0, 0.0]) # Velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Position (m) y0 = np.concatenate((r0, v0)) # Combine initial state (position and velocity) # --- Lorentz Force Function --- def lorentz(t, y): r = y[:3] # Extract position components (x, y, z) v = y[3:] # Extract velocity components (vx, vy, vz) dvdt = (q / m) * (E + np.cross(v, B)) # Calculate acceleration based on Lorentz force return np.concatenate((v, dvdt)) # Return concatenated velocity and acceleration # --- Time Settings --- t_span = (0, 10) # Time interval for simulation (start, end) t_eval = np.linspace(t_span[0], t_span[1], 500) # Points at which to evaluate the solution sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) # Solve the differential equation x, y = sol.y[0], sol.y[1] # Extract x and y components for 2D plotting z = sol.y[2] # Extract z component (will be flat in circular motion if B is along z) # --- Set Up Plot --- fig, ax = plt.subplots(figsize=(8, 8)) # Create a figure and a set of subplots fig.patch.set_facecolor('#282C34') # Set the background color of the figure ax.set_facecolor('#21252B') # Set the background color of the plot area ax.set_xlim(np.min(x)*1.1, np.max(x)*1.1) # Set x-axis limits with a small buffer ax.set_ylim(np.min(y)*1.1, np.max(y)*1.1) # Set y-axis limits with a small buffer ax.set_xlabel(\"x (m)\", color='#ABB2BF') # X-axis label ax.set_ylabel(\"y (m)\", color='#ABB2BF') # Y-axis label ax.set_title(\"Charged Particle Motion in a Magnetic Field\", color='#61AFEF', fontsize=16) # Plot title ax.grid(True, linestyle='--', alpha=0.5, color='#3E4452') # Add a subtle grid ax.tick_params(axis='x', colors='#ABB2BF') # Set x-axis tick label color ax.tick_params(axis='y', colors='#ABB2BF') # Set y-axis tick label color line, = ax.plot([], [], lw=2, color='#98C379', alpha=0.9) # Initialize the line for the particle's path point, = ax.plot([], [], 'o', color='#E06C75', markersize=8, markeredgecolor='#E06C75') # Initialize the point for the current position # --- Init Function for Animation --- def init(): line.set_data([], []) # Clear line data point.set_data([], []) # Clear point data return line, point # Return the plot objects to be updated # --- Update Function for Animation --- def update(i): if i < len(x): # Ensure index is within bounds line.set_data(x[:i+1], y[:i+1]) # Update the path up to the current frame point.set_data([x[i]], [y[i]]) # Update the current particle position return line, point # Return the updated plot objects # --- Create Animation --- # FuncAnimation creates the animation by repeatedly calling the update function ani = FuncAnimation(fig, update, frames=len(x), init_func=init, blit=False, interval=20) # --- Save to GIF --- # GIF'i \"4 Electromagnetism\" klas\u00f6r\u00fcn\u00fcn i\u00e7ine kaydedecek \u015fekilde g\u00fcncellendi. # Bu klas\u00f6r yoksa olu\u015fturulur. output_dir = \"4 Electromagnetism\" # Hedef klas\u00f6r ad\u0131n\u0131z os.makedirs(output_dir, exist_ok=True) # Klas\u00f6r\u00fc olu\u015ftur (zaten varsa hata vermez) gif_path = os.path.join(output_dir, \"charged_particle_motion_animated.gif\") # Klas\u00f6r i\u00e7inde kaydet writer = PillowWriter(fps=30) # Initialize GIF writer with 30 frames per second ani.save(gif_path, writer=writer, dpi=150) # Save the animation to a GIF file with higher DPI for better quality plt.close() # Close the plot window to free up resources, important for Colab and non-interactive environments # --- Display in Notebook (if using Jupyter/Colab) --- # This line displays the saved GIF directly within the Colab or Jupyter notebook output. display(Image(filename=gif_path)) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Explicitly import Axes3D from matplotlib import cm # For colormaps import os # Required for operating system functions (like creating directories) from IPython.display import Image, display # For displaying images in Colab # --- Constants --- q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 1.0]) # Electric field (V/m) - now along z-axis B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) - now along z-axis # --- Initial conditions --- v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) y0 = np.concatenate((v0, r0)) # Combine initial state: velocity then position # --- Lorentz force differential equation --- def lorentz(t, y): v = y[:3] # Extract velocity components (vx, vy, vz) r = y[3:] # Extract position components (x, y, z) dvdt = (q / m) * (E + np.cross(v, B)) # Calculate acceleration based on Lorentz force return np.concatenate((dvdt, v)) # Return concatenated acceleration (dv/dt) and velocity (dr/dt) # --- Time setup --- t_span = (0, 10) # Time interval for simulation (start, end) t_eval = np.linspace(*t_span, 1000) # Points at which to evaluate the solution (1000 points) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) # Solve the differential equation # Extract position components from the solution x, y, z = sol.y[3], sol.y[4], sol.y[5] # --- 3D Plot --- fig = plt.figure(figsize=(14, 10)) # Larger figure for 3D plot fig.patch.set_facecolor('#282C34') # Dark background for the figure ax = fig.add_subplot(111, projection='3d') # Add a 3D subplot ax.set_facecolor('#21252B') # Dark background for the plot area (3D specific) # Plot the full trajectory (lighter, semi-transparent for context) ax.plot(x, y, z, lw=1.5, c='#ABB2BF', alpha=0.4) # Lighter gray, slightly thicker line # Scatter points colored by time (for better visual appeal) scatter = ax.scatter(x, y, z, c=sol.t, cmap='viridis', s=8, alpha=0.9, edgecolor='none') # Larger, more visible points # Mark start and end points ax.scatter(x[0], y[0], z[0], color='#00FF00', label='Start Point', s=150, zorder=5, edgecolors='white', linewidth=1.5) # Bright green, larger marker ax.scatter(x[-1], y[-1], z[-1], color='#FF4500', label='End Point', s=150, zorder=5, edgecolors='white', linewidth=1.5) # Orange-red, larger marker # Set labels with dark theme colors ax.set_xlabel('X Position (m)', color='#ABB2BF', fontsize=12) ax.set_ylabel('Y Position (m)', color='#ABB2BF', fontsize=12) ax.set_zlabel('Z Position (m)', color='#ABB2BF', fontsize=12) # Set title with dark theme colors ax.set_title('3D Trajectory of a Charged Particle in\\nElectric & Magnetic Fields', color='#61AFEF', weight='bold', fontsize=18, pad=20) # Blue, larger, bold title, higher padding # Customize grid, tick labels, and axes for dark theme ax.tick_params(axis='x', colors='#ABB2BF', labelsize=10) ax.tick_params(axis='y', colors='#ABB2BF', labelsize=10) ax.tick_params(axis='z', colors='#ABB2BF', labelsize=10) # Set grid line colors ax.xaxis.pane.set_edgecolor('#3E4452') ax.yaxis.pane.set_edgecolor('#3E4452') ax.zaxis.pane.set_edgecolor('#3E4452') ax.xaxis.pane.set_facecolor('#21252B') # Make panes match ax background ax.yaxis.pane.set_facecolor('#21252B') ax.zaxis.pane.set_facecolor('#21252B') ax.grid(True, linestyle='--', alpha=0.4, color='#3E4452') # Subtler grid lines # Color bar for time cbar = fig.colorbar(scatter, ax=ax, label='Time (s)', shrink=0.7, pad=0.08) # Adjusted shrink and pad for 3D cbar.set_label('Time (s)', color='#ABB2BF', fontsize=12) cbar.ax.tick_params(colors='#ABB2BF') # Colorbar tick labels # Legend ax.legend(facecolor='#21252B', edgecolor='#3E4452', labelcolor='white', fontsize=10) # Styled legend plt.tight_layout(rect=[0, 0, 1, 0.95]) # Adjust layout to prevent title overlap # --- Save to PNG --- # The image will be saved in the \"4 Electromagnetism\" folder, as requested. # It will create the directory if it doesn't exist. output_dir = \"4 Electromagnetism\" # Your target directory name os.makedirs(output_dir, exist_ok=True) # Create the directory if it doesn't exist # Using a descriptive filename for the static 3D plot image_path = os.path.join(output_dir, \"3d_charged_particle_trajectory.png\") plt.savefig(image_path, dpi=300, bbox_inches='tight', facecolor=fig.get_facecolor()) # Save with high DPI plt.close(fig) # Close the plot to free memory # --- Display in Notebook (if using Jupyter/Colab) --- display(Image(filename=image_path)) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Explicitly import Axes3D import os # Required for operating system functions (like creating directories) from IPython.display import Image, display # For displaying images in Colab # --- Constants --- q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([1.0, 0.0, 0.0]) # Electric field (V/m) - along x-axis for drift B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) - along z-axis # --- Initial conditions --- v0 = np.array([0.0, 1.0, 0.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) y0 = np.concatenate((v0, r0)) # Combine initial state: velocity then position # --- Lorentz force differential equation --- def lorentz(t, y): v = y[:3] # Extract velocity components (vx, vy, vz) r = y[3:] # Extract position components (x, y, z) dvdt = (q / m) * (E + np.cross(v, B)) # Calculate acceleration based on Lorentz force return np.concatenate((dvdt, v)) # Return concatenated acceleration (dv/dt) and velocity (dr/dt) # --- Time settings --- t_span = (0, 20) # Time interval for simulation (start, end) t_eval = np.linspace(*t_span, 2000) # Points at which to evaluate the solution (2000 points for smoothness) # --- Solve the ODE --- sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) # Extract position components from the solution x, y, z = sol.y[3], sol.y[4], sol.y[5] # --- 3D Plotting --- fig = plt.figure(figsize=(12, 8)) # Slightly larger figure for better detail fig.patch.set_facecolor('#282C34') # Dark background for the figure ax = fig.add_subplot(111, projection='3d') # Add a 3D subplot ax.set_facecolor('#21252B') # Dark background for the plot area # Plot the trajectory with enhanced styling ax.plot(x, y, z, color='#FFD700', lw=2.5, label='Drift Trajectory', alpha=0.9) # Gold color, slightly thicker, opaque # Add start and end points for clarity ax.scatter(x[0], y[0], z[0], color='#00FF00', s=120, label='Start Point', zorder=5, edgecolors='white', linewidth=1.2) # Bright green ax.scatter(x[-1], y[-1], z[-1], color='#FF4500', s=120, label='End Point', zorder=5, edgecolors='white', linewidth=1.2) # Orange-red # Labels and style for dark theme ax.set_xlabel('X Position (m)', color='#ABB2BF', fontsize=12, labelpad=10) # Label padding ax.set_ylabel('Y Position (m)', color='#ABB2BF', fontsize=12, labelpad=10) ax.set_zlabel('Z Position (m)', color='#ABB2BF', fontsize=12, labelpad=10) ax.tick_params(colors='#ABB2BF', labelsize=10) # Tick label colors # Adjust grid and background panes for 3D plot ax.xaxis.pane.set_edgecolor('#3E4452') # Grid line colors for the panes ax.yaxis.pane.set_edgecolor('#3E4452') ax.zaxis.pane.set_edgecolor('#3E4452') ax.xaxis.pane.set_facecolor('#21252B') # Pane face colors ax.yaxis.pane.set_facecolor('#21252B') ax.zaxis.pane.set_facecolor('#21252B') ax.grid(True, color='#3E4452', linestyle='--', alpha=0.5) # Subtler grid lines # Title plt.title(\"Drift Motion of a Charged Particle\", color='#61AFEF', fontsize=18, weight='bold', pad=20) # Blue, larger, bold title, padding # Legend ax.legend(loc='upper right', facecolor='#21252B', edgecolor='#3E4452', labelcolor='white', fontsize=10) # Styled legend plt.tight_layout(rect=[0, 0, 1, 0.95]) # Adjust layout to prevent title overlap # --- Save to PNG --- # The image will be saved in the \"4 Electromagnetism\" folder. output_dir = \"4 Electromagnetism\" # Your target directory name os.makedirs(output_dir, exist_ok=True) # Create the directory if it doesn't exist # Using a descriptive filename for the static 3D plot image_path = os.path.join(output_dir, \"drift_motion_trajectory.png\") plt.savefig(image_path, dpi=300, bbox_inches='tight', facecolor=fig.get_facecolor()) # Save with high DPI plt.close(fig) # Close the plot to free memory # --- Display in Notebook (if using Jupyter/Colab) --- display(Image(filename=image_path)) 5. Results and Visualizations Case 1: Circular Motion \\(\\vec{E} = 0\\) \\(\\vec{B} = [0, 0, B]\\) Initial velocity perpendicular to \\(\\vec{B}\\) Expected motion: circular From theory: \\[ r_L = \\frac{mv}{|q||B|} \\quad \\text{(Larmor radius)} \\] Plot: [Circular orbit in x-y plane] Case 2: Helical Motion \\(\\vec{E} = [0, 0, E]\\) \\(\\vec{B} = [0, 0, B]\\) Expected motion: helix, as velocity has components both parallel and perpendicular to \\(\\vec{B}\\) . Plot: [3D helical path] Case 3: Crossed Fields (Drift) \\(\\vec{E} = [0, E, 0]\\) Case 3: Crossed Fields (Drift) \\(\\vec{E} = [0, E, 0]\\) \\(\\vec{B} = [0, 0, B]\\) Expected motion: drift velocity in x-direction: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Plot: [Curved motion with net drift]","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-introduction-and-motivation","text":"The Lorentz force governs the motion of charged particles in electromagnetic fields and is essential in understanding systems like: - Particle accelerators \u2013 guiding and accelerating beams. - Mass spectrometers \u2013 separating particles based on mass-to-charge ratio. - Plasma confinement devices (e.g., tokamaks) \u2013 controlling plasma using magnetic fields. Understanding the Lorentz force enables the design and analysis of such systems.","title":"1. Introduction and Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-lorentz-force-equation","text":"The Lorentz force \\(\\vec{F}\\) acting on a charged particle is given by: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: - \\(q\\) : Charge of the particle - \\(\\vec{E}\\) : Electric field - \\(\\vec{B}\\) : Magnetic field - \\(\\vec{v}\\) : Particle velocity Using Newton\u2019s Second Law: \\[ \\vec{F} = m \\frac{d\\vec{v}}{dt} \\] We obtain the equation of motion: \\[ m \\frac{d\\vec{v}}{dt} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This equation is generally solved numerically due to the complexity of \\(\\vec{v} \\times \\vec{B}\\) .","title":"2. Lorentz Force Equation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-simulation-overview","text":"We simulate particle trajectories using the 4th-order Runge-Kutta method for accuracy. Scenarios Simulated: 1. Uniform magnetic field only: Circular motion. 2. Parallel \\(\\vec{E}\\) and \\(\\vec{B}\\) : Helical motion. 3. Crossed fields: Drift motion. Parameters that can be varied: - Electric field strength \\(\\vec{E}\\) - Magnetic field strength \\(\\vec{B}\\) - Initial velocity \\(\\vec{v}_0\\) - Charge \\(q\\) and mass \\(m\\)","title":"3. Simulation Overview"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from matplotlib.collections import LineCollection import os # Required for operating system functions (like creating directories) from IPython.display import Image, display # For displaying in Colab # --- Constants --- q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # --- Initial conditions --- r0 = np.array([1.0, 0.0, 0.0]) # Initial position (m) v0 = np.array([0.0, 1.0, 0.0]) # Initial velocity perpendicular to B (m/s) y0 = np.concatenate((r0, v0)) # Combine position and velocity # --- Lorentz force differential equation --- def lorentz(t, y): r = y[:3] v = y[3:] dvdt = (q / m) * (E + np.cross(v, B)) return np.concatenate((v, dvdt)) # --- Time setup --- t_span = (0, 10) t_eval = np.linspace(*t_span, 500) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) x, y = sol.y[0], sol.y[1] # --- Color gradient path --- points = np.array([x, y]).T.reshape(-1, 1, 2) segments = np.concatenate([points[:-1], points[1:]], axis=1) norm = plt.Normalize(t_eval.min(), t_eval.max()) # Using 'magma' or 'viridis' for a cooler gradient lc = LineCollection(segments, cmap='viridis', norm=norm) lc.set_array(t_eval) lc.set_linewidth(3.0) # Slightly thicker line for better visibility # --- Plot --- fig, ax = plt.subplots(figsize=(9, 7)) # Slightly larger figure fig.patch.set_facecolor('#282C34') # Dark background for the figure ax.set_facecolor('#21252B') # Dark background for the plot area ax.add_collection(lc) # Add the colored line collection to the plot # Particle start and end points with distinct markers and colors ax.scatter(x[0], y[0], color='#00FF00', s=100, label='Start Point', zorder=5, edgecolors='white', linewidth=0.8) # Bright green, larger ax.scatter(x[-1], y[-1], color='#FF4500', s=100, label='End Point', zorder=5, edgecolors='white', linewidth=0.8) # Orange-red, larger # Labels and Title ax.set_xlabel('X Position (m)', color='#ABB2BF', fontsize=12) ax.set_ylabel('Y Position (m)', color='#ABB2BF', fontsize=12) ax.set_title('Charged Particle Trajectory in a Uniform Magnetic Field', color='#61AFEF', fontsize=18, weight='bold') # Blue, larger, bold title # Grid and Ticks ax.grid(True, linestyle='--', alpha=0.4, color='#3E4452') # Subtler grid ax.tick_params(axis='x', colors='#ABB2BF', labelsize=10) ax.tick_params(axis='y', colors='#ABB2BF', labelsize=10) # Aspect Ratio ax.axis('equal') # Ensures circular motion appears circular # Color bar for time cbar = fig.colorbar(lc, ax=ax, label='Time (s)', shrink=0.75, pad=0.03) # Shrink and position cbar.set_label('Time (s)', color='#ABB2BF', fontsize=12) cbar.ax.tick_params(colors='#ABB2BF') # Colorbar tick labels # Legend ax.legend(facecolor='#21252B', edgecolor='#3E4452', labelcolor='white', fontsize=10) # Styled legend plt.tight_layout() # Adjust plot to prevent labels from overlapping # --- Save to PNG (or JPG if preferred, for static images) --- # For GitHub Pages, saving as PNG is often good for static plots. # The image will be saved in the \"4 Electromagnetism\" folder. output_dir = \"4 Electromagnetism\" # Your target directory name os.makedirs(output_dir, exist_ok=True) # Create the directory if it doesn't exist # Using a descriptive filename for the static plot image_path = os.path.join(output_dir, \"charged_particle_trajectory.png\") plt.savefig(image_path, dpi=300, bbox_inches='tight', facecolor=fig.get_facecolor()) # Save the plot with high DPI plt.close(fig) # Close the plot to free memory # --- Display in Notebook (if using Jupyter/Colab) --- display(Image(filename=image_path)) import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation, PillowWriter from scipy.integrate import solve_ivp from IPython.display import Image, display import os # \u0130\u015fletim sistemi fonksiyonlar\u0131 i\u00e7in gerekli # --- Constants --- q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # --- Initial Conditions --- v0 = np.array([1.0, 0.0, 0.0]) # Velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Position (m) y0 = np.concatenate((r0, v0)) # Combine initial state (position and velocity) # --- Lorentz Force Function --- def lorentz(t, y): r = y[:3] # Extract position components (x, y, z) v = y[3:] # Extract velocity components (vx, vy, vz) dvdt = (q / m) * (E + np.cross(v, B)) # Calculate acceleration based on Lorentz force return np.concatenate((v, dvdt)) # Return concatenated velocity and acceleration # --- Time Settings --- t_span = (0, 10) # Time interval for simulation (start, end) t_eval = np.linspace(t_span[0], t_span[1], 500) # Points at which to evaluate the solution sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) # Solve the differential equation x, y = sol.y[0], sol.y[1] # Extract x and y components for 2D plotting z = sol.y[2] # Extract z component (will be flat in circular motion if B is along z) # --- Set Up Plot --- fig, ax = plt.subplots(figsize=(8, 8)) # Create a figure and a set of subplots fig.patch.set_facecolor('#282C34') # Set the background color of the figure ax.set_facecolor('#21252B') # Set the background color of the plot area ax.set_xlim(np.min(x)*1.1, np.max(x)*1.1) # Set x-axis limits with a small buffer ax.set_ylim(np.min(y)*1.1, np.max(y)*1.1) # Set y-axis limits with a small buffer ax.set_xlabel(\"x (m)\", color='#ABB2BF') # X-axis label ax.set_ylabel(\"y (m)\", color='#ABB2BF') # Y-axis label ax.set_title(\"Charged Particle Motion in a Magnetic Field\", color='#61AFEF', fontsize=16) # Plot title ax.grid(True, linestyle='--', alpha=0.5, color='#3E4452') # Add a subtle grid ax.tick_params(axis='x', colors='#ABB2BF') # Set x-axis tick label color ax.tick_params(axis='y', colors='#ABB2BF') # Set y-axis tick label color line, = ax.plot([], [], lw=2, color='#98C379', alpha=0.9) # Initialize the line for the particle's path point, = ax.plot([], [], 'o', color='#E06C75', markersize=8, markeredgecolor='#E06C75') # Initialize the point for the current position # --- Init Function for Animation --- def init(): line.set_data([], []) # Clear line data point.set_data([], []) # Clear point data return line, point # Return the plot objects to be updated # --- Update Function for Animation --- def update(i): if i < len(x): # Ensure index is within bounds line.set_data(x[:i+1], y[:i+1]) # Update the path up to the current frame point.set_data([x[i]], [y[i]]) # Update the current particle position return line, point # Return the updated plot objects # --- Create Animation --- # FuncAnimation creates the animation by repeatedly calling the update function ani = FuncAnimation(fig, update, frames=len(x), init_func=init, blit=False, interval=20) # --- Save to GIF --- # GIF'i \"4 Electromagnetism\" klas\u00f6r\u00fcn\u00fcn i\u00e7ine kaydedecek \u015fekilde g\u00fcncellendi. # Bu klas\u00f6r yoksa olu\u015fturulur. output_dir = \"4 Electromagnetism\" # Hedef klas\u00f6r ad\u0131n\u0131z os.makedirs(output_dir, exist_ok=True) # Klas\u00f6r\u00fc olu\u015ftur (zaten varsa hata vermez) gif_path = os.path.join(output_dir, \"charged_particle_motion_animated.gif\") # Klas\u00f6r i\u00e7inde kaydet writer = PillowWriter(fps=30) # Initialize GIF writer with 30 frames per second ani.save(gif_path, writer=writer, dpi=150) # Save the animation to a GIF file with higher DPI for better quality plt.close() # Close the plot window to free up resources, important for Colab and non-interactive environments # --- Display in Notebook (if using Jupyter/Colab) --- # This line displays the saved GIF directly within the Colab or Jupyter notebook output. display(Image(filename=gif_path)) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Explicitly import Axes3D from matplotlib import cm # For colormaps import os # Required for operating system functions (like creating directories) from IPython.display import Image, display # For displaying images in Colab # --- Constants --- q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 1.0]) # Electric field (V/m) - now along z-axis B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) - now along z-axis # --- Initial conditions --- v0 = np.array([1.0, 0.0, 0.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) y0 = np.concatenate((v0, r0)) # Combine initial state: velocity then position # --- Lorentz force differential equation --- def lorentz(t, y): v = y[:3] # Extract velocity components (vx, vy, vz) r = y[3:] # Extract position components (x, y, z) dvdt = (q / m) * (E + np.cross(v, B)) # Calculate acceleration based on Lorentz force return np.concatenate((dvdt, v)) # Return concatenated acceleration (dv/dt) and velocity (dr/dt) # --- Time setup --- t_span = (0, 10) # Time interval for simulation (start, end) t_eval = np.linspace(*t_span, 1000) # Points at which to evaluate the solution (1000 points) sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) # Solve the differential equation # Extract position components from the solution x, y, z = sol.y[3], sol.y[4], sol.y[5] # --- 3D Plot --- fig = plt.figure(figsize=(14, 10)) # Larger figure for 3D plot fig.patch.set_facecolor('#282C34') # Dark background for the figure ax = fig.add_subplot(111, projection='3d') # Add a 3D subplot ax.set_facecolor('#21252B') # Dark background for the plot area (3D specific) # Plot the full trajectory (lighter, semi-transparent for context) ax.plot(x, y, z, lw=1.5, c='#ABB2BF', alpha=0.4) # Lighter gray, slightly thicker line # Scatter points colored by time (for better visual appeal) scatter = ax.scatter(x, y, z, c=sol.t, cmap='viridis', s=8, alpha=0.9, edgecolor='none') # Larger, more visible points # Mark start and end points ax.scatter(x[0], y[0], z[0], color='#00FF00', label='Start Point', s=150, zorder=5, edgecolors='white', linewidth=1.5) # Bright green, larger marker ax.scatter(x[-1], y[-1], z[-1], color='#FF4500', label='End Point', s=150, zorder=5, edgecolors='white', linewidth=1.5) # Orange-red, larger marker # Set labels with dark theme colors ax.set_xlabel('X Position (m)', color='#ABB2BF', fontsize=12) ax.set_ylabel('Y Position (m)', color='#ABB2BF', fontsize=12) ax.set_zlabel('Z Position (m)', color='#ABB2BF', fontsize=12) # Set title with dark theme colors ax.set_title('3D Trajectory of a Charged Particle in\\nElectric & Magnetic Fields', color='#61AFEF', weight='bold', fontsize=18, pad=20) # Blue, larger, bold title, higher padding # Customize grid, tick labels, and axes for dark theme ax.tick_params(axis='x', colors='#ABB2BF', labelsize=10) ax.tick_params(axis='y', colors='#ABB2BF', labelsize=10) ax.tick_params(axis='z', colors='#ABB2BF', labelsize=10) # Set grid line colors ax.xaxis.pane.set_edgecolor('#3E4452') ax.yaxis.pane.set_edgecolor('#3E4452') ax.zaxis.pane.set_edgecolor('#3E4452') ax.xaxis.pane.set_facecolor('#21252B') # Make panes match ax background ax.yaxis.pane.set_facecolor('#21252B') ax.zaxis.pane.set_facecolor('#21252B') ax.grid(True, linestyle='--', alpha=0.4, color='#3E4452') # Subtler grid lines # Color bar for time cbar = fig.colorbar(scatter, ax=ax, label='Time (s)', shrink=0.7, pad=0.08) # Adjusted shrink and pad for 3D cbar.set_label('Time (s)', color='#ABB2BF', fontsize=12) cbar.ax.tick_params(colors='#ABB2BF') # Colorbar tick labels # Legend ax.legend(facecolor='#21252B', edgecolor='#3E4452', labelcolor='white', fontsize=10) # Styled legend plt.tight_layout(rect=[0, 0, 1, 0.95]) # Adjust layout to prevent title overlap # --- Save to PNG --- # The image will be saved in the \"4 Electromagnetism\" folder, as requested. # It will create the directory if it doesn't exist. output_dir = \"4 Electromagnetism\" # Your target directory name os.makedirs(output_dir, exist_ok=True) # Create the directory if it doesn't exist # Using a descriptive filename for the static 3D plot image_path = os.path.join(output_dir, \"3d_charged_particle_trajectory.png\") plt.savefig(image_path, dpi=300, bbox_inches='tight', facecolor=fig.get_facecolor()) # Save with high DPI plt.close(fig) # Close the plot to free memory # --- Display in Notebook (if using Jupyter/Colab) --- display(Image(filename=image_path)) import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp from mpl_toolkits.mplot3d import Axes3D # Explicitly import Axes3D import os # Required for operating system functions (like creating directories) from IPython.display import Image, display # For displaying images in Colab # --- Constants --- q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([1.0, 0.0, 0.0]) # Electric field (V/m) - along x-axis for drift B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) - along z-axis # --- Initial conditions --- v0 = np.array([0.0, 1.0, 0.0]) # Initial velocity (m/s) r0 = np.array([0.0, 0.0, 0.0]) # Initial position (m) y0 = np.concatenate((v0, r0)) # Combine initial state: velocity then position # --- Lorentz force differential equation --- def lorentz(t, y): v = y[:3] # Extract velocity components (vx, vy, vz) r = y[3:] # Extract position components (x, y, z) dvdt = (q / m) * (E + np.cross(v, B)) # Calculate acceleration based on Lorentz force return np.concatenate((dvdt, v)) # Return concatenated acceleration (dv/dt) and velocity (dr/dt) # --- Time settings --- t_span = (0, 20) # Time interval for simulation (start, end) t_eval = np.linspace(*t_span, 2000) # Points at which to evaluate the solution (2000 points for smoothness) # --- Solve the ODE --- sol = solve_ivp(lorentz, t_span, y0, t_eval=t_eval) # Extract position components from the solution x, y, z = sol.y[3], sol.y[4], sol.y[5] # --- 3D Plotting --- fig = plt.figure(figsize=(12, 8)) # Slightly larger figure for better detail fig.patch.set_facecolor('#282C34') # Dark background for the figure ax = fig.add_subplot(111, projection='3d') # Add a 3D subplot ax.set_facecolor('#21252B') # Dark background for the plot area # Plot the trajectory with enhanced styling ax.plot(x, y, z, color='#FFD700', lw=2.5, label='Drift Trajectory', alpha=0.9) # Gold color, slightly thicker, opaque # Add start and end points for clarity ax.scatter(x[0], y[0], z[0], color='#00FF00', s=120, label='Start Point', zorder=5, edgecolors='white', linewidth=1.2) # Bright green ax.scatter(x[-1], y[-1], z[-1], color='#FF4500', s=120, label='End Point', zorder=5, edgecolors='white', linewidth=1.2) # Orange-red # Labels and style for dark theme ax.set_xlabel('X Position (m)', color='#ABB2BF', fontsize=12, labelpad=10) # Label padding ax.set_ylabel('Y Position (m)', color='#ABB2BF', fontsize=12, labelpad=10) ax.set_zlabel('Z Position (m)', color='#ABB2BF', fontsize=12, labelpad=10) ax.tick_params(colors='#ABB2BF', labelsize=10) # Tick label colors # Adjust grid and background panes for 3D plot ax.xaxis.pane.set_edgecolor('#3E4452') # Grid line colors for the panes ax.yaxis.pane.set_edgecolor('#3E4452') ax.zaxis.pane.set_edgecolor('#3E4452') ax.xaxis.pane.set_facecolor('#21252B') # Pane face colors ax.yaxis.pane.set_facecolor('#21252B') ax.zaxis.pane.set_facecolor('#21252B') ax.grid(True, color='#3E4452', linestyle='--', alpha=0.5) # Subtler grid lines # Title plt.title(\"Drift Motion of a Charged Particle\", color='#61AFEF', fontsize=18, weight='bold', pad=20) # Blue, larger, bold title, padding # Legend ax.legend(loc='upper right', facecolor='#21252B', edgecolor='#3E4452', labelcolor='white', fontsize=10) # Styled legend plt.tight_layout(rect=[0, 0, 1, 0.95]) # Adjust layout to prevent title overlap # --- Save to PNG --- # The image will be saved in the \"4 Electromagnetism\" folder. output_dir = \"4 Electromagnetism\" # Your target directory name os.makedirs(output_dir, exist_ok=True) # Create the directory if it doesn't exist # Using a descriptive filename for the static 3D plot image_path = os.path.join(output_dir, \"drift_motion_trajectory.png\") plt.savefig(image_path, dpi=300, bbox_inches='tight', facecolor=fig.get_facecolor()) # Save with high DPI plt.close(fig) # Close the plot to free memory # --- Display in Notebook (if using Jupyter/Colab) --- display(Image(filename=image_path))","title":"4. Code Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-results-and-visualizations","text":"","title":"5. Results and Visualizations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-1-circular-motion","text":"\\(\\vec{E} = 0\\) \\(\\vec{B} = [0, 0, B]\\) Initial velocity perpendicular to \\(\\vec{B}\\) Expected motion: circular From theory: \\[ r_L = \\frac{mv}{|q||B|} \\quad \\text{(Larmor radius)} \\] Plot: [Circular orbit in x-y plane]","title":"Case 1: Circular Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-2-helical-motion","text":"\\(\\vec{E} = [0, 0, E]\\) \\(\\vec{B} = [0, 0, B]\\) Expected motion: helix, as velocity has components both parallel and perpendicular to \\(\\vec{B}\\) . Plot: [3D helical path]","title":"Case 2: Helical Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-3-crossed-fields-drift","text":"\\(\\vec{E} = [0, E, 0]\\)","title":"Case 3: Crossed Fields (Drift)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-3-crossed-fields-drift_1","text":"\\(\\vec{E} = [0, E, 0]\\) \\(\\vec{B} = [0, 0, B]\\) Expected motion: drift velocity in x-direction: \\[ \\vec{v}_d = \\frac{\\vec{E} \\times \\vec{B}}{B^2} \\] Plot: [Curved motion with net drift]","title":"Case 3: Crossed Fields (Drift)"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 \ud83d\udcca Simulating Sampling Distributions \ud83c\udfaf Objective To demonstrate the Central Limit Theorem (CLT), we begin by generating large populations from various distributions: Uniform Distribution Exponential Distribution Binomial Distribution Each dataset will represent a \"population\", from which we will later draw repeated random samples to study the behavior of their means. \ud83d\udd22 Step 1: Generate Populations Let: - \\(N = 100000\\) be the size of each simulated population. We will define each population as follows: Uniform Distribution : \\[X \\sim \\text{Uniform}(a=0, b=1)\\] Exponential Distribution : \\[X \\sim \\text{Exponential}(\\lambda=1)\\] Binomial Distribution : \\[X \\sim \\text{Binomial}(n=10, p=0.5)\\] import numpy as np import matplotlib.pyplot as plt # Set seed for reproducibility np.random.seed(42) # Population size N = 100_000 # --- Generate Populations --- # 1. Uniform Distribution: U(0, 1) population_uniform = np.random.uniform(low=0, high=1, size=N) # 2. Exponential Distribution: Exp(\u03bb=1) population_exponential = np.random.exponential(scale=1.0, size=N) # 3. Binomial Distribution: Binomial(n=10, p=0.5) population_binomial = np.random.binomial(n=10, p=0.5, size=N) # --- Set Styling for a Cooler Look --- plt.style.use('dark_background') plt.rcParams.update({ 'font.family': 'sans-serif', 'font.size': 14, 'axes.titlesize': 18, 'axes.labelsize': 14, 'axes.labelcolor': '#E0E0E0', 'axes.facecolor': '#1C2526', 'grid.color': '#444444', 'grid.alpha': 0.3, 'grid.linestyle': '--', 'text.color': '#E0E0E0' }) # --- Plot Histograms --- fig, axs = plt.subplots(1, 3, figsize=(18, 5), facecolor='#1C2526') # Uniform axs[0].hist(population_uniform, bins=50, color='#4682B4', edgecolor='#FFFFFF', linewidth=0.5) axs[0].set_title(\"Uniform(0,1) Distribution\", pad=10, fontweight='bold') axs[0].set_xlabel(\"Value\") axs[0].set_ylabel(\"Frequency\") axs[0].grid(True) # Exponential axs[1].hist(population_exponential, bins=50, color='#800020', edgecolor='#FFFFFF', linewidth=0.5) axs[1].set_title(\"Exponential(\u03bb=1) Distribution\", pad=10, fontweight='bold') axs[1].set_xlabel(\"Value\") axs[1].set_ylabel(\"Frequency\") axs[1].grid(True) # Binomial axs[2].hist(population_binomial, bins=range(0,12), color='#87CEEB', edgecolor='#FFFFFF', linewidth=0.5, align='left') axs[2].set_title(\"Binomial(n=10, p=0.5) Distribution\", pad=10, fontweight='bold') axs[2].set_xlabel(\"Value\") axs[2].set_ylabel(\"Frequency\") axs[2].grid(True) # Add a subtle glow effect with alpha for cooler visuals for ax in axs: ax.patch.set_alpha(0.9) plt.tight_layout() plt.show() \ud83e\uddea Step 2: Modeling Sampling Distributions \ud83c\udfaf Goal To investigate the Central Limit Theorem (CLT) by modeling how sample means behave when taken from various population distributions. \ud83d\udcda Central Limit Theorem (CLT) The Central Limit Theorem asserts: For a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , the distribution of the sample mean \\(\\bar{X}\\) approximates a normal distribution as the sample size \\(n\\) grows \u2014 irrespective of the original population's form. In mathematical terms, if \\(X_1, X_2, ..., X_n\\) are independent and identically distributed (i.i.d.) random variables with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , then the standardized sample mean: \\[ Z = \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\] approaches the standard normal distribution \\(N(0, 1)\\) in distribution as \\(n\\) becomes very large. \ud83d\udee0\ufe0f Simulation Strategy We will: Select a variety of sample sizes : \\(n = 5, 10, 30, 50\\) For each \\(n\\) : Extract a large number of samples (e.g., 1000) Calculate the sample mean for each sample Gather all sample means to create the sampling distribution Visualize histograms of these sampling distributions and monitor the trend toward normality \ud83d\udc0d Python Code import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set a custom dark theme with seaborn sns.set(style=\"darkgrid\", rc={\"axes.facecolor\": \"#1C2526\", \"figure.facecolor\": \"#1C2526\", \"grid.color\": \"#444444\", \"grid.alpha\": 0.3}) # Define population N = 100_000 np.random.seed(42) population = np.random.exponential(scale=1.0, size=N) # Sample sizes to test sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Number of samples per size # Custom color palette inspired by burgundy (#800020) and lighter blue (#4682B4) colors = ['#800020', '#4682B4', '#87CEEB', '#400010'] # Burgundy, Light Blue, Light Blue Accent, Dark Burgundy sns.set_palette(sns.color_palette(colors)) # Plotting fig, axs = plt.subplots(1, len(sample_sizes), figsize=(20, 5), facecolor='#1C2526') for i, n in enumerate(sample_sizes): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n, replace=False) sample_means.append(np.mean(sample)) sns.histplot(sample_means, bins=30, kde=True, ax=axs[i], edgecolor='#FFFFFF', linewidth=0.5) axs[i].set_title(f'n = {n}', fontsize=16, fontweight='bold', pad=10, color='#E0E0E0') axs[i].set_xlabel('Sample Mean', fontsize=12, color='#E0E0E0') axs[i].set_ylabel('Frequency', fontsize=12, color='#E0E0E0') axs[i].tick_params(colors='#E0E0E0') # Match tick colors to text # Add a subtle glow effect with alpha axs[i].patch.set_alpha(0.9) plt.suptitle('Sampling Distributions of Sample Means (Exponential Population)', fontsize=18, fontweight='bold', color='#87CEEB', y=1.05) plt.tight_layout() plt.show() \ud83d\udcc8 Step 3: Displaying Sampling Distribution Outcomes \ud83c\udfaf Aim Create histograms of the sample averages for each population distribution across different sample sizes. Analyze the speed of convergence of these sampling distributions toward a normal shape. Evaluate how the form of the initial population distribution influences convergence. \ud83d\udd0e Conceptual Foundation Consider the Central Limit Theorem (CLT) : For independent, identically distributed random variables \\(X_1, X_2, \\ldots, X_n\\) with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , the standardized sample mean \\[ Z = \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\] tends toward a standard normal distribution \\(N(0,1)\\) as the sample size \\(n\\) grows infinitely large. \ud83d\udccc Key Aspects to Note Sampling distributions for small \\(n\\) mirror the population's shape. With increasing \\(n\\) , the sampling distributions turn more symmetric and bell-like . The rate of convergence is influenced by the population distribution's: Skewness Kurtosis Variance \ud83d\udc0d Python Code for Visualization import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set a custom dark theme with seaborn sns.set(style=\"darkgrid\", rc={\"axes.facecolor\": \"#1C2526\", \"figure.facecolor\": \"#1C2526\", \"grid.color\": \"#444444\", \"grid.alpha\": 0.3}) # Set random seed for reproducibility np.random.seed(42) # Population size N = 100_000 # Generate populations populations = { \"Uniform[0,1]\": np.random.uniform(0, 1, N), \"Exponential(\u03bb=1)\": np.random.exponential(1, N), \"Binomial(n=10, p=0.5)\": np.random.binomial(n=10, p=0.5, size=N), } sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Custom color palette inspired by burgundy (#800020) and lighter blue (#4682B4) colors = ['#800020', '#4682B4', '#87CEEB'] # Burgundy, Light Blue, Light Blue Accent sns.set_palette(sns.color_palette(colors)) # Plotting fig, axes = plt.subplots(len(populations), len(sample_sizes), figsize=(20, 12), sharex='col', sharey='row', facecolor='#1C2526') for row_idx, (dist_name, population) in enumerate(populations.items()): for col_idx, n in enumerate(sample_sizes): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n, replace=False) sample_means.append(np.mean(sample)) ax = axes[row_idx, col_idx] sns.histplot(sample_means, bins=30, kde=True, color=colors[row_idx % len(colors)], ax=ax, edgecolor='#FFFFFF', linewidth=0.5) ax.set_title(f\"{dist_name}\\nSample Size $n={n}$\", fontsize=14, fontweight='bold', pad=10, color='#E0E0E0') if col_idx == 0: ax.set_ylabel('Frequency', fontsize=12, color='#E0E0E0') if row_idx == len(populations)-1: ax.set_xlabel('Sample Mean', fontsize=12, color='#E0E0E0') ax.tick_params(colors='#E0E0E0') # Match tick colors to text ax.grid(True) # Add a subtle glow effect with alpha ax.patch.set_alpha(0.9) plt.suptitle(\"Sampling Distributions of Sample Means Across Populations and Sample Sizes\", fontsize=18, fontweight='bold', color='#87CEEB', y=1.02) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() \ud83d\udd0e Step 4: Investigating Factors Shaping the Central Limit Theorem \ud83c\udfaf Goals Explore how the form of the initial population distribution impacts the speed of convergence to a normal shape. Assess the effect of sample size \\(n\\) on the approximation to a normal distribution. Study the influence of population variance \\(\\sigma^2\\) on the dispersion of the sampling distribution of the mean. 1. Role of Population Distribution Form The CLT ensures a move toward normality, but the pace of convergence hinges on the form of the population distribution. Distributions with significant skewness or heavy tails (e.g., Exponential, Cauchy) need larger sample sizes for the sample mean to near normality. For balanced and light-tailed distributions (e.g., Uniform, Binomial), the convergence tends to be quicker. 2. Effect of Sample Size \\(n\\) The sampling distribution of the mean \\(\\bar{X}\\) for sample size \\(n\\) exhibits: $$ \\text{Mean}(\\bar{X}) = \\mu $$ $$ \\text{Variance}(\\bar{X}) = \\frac{\\sigma^2}{n} $$ As \\(n\\) grows: The variance of \\(\\bar{X}\\) shrinks, making the sampling distribution more tightly clustered around \\(\\mu\\) . Per the CLT, the distribution of \\(\\bar{X}\\) nears the normal distribution: $$ \\bar{X} \\xrightarrow{d} N\\left(\\mu, \\frac{\\sigma^2}{n}\\right) $$ Visualizing various \\(n\\) values aids in tracking this clustering and shape evolution . 3. Influence of Population Variance \\(\\sigma^2\\) The spread of the sampling distribution is tied to the population variance \\(\\sigma^2\\) . A larger \\(\\sigma^2\\) results in greater variation in sample means . This underscores the importance of knowing or estimating \\(\\sigma^2\\) in statistical inference. \ud83d\udcca Overview of Connections The interplay of population form, sample size, and variance dictates how swiftly and closely the sampling distribution of the mean approaches normality. Core equation encapsulating the CLT: $$ Z = \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} N(0,1) $$ \ud83d\udc0d Next: Python Code to Test These Factors Model sampling distributions with varying: Population forms (e.g., Uniform, Exponential, Binomial) Sample sizes ( \\(n = 5, 10, 30, 50\\) ) Variances (e.g., by adjusting distribution scales) Illustrate the outcomes to enhance comprehension of the CLT in practice. import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set a custom dark theme with seaborn sns.set(style=\"darkgrid\", rc={\"axes.facecolor\": \"#1C2526\", \"figure.facecolor\": \"#1C2526\", \"grid.color\": \"#444444\", \"grid.alpha\": 0.3}) # Set random seed for reproducibility np.random.seed(42) # Population size for each distribution N = 100_000 # Define original populations with different shapes and variances populations = { \"Uniform[0,1]\": np.random.uniform(0, 1, N), # Variance = 1/12 ~0.083 \"Exponential(\u03bb=1)\": np.random.exponential(1, N), # Variance = 1 \"Binomial(n=10, p=0.5)\": np.random.binomial(n=10, p=0.5, size=N), # Variance = np(1-p) = 2.5 } # Scale exponential to higher variance for demonstration populations[\"Scaled Exponential (\u00d73)\"] = populations[\"Exponential(\u03bb=1)\"] * 3 # Variance ~9 sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Number of samples per sample size # Custom color palette inspired by burgundy (#800020) and lighter blue (#4682B4) colors = ['#800020', '#4682B4', '#87CEEB', '#400010'] # Burgundy, Light Blue, Light Blue Accent, Dark Burgundy sns.set_palette(sns.color_palette(colors)) # Plotting fig, axes = plt.subplots(len(populations), len(sample_sizes), figsize=(22, 14), sharex='col', sharey='row', facecolor='#1C2526') for row_idx, (dist_name, population) in enumerate(populations.items()): for col_idx, n in enumerate(sample_sizes): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n, replace=False) sample_means.append(np.mean(sample)) ax = axes[row_idx, col_idx] sns.histplot(sample_means, bins=30, kde=True, color=colors[row_idx % len(colors)], ax=ax, edgecolor='#FFFFFF', linewidth=0.5) ax.set_title(f\"{dist_name}\\nSample Size $n={n}$\", fontsize=14, fontweight='bold', pad=10, color='#E0E0E0') if col_idx == 0: ax.set_ylabel('Frequency', fontsize=12, color='#E0E0E0') if row_idx == len(populations) - 1: ax.set_xlabel('Sample Mean', fontsize=12, color='#E0E0E0') ax.tick_params(colors='#E0E0E0') # Match tick colors to text ax.grid(True) # Add a subtle glow effect with alpha ax.patch.set_alpha(0.9) plt.suptitle(\"Exploring Effects of Population Shape, Sample Size, and Variance on Sampling Distribution\", fontsize=18, fontweight='bold', color='#87CEEB', y=1.02) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulating-sampling-distributions","text":"","title":"\ud83d\udcca Simulating Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#objective","text":"To demonstrate the Central Limit Theorem (CLT), we begin by generating large populations from various distributions: Uniform Distribution Exponential Distribution Binomial Distribution Each dataset will represent a \"population\", from which we will later draw repeated random samples to study the behavior of their means.","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-1-generate-populations","text":"Let: - \\(N = 100000\\) be the size of each simulated population. We will define each population as follows: Uniform Distribution : \\[X \\sim \\text{Uniform}(a=0, b=1)\\] Exponential Distribution : \\[X \\sim \\text{Exponential}(\\lambda=1)\\] Binomial Distribution : \\[X \\sim \\text{Binomial}(n=10, p=0.5)\\] import numpy as np import matplotlib.pyplot as plt # Set seed for reproducibility np.random.seed(42) # Population size N = 100_000 # --- Generate Populations --- # 1. Uniform Distribution: U(0, 1) population_uniform = np.random.uniform(low=0, high=1, size=N) # 2. Exponential Distribution: Exp(\u03bb=1) population_exponential = np.random.exponential(scale=1.0, size=N) # 3. Binomial Distribution: Binomial(n=10, p=0.5) population_binomial = np.random.binomial(n=10, p=0.5, size=N) # --- Set Styling for a Cooler Look --- plt.style.use('dark_background') plt.rcParams.update({ 'font.family': 'sans-serif', 'font.size': 14, 'axes.titlesize': 18, 'axes.labelsize': 14, 'axes.labelcolor': '#E0E0E0', 'axes.facecolor': '#1C2526', 'grid.color': '#444444', 'grid.alpha': 0.3, 'grid.linestyle': '--', 'text.color': '#E0E0E0' }) # --- Plot Histograms --- fig, axs = plt.subplots(1, 3, figsize=(18, 5), facecolor='#1C2526') # Uniform axs[0].hist(population_uniform, bins=50, color='#4682B4', edgecolor='#FFFFFF', linewidth=0.5) axs[0].set_title(\"Uniform(0,1) Distribution\", pad=10, fontweight='bold') axs[0].set_xlabel(\"Value\") axs[0].set_ylabel(\"Frequency\") axs[0].grid(True) # Exponential axs[1].hist(population_exponential, bins=50, color='#800020', edgecolor='#FFFFFF', linewidth=0.5) axs[1].set_title(\"Exponential(\u03bb=1) Distribution\", pad=10, fontweight='bold') axs[1].set_xlabel(\"Value\") axs[1].set_ylabel(\"Frequency\") axs[1].grid(True) # Binomial axs[2].hist(population_binomial, bins=range(0,12), color='#87CEEB', edgecolor='#FFFFFF', linewidth=0.5, align='left') axs[2].set_title(\"Binomial(n=10, p=0.5) Distribution\", pad=10, fontweight='bold') axs[2].set_xlabel(\"Value\") axs[2].set_ylabel(\"Frequency\") axs[2].grid(True) # Add a subtle glow effect with alpha for cooler visuals for ax in axs: ax.patch.set_alpha(0.9) plt.tight_layout() plt.show()","title":"\ud83d\udd22 Step 1: Generate Populations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-2-modeling-sampling-distributions","text":"","title":"\ud83e\uddea Step 2: Modeling Sampling Distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#goal","text":"To investigate the Central Limit Theorem (CLT) by modeling how sample means behave when taken from various population distributions.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-clt","text":"The Central Limit Theorem asserts: For a population with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , the distribution of the sample mean \\(\\bar{X}\\) approximates a normal distribution as the sample size \\(n\\) grows \u2014 irrespective of the original population's form. In mathematical terms, if \\(X_1, X_2, ..., X_n\\) are independent and identically distributed (i.i.d.) random variables with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , then the standardized sample mean: \\[ Z = \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\] approaches the standard normal distribution \\(N(0, 1)\\) in distribution as \\(n\\) becomes very large.","title":"\ud83d\udcda Central Limit Theorem (CLT)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#simulation-strategy","text":"We will: Select a variety of sample sizes : \\(n = 5, 10, 30, 50\\) For each \\(n\\) : Extract a large number of samples (e.g., 1000) Calculate the sample mean for each sample Gather all sample means to create the sampling distribution Visualize histograms of these sampling distributions and monitor the trend toward normality","title":"\ud83d\udee0\ufe0f Simulation Strategy"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set a custom dark theme with seaborn sns.set(style=\"darkgrid\", rc={\"axes.facecolor\": \"#1C2526\", \"figure.facecolor\": \"#1C2526\", \"grid.color\": \"#444444\", \"grid.alpha\": 0.3}) # Define population N = 100_000 np.random.seed(42) population = np.random.exponential(scale=1.0, size=N) # Sample sizes to test sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Number of samples per size # Custom color palette inspired by burgundy (#800020) and lighter blue (#4682B4) colors = ['#800020', '#4682B4', '#87CEEB', '#400010'] # Burgundy, Light Blue, Light Blue Accent, Dark Burgundy sns.set_palette(sns.color_palette(colors)) # Plotting fig, axs = plt.subplots(1, len(sample_sizes), figsize=(20, 5), facecolor='#1C2526') for i, n in enumerate(sample_sizes): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n, replace=False) sample_means.append(np.mean(sample)) sns.histplot(sample_means, bins=30, kde=True, ax=axs[i], edgecolor='#FFFFFF', linewidth=0.5) axs[i].set_title(f'n = {n}', fontsize=16, fontweight='bold', pad=10, color='#E0E0E0') axs[i].set_xlabel('Sample Mean', fontsize=12, color='#E0E0E0') axs[i].set_ylabel('Frequency', fontsize=12, color='#E0E0E0') axs[i].tick_params(colors='#E0E0E0') # Match tick colors to text # Add a subtle glow effect with alpha axs[i].patch.set_alpha(0.9) plt.suptitle('Sampling Distributions of Sample Means (Exponential Population)', fontsize=18, fontweight='bold', color='#87CEEB', y=1.05) plt.tight_layout() plt.show()","title":"\ud83d\udc0d Python Code"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-3-displaying-sampling-distribution-outcomes","text":"","title":"\ud83d\udcc8 Step 3: Displaying Sampling Distribution Outcomes"},{"location":"1%20Physics/6%20Statistics/Problem_1/#aim","text":"Create histograms of the sample averages for each population distribution across different sample sizes. Analyze the speed of convergence of these sampling distributions toward a normal shape. Evaluate how the form of the initial population distribution influences convergence.","title":"\ud83c\udfaf Aim"},{"location":"1%20Physics/6%20Statistics/Problem_1/#conceptual-foundation","text":"Consider the Central Limit Theorem (CLT) : For independent, identically distributed random variables \\(X_1, X_2, \\ldots, X_n\\) with mean \\(\\mu\\) and variance \\(\\sigma^2\\) , the standardized sample mean \\[ Z = \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\] tends toward a standard normal distribution \\(N(0,1)\\) as the sample size \\(n\\) grows infinitely large.","title":"\ud83d\udd0e Conceptual Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-aspects-to-note","text":"Sampling distributions for small \\(n\\) mirror the population's shape. With increasing \\(n\\) , the sampling distributions turn more symmetric and bell-like . The rate of convergence is influenced by the population distribution's: Skewness Kurtosis Variance","title":"\ud83d\udccc Key Aspects to Note"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-for-visualization","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set a custom dark theme with seaborn sns.set(style=\"darkgrid\", rc={\"axes.facecolor\": \"#1C2526\", \"figure.facecolor\": \"#1C2526\", \"grid.color\": \"#444444\", \"grid.alpha\": 0.3}) # Set random seed for reproducibility np.random.seed(42) # Population size N = 100_000 # Generate populations populations = { \"Uniform[0,1]\": np.random.uniform(0, 1, N), \"Exponential(\u03bb=1)\": np.random.exponential(1, N), \"Binomial(n=10, p=0.5)\": np.random.binomial(n=10, p=0.5, size=N), } sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Custom color palette inspired by burgundy (#800020) and lighter blue (#4682B4) colors = ['#800020', '#4682B4', '#87CEEB'] # Burgundy, Light Blue, Light Blue Accent sns.set_palette(sns.color_palette(colors)) # Plotting fig, axes = plt.subplots(len(populations), len(sample_sizes), figsize=(20, 12), sharex='col', sharey='row', facecolor='#1C2526') for row_idx, (dist_name, population) in enumerate(populations.items()): for col_idx, n in enumerate(sample_sizes): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n, replace=False) sample_means.append(np.mean(sample)) ax = axes[row_idx, col_idx] sns.histplot(sample_means, bins=30, kde=True, color=colors[row_idx % len(colors)], ax=ax, edgecolor='#FFFFFF', linewidth=0.5) ax.set_title(f\"{dist_name}\\nSample Size $n={n}$\", fontsize=14, fontweight='bold', pad=10, color='#E0E0E0') if col_idx == 0: ax.set_ylabel('Frequency', fontsize=12, color='#E0E0E0') if row_idx == len(populations)-1: ax.set_xlabel('Sample Mean', fontsize=12, color='#E0E0E0') ax.tick_params(colors='#E0E0E0') # Match tick colors to text ax.grid(True) # Add a subtle glow effect with alpha ax.patch.set_alpha(0.9) plt.suptitle(\"Sampling Distributions of Sample Means Across Populations and Sample Sizes\", fontsize=18, fontweight='bold', color='#87CEEB', y=1.02) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"\ud83d\udc0d Python Code for Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/#step-4-investigating-factors-shaping-the-central-limit-theorem","text":"","title":"\ud83d\udd0e Step 4: Investigating Factors Shaping the Central Limit Theorem"},{"location":"1%20Physics/6%20Statistics/Problem_1/#goals","text":"Explore how the form of the initial population distribution impacts the speed of convergence to a normal shape. Assess the effect of sample size \\(n\\) on the approximation to a normal distribution. Study the influence of population variance \\(\\sigma^2\\) on the dispersion of the sampling distribution of the mean.","title":"\ud83c\udfaf Goals"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-role-of-population-distribution-form","text":"The CLT ensures a move toward normality, but the pace of convergence hinges on the form of the population distribution. Distributions with significant skewness or heavy tails (e.g., Exponential, Cauchy) need larger sample sizes for the sample mean to near normality. For balanced and light-tailed distributions (e.g., Uniform, Binomial), the convergence tends to be quicker.","title":"1. Role of Population Distribution Form"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-effect-of-sample-size-n","text":"The sampling distribution of the mean \\(\\bar{X}\\) for sample size \\(n\\) exhibits: $$ \\text{Mean}(\\bar{X}) = \\mu $$ $$ \\text{Variance}(\\bar{X}) = \\frac{\\sigma^2}{n} $$ As \\(n\\) grows: The variance of \\(\\bar{X}\\) shrinks, making the sampling distribution more tightly clustered around \\(\\mu\\) . Per the CLT, the distribution of \\(\\bar{X}\\) nears the normal distribution: $$ \\bar{X} \\xrightarrow{d} N\\left(\\mu, \\frac{\\sigma^2}{n}\\right) $$ Visualizing various \\(n\\) values aids in tracking this clustering and shape evolution .","title":"2. Effect of Sample Size \\(n\\)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-influence-of-population-variance-sigma2","text":"The spread of the sampling distribution is tied to the population variance \\(\\sigma^2\\) . A larger \\(\\sigma^2\\) results in greater variation in sample means . This underscores the importance of knowing or estimating \\(\\sigma^2\\) in statistical inference.","title":"3. Influence of Population Variance \\(\\sigma^2\\)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#overview-of-connections","text":"The interplay of population form, sample size, and variance dictates how swiftly and closely the sampling distribution of the mean approaches normality. Core equation encapsulating the CLT: $$ Z = \\frac{\\bar{X} - \\mu}{\\sigma/\\sqrt{n}} \\xrightarrow{d} N(0,1) $$","title":"\ud83d\udcca Overview of Connections"},{"location":"1%20Physics/6%20Statistics/Problem_1/#next-python-code-to-test-these-factors","text":"Model sampling distributions with varying: Population forms (e.g., Uniform, Exponential, Binomial) Sample sizes ( \\(n = 5, 10, 30, 50\\) ) Variances (e.g., by adjusting distribution scales) Illustrate the outcomes to enhance comprehension of the CLT in practice. import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set a custom dark theme with seaborn sns.set(style=\"darkgrid\", rc={\"axes.facecolor\": \"#1C2526\", \"figure.facecolor\": \"#1C2526\", \"grid.color\": \"#444444\", \"grid.alpha\": 0.3}) # Set random seed for reproducibility np.random.seed(42) # Population size for each distribution N = 100_000 # Define original populations with different shapes and variances populations = { \"Uniform[0,1]\": np.random.uniform(0, 1, N), # Variance = 1/12 ~0.083 \"Exponential(\u03bb=1)\": np.random.exponential(1, N), # Variance = 1 \"Binomial(n=10, p=0.5)\": np.random.binomial(n=10, p=0.5, size=N), # Variance = np(1-p) = 2.5 } # Scale exponential to higher variance for demonstration populations[\"Scaled Exponential (\u00d73)\"] = populations[\"Exponential(\u03bb=1)\"] * 3 # Variance ~9 sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Number of samples per sample size # Custom color palette inspired by burgundy (#800020) and lighter blue (#4682B4) colors = ['#800020', '#4682B4', '#87CEEB', '#400010'] # Burgundy, Light Blue, Light Blue Accent, Dark Burgundy sns.set_palette(sns.color_palette(colors)) # Plotting fig, axes = plt.subplots(len(populations), len(sample_sizes), figsize=(22, 14), sharex='col', sharey='row', facecolor='#1C2526') for row_idx, (dist_name, population) in enumerate(populations.items()): for col_idx, n in enumerate(sample_sizes): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=n, replace=False) sample_means.append(np.mean(sample)) ax = axes[row_idx, col_idx] sns.histplot(sample_means, bins=30, kde=True, color=colors[row_idx % len(colors)], ax=ax, edgecolor='#FFFFFF', linewidth=0.5) ax.set_title(f\"{dist_name}\\nSample Size $n={n}$\", fontsize=14, fontweight='bold', pad=10, color='#E0E0E0') if col_idx == 0: ax.set_ylabel('Frequency', fontsize=12, color='#E0E0E0') if row_idx == len(populations) - 1: ax.set_xlabel('Sample Mean', fontsize=12, color='#E0E0E0') ax.tick_params(colors='#E0E0E0') # Match tick colors to text ax.grid(True) # Add a subtle glow effect with alpha ax.patch.set_alpha(0.9) plt.suptitle(\"Exploring Effects of Population Shape, Sample Size, and Variance on Sampling Distribution\", fontsize=18, fontweight='bold', color='#87CEEB', y=1.02) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"\ud83d\udc0d Next: Python Code to Test These Factors"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 \ud83d\udcd8 Part 1: Approximating \u03c0 Using a Circle 1. Theoretical Background \ud83e\udde0 Conceptual Insight Monte Carlo techniques apply randomness to tackle problems that are fundamentally deterministic. To approximate \u03c0, we leverage the geometric connection between a circle and the square that encloses it: Imagine a unit circle (radius = 1) centered at the origin (0, 0). This circle fits perfectly within a square with a side length of 2, spanning coordinates from (-1, -1) to (1, 1). The area of the unit circle is: $$ A_{circle} = \\pi r^2 = \\pi \\cdot 1^2 = \\pi $$ The area of the surrounding square is: $$ A_{square} = (2r)^2 = (2 \\cdot 1)^2 = 4 $$ The ratio between these areas becomes: $$ \\frac{A_{circle}}{A_{square}} = \\frac{\\pi}{4} $$ So, when we uniformly sample points at random within the square, the likelihood that a point lands inside the circle is: $$ P(\\text{point inside circle}) = \\frac{\\pi}{4} $$ \ud83d\udd22 Estimating \u03c0 via Monte Carlo To derive \u03c0 using this probabilistic approach: Generate many random coordinate pairs \\((x, y)\\) in the square \\([-1, 1] \\times [-1, 1]\\) . Determine whether each point lies within the unit circle using: $$ x^2 + y^2 \\leq 1 $$ Record the number of points that fall inside the circle: \\(N_{circle}\\) Note the total number of sampled points: \\(N_{total}\\) Estimate \u03c0 using the expression: $$ \\hat{\\pi} = 4 \\cdot \\frac{N_{circle}}{N_{total}} $$ \u2705 Key Takeaways Monte Carlo estimation of \u03c0 depends on simulating random events and comparing relative counts. The more points you sample ( \\(N_{total}\\) ), the closer the estimate gets to the true value of \u03c0. This strategy intuitively combines geometry, probability, and numerical simulation .","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-approximating-using-a-circle","text":"","title":"\ud83d\udcd8 Part 1: Approximating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-background","text":"","title":"1. Theoretical Background"},{"location":"1%20Physics/6%20Statistics/Problem_2/#conceptual-insight","text":"Monte Carlo techniques apply randomness to tackle problems that are fundamentally deterministic. To approximate \u03c0, we leverage the geometric connection between a circle and the square that encloses it: Imagine a unit circle (radius = 1) centered at the origin (0, 0). This circle fits perfectly within a square with a side length of 2, spanning coordinates from (-1, -1) to (1, 1). The area of the unit circle is: $$ A_{circle} = \\pi r^2 = \\pi \\cdot 1^2 = \\pi $$ The area of the surrounding square is: $$ A_{square} = (2r)^2 = (2 \\cdot 1)^2 = 4 $$ The ratio between these areas becomes: $$ \\frac{A_{circle}}{A_{square}} = \\frac{\\pi}{4} $$ So, when we uniformly sample points at random within the square, the likelihood that a point lands inside the circle is: $$ P(\\text{point inside circle}) = \\frac{\\pi}{4} $$","title":"\ud83e\udde0 Conceptual Insight"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-via-monte-carlo","text":"To derive \u03c0 using this probabilistic approach: Generate many random coordinate pairs \\((x, y)\\) in the square \\([-1, 1] \\times [-1, 1]\\) . Determine whether each point lies within the unit circle using: $$ x^2 + y^2 \\leq 1 $$ Record the number of points that fall inside the circle: \\(N_{circle}\\) Note the total number of sampled points: \\(N_{total}\\) Estimate \u03c0 using the expression: $$ \\hat{\\pi} = 4 \\cdot \\frac{N_{circle}}{N_{total}} $$","title":"\ud83d\udd22 Estimating \u03c0 via Monte Carlo"},{"location":"1%20Physics/6%20Statistics/Problem_2/#key-takeaways","text":"Monte Carlo estimation of \u03c0 depends on simulating random events and comparing relative counts. The more points you sample ( \\(N_{total}\\) ), the closer the estimate gets to the true value of \u03c0. This strategy intuitively combines geometry, probability, and numerical simulation .","title":"\u2705 Key Takeaways"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}